/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"app": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./public/javascript/index.js",0]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./public/javascript/ag-grid-options-base.js":
/*!***************************************************!*\
  !*** ./public/javascript/ag-grid-options-base.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_cell_tooltip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/cell-tooltip.js */ "./public/javascript/utils/cell-tooltip.js");
/* harmony import */ var _utils_should_cell_update_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/should-cell-update.js */ "./public/javascript/utils/should-cell-update.js");
/* harmony import */ var _utils_value_formatter_percent_change_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/value-formatter-percent-change.js */ "./public/javascript/utils/value-formatter-percent-change.js");
/* harmony import */ var _utils_class_compound_cell_renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/class-compound-cell-renderer.js */ "./public/javascript/utils/class-compound-cell-renderer.js");
/* harmony import */ var _utils_filter_number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/filter-number.js */ "./public/javascript/utils/filter-number.js");
/* harmony import */ var _utils_filter_floating_number_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/filter-floating-number.js */ "./public/javascript/utils/filter-floating-number.js");
/* harmony import */ var _utils_sort_numbers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/sort-numbers.js */ "./public/javascript/utils/sort-numbers.js");
 // Cryptohub util functions


 // ag-grid valueFormatters

 // ag-grid cell Renderer Classes

 // ag-grid custom filters


 // ag-grid filter comparators

 //
// AG-GRID BASE OPTIONS
//
// Default ag-grid options before any configuration is applied
//

/* harmony default export */ __webpack_exports__["default"] = ({
  //
  // AG-GRID Components
  //
  // You can create your own custom components to customise the behaviour of the grid.
  // For example you can customise how cells are rendered, how values are edited and also create your own filters.
  //
  // The full list of component types you can provide in ag-Grid are as follows:
  //
  // Cell Renderer:        To customises the contents of a cell.
  // Cell Editor:          To customises editing of a cell.
  // Filter Component:     For custom column filter that appears inside the column menu.
  // Floating Filter:      For custom column filter that appears inside the column menu.
  // Date Component:       To customise the date selection component in the date filter.
  // Header Component:     To customise the header of a column and column groups.
  // Overlay Component:    To customise loading and no rows overlay components.
  // Status Bar Component: For custom status bar components.
  //
  components: {},
  //
  // AG-GRID columnTypes
  //
  // specific column types containing properties that column definitions can inherit.
  //
  columnTypes: {
    cryptohubDefaults: {
      // NOTE: the equals property is not shown in the standard list of ag-grid options
      // https://www.ag-grid.com/javascript-grid-change-detection/
      equals: _utils_should_cell_update_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      tooltip: _utils_cell_tooltip_js__WEBPACK_IMPORTED_MODULE_0__["default"]
    },
    cryptohubNumeric: {
      // Filter
      filter: _utils_filter_number_js__WEBPACK_IMPORTED_MODULE_4__["default"],
      suppressMenu: true,
      // Floating filter
      floatingFilterComponent: _utils_filter_floating_number_js__WEBPACK_IMPORTED_MODULE_5__["default"],
      floatingFilterComponentParams: {
        suppressMenu: true,
        suppressFilterButton: true
      },
      // Sort
      comparator: _utils_sort_numbers_js__WEBPACK_IMPORTED_MODULE_6__["default"],
      // Style
      cellClass: 'cryptohub-align-right'
    },
    cryptohubPercent: {
      cellClassRules: {
        'cryptohub-text-bad': function cryptohubTextBad(x) {
          return x.value && x.value.value < 0;
        },
        'cryptohub-text-good': function cryptohubTextGood(x) {
          return x.value && x.value.value > 0;
        }
      },
      valueFormatter: _utils_value_formatter_percent_change_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      // TODO the compound renderer is not what I planned it to be, revisit
      cellRenderer: _utils_class_compound_cell_renderer_js__WEBPACK_IMPORTED_MODULE_3__["default"]
    },
    cryptohubText: {
      filter: 'agTextColumnFilter'
    }
  },
  columnDefs: [],
  onCellMouseOver: function onCellMouseOver(params) {
    var field = params.colDef.field;
    var action = null;

    if (field === 'cc-total-vol-full-PRICE') {
      action = 'tradingview';
    }

    window.bo.inst.cellInteractions.mouseOver(params, action);
  },
  onCellMouseOut: function onCellMouseOut(params) {
    window.bo.inst.cellInteractions.mouseOut(params);
  },
  onVirtualColumnsChanged: function onVirtualColumnsChanged(params) {
    console.log(params);
  },
  onVirtualRowRemoved: function onVirtualRowRemoved(params) {
    console.log(params);
  },
  rowHeight: 35,
  // NOTE: DO NOT CHANGE UNLESS YOU WANT TO UPDATE HOW DATA WORKS
  rowData: window.refs.rowData,
  // Set to true to have cells flash after data changes. See Flashing Data Changes.
  enableCellChangeFlash: true,
  // Set to true when using Client-side Row Model to enable Row Filtering
  enableFilter: true,
  // Set to true when using Client-side Row Model to enable Row Sorting.
  // Clicking a column header will cause the grid to sort the data.
  enableSorting: true,
  // Floating Filter components allow you to add your own floating filter types to ag-Grid
  floatingFilter: true,
  // Set to true to allow column resizing by dragging the mouse at a columns headers edge.
  enableColResize: true,
  // If you turn on deltaRowDataMode, then when you call api.setRowData(rowData)
  // the grid will work out which items are to be added, removed and updated.
  // For this to work you must implement `getRowNodeId`.
  deltaRowDataMode: true,
  // Set to true to enable Row Animation.
  animateRows: false,
  // Type of Row Selection, set to either 'single' or 'multiple'.
  rowSelection: 'multiple',
  getRowNodeId: function getRowNodeId(data) {
    return data['cc-total-vol-full-Id'].value;
  },
  // defaultColDef: contains column properties all columns will inherit.
  defaultColDef: {
    editable: false,
    resizable: true,
    floatingFilterComponentParams: {
      suppressMenu: true,
      suppressFilterButton: true
    }
  }
});

/***/ }),

/***/ "./public/javascript/ag-grid-options-generate.js":
/*!*******************************************************!*\
  !*** ./public/javascript/ag-grid-options-generate.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return generateAgOptions; });
/* harmony import */ var _utils_convert_working_data_to_row_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/convert-working-data-to-row-data.js */ "./public/javascript/utils/convert-working-data-to-row-data.js");
/* harmony import */ var _utils_view_update_overview_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/view-update-overview.js */ "./public/javascript/utils/view-update-overview.js");
/* harmony import */ var _column_library_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./column-library.js */ "./public/javascript/column-library.js");
/* harmony import */ var _default_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./default-config.js */ "./public/javascript/default-config.js");
/* harmony import */ var _ag_grid_options_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ag-grid-options-base.js */ "./public/javascript/ag-grid-options-base.js");
 // Cryptohub util functions

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // ag-grid config




/**
 *
 * AG-GRID columnDefs
 *
 * Each column in the grid is defined using a column definition.
 * Columns are positioned in the grid according to the order the ColDef's are specified in the grid options
 *
 */

function generateColumnDefs(columns) {
  var id;
  var column;
  var output = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = columns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      column = _step.value;
      id = column.id;

      if (id in _column_library_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
        output.push(_column_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][id]);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return output;
}
/**
 *
 * On Grid Ready
 *
 */


function onGridReady(params) {
  // default sort order
  params.api.setSortModel([{
    colId: _column_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][_default_config_js__WEBPACK_IMPORTED_MODULE_3__["default"].sort.column].field,
    sort: _default_config_js__WEBPACK_IMPORTED_MODULE_3__["default"].sort.direction
  }]);
  window.bo.func.updated('now');
  window.refs.workingData = window.initData;
  window.refs.rowData = Object(_utils_convert_working_data_to_row_data_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.initData || {});
  params.api.setRowData(window.refs.rowData);
  Object(_utils_view_update_overview_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window.refs.workingData);
}

;
/**
 *
 * Generate AgOptions
 *
 */

function generateAgOptions() {
  if (!window.bo) throw new Error('window.bo does not exist');
  if (!window.refs) throw new Error('window.refs does not exist'); //
  // TODO: check if there is a url config
  // if there is use that and backfill with the default config
  // dont forget to make it very secure!!!
  //

  var columnDefs = generateColumnDefs(_default_config_js__WEBPACK_IMPORTED_MODULE_3__["default"].columns);

  var options = window.bo.agOptions = _objectSpread({}, _ag_grid_options_base_js__WEBPACK_IMPORTED_MODULE_4__["default"], {
    columnDefs: columnDefs
  }, {
    onGridReady: onGridReady
  });

  return options;
}

/***/ }),

/***/ "./public/javascript/classes/class-cell-interactions.js":
/*!**************************************************************!*\
  !*** ./public/javascript/classes/class-cell-interactions.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CellInteractions; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_popdiv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/popdiv.js */ "./public/javascript/utils/popdiv.js");
/* harmony import */ var _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../generated/init-pug.generated.js */ "./public/javascript/generated/init-pug.generated.js");
/* harmony import */ var _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_cell_on_click_tradingview_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cell-on-click-tradingview.js */ "./public/javascript/utils/cell-on-click-tradingview.js");
 // Binary Overdose Projects

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // Cryptohub util functions





var CellInteractions =
/*#__PURE__*/
function () {
  function CellInteractions() {
    _classCallCheck(this, CellInteractions);

    this.hovering$cell = null;
    this.openItems = [];
    this.tippyOptions = {
      theme: 'light',
      placement: 'right',
      hideOnClick: 'false',
      interactiveBorder: 5,
      interactiveDebounce: 1,
      onHide: function onHide(tippy) {
        var opened = tippy.reference.dataset.chOpen === 'true';
        var hovering = tippy.reference.dataset.chHover === 'true';
        if (opened || hovering) return false;else return true;
      }
    };
  }
  /**
   *
   * Open a popdiv
   *
   */


  _createClass(CellInteractions, [{
    key: "setMouseOverState",

    /**
     *
     * Set the mouse over state of a cell
     *
     */
    value: function setMouseOverState($cell, content) {
      Object(_utils_popdiv_js__WEBPACK_IMPORTED_MODULE_1__["default"])($cell, content, this.tippyOptions);
      $cell.$triggerTippy = $cell._tippy;
      $cell.classList.add('ch-cell-hover');
      $cell.dataset.chHover = 'true';
      this.hovering$cell = $cell;
    }
    /**
     *
     * Set the mouse out state of a cell
     *
     */

  }, {
    key: "setMouseOutState",
    value: function setMouseOutState($cell) {
      $cell.dataset.chHover = false;
      $cell.dataset.chOpen = false;
      this.hovering$cell = null;

      if ($cell.$triggerTippy) {
        $cell.$triggerTippy.reference.classList.remove('ch-cell-hover');
        $cell.$triggerTippy.destroy();

        if ($cell.$triggerTippy) {
          $cell.$trigger.removeEventListener('click', this.triggerClickHandler);
          $cell.$triggerTippy.destroy();
        }
      }
    }
    /**
     *
     * User clicked on a trigger
     *
     */

  }, {
    key: "triggerClickHandler",
    value: function triggerClickHandler(context, params, action) {
      var $cell = params.event.srcElement.closest('.ag-cell');

      if ($cell.dataset.chOpen === 'true') {
        context.setMouseOutState($cell);
        CellInteractions.close(params);
      } else {
        CellInteractions.open(params, action);
      }
    }
    /**
     *
     * Mouse out handler
     *
     */

  }, {
    key: "mouseOut",
    value: function mouseOut(params) {
      var $cell = params.event.srcElement.closest('.ag-cell');

      if (!$cell.$trigger) {
        this.setMouseOutState($cell);
      } // const $cell = params.event.srcElement.closest('.ag-cell');
      // if (this.hovering$cell && !hovering$cellOpen) {
      //   this.setMouseOutState(this.hovering$cell);
      // }
      //   const hovering = $cell.dataset.chHover === 'true';
      //   if (hovering) {
      //     $cell.dataset.chHover = false;
      //     // $cell.dataset.chOpen = false;
      //     if ($cell._tippy) {
      //       $cell._tippy.reference.classList.remove('ch-cell-hover');
      //       $cell._tippy.destroy();
      //     }
      //   }

    }
    /**
     *
     * Mouse over handler
     *
     */

  }, {
    key: "mouseOver",
    value: function mouseOver(params, action) {
      var id = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["getRandomInt"])();
      var $cell = params.event.srcElement.closest('.ag-cell');
      var width = $cell.scrollWidth;
      var height = $cell.scrollHeight;
      var content = _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default.a['ch-tippy-cell-hover']({
        id: id
      });
      var hovering$cellOpen = this.hovering$cell && this.hovering$cell.dataset.chOpen === 'true'; // If we are hovering over one that is already open

      if ($cell.dataset.chOpen === 'true') return; // If this is the same cell

      if ($cell === this.hovering$cell) return;

      if (this.hovering$cell && !hovering$cellOpen) {
        this.setMouseOutState(this.hovering$cell);
      } // If there are no actions


      if (!action) return;

      if ($cell.dataset.chHover !== 'true') {
        this.setMouseOverState($cell, content);
      } // this.active$cell = $cell;


      var $trigger = document.querySelector(".ch-tippy-cell-hover-".concat(id));
      if (!$trigger) return;
      $cell.$trigger = $trigger;
      $cell.$triggerTippy = $cell._tippy;
      $trigger.addEventListener('click', Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(this.triggerClickHandler, this, params, action), false);
    }
  }], [{
    key: "open",
    value: function open(params, action) {
      var $cell = params.event.srcElement.closest('.ag-cell'); // htmlToggleClass($cell, 'ch-cell-active');
      // this.setMouseOverState($cell);

      switch (action) {
        case 'tradingview':
          $cell.dataset.chOpen = true;

          $cell._tippy.set({
            hideOnClick: 'false'
          });

          Object(_utils_cell_on_click_tradingview_js__WEBPACK_IMPORTED_MODULE_3__["default"])('USD', params);
          $cell.$popDivTippy = $cell._tippy;
          break;

        default: // do nothing

      }
    }
    /**
     *
     * Close a popdiv
     *
     */

  }, {
    key: "close",
    value: function close(params) {
      var $cell = params.event.srcElement.closest('.ag-cell');

      if ($cell.$popDivTippy) {
        $cell.$popDivTippy.destroy();
      }
    }
  }]);

  return CellInteractions;
}();



/***/ }),

/***/ "./public/javascript/column-library.js":
/*!*********************************************!*\
  !*** ./public/javascript/column-library.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_class_cell_renderer_sparkline_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/class-cell-renderer-sparkline.js */ "./public/javascript/utils/class-cell-renderer-sparkline.js");
/* harmony import */ var _utils_cell_renderer_name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/cell-renderer-name.js */ "./public/javascript/utils/cell-renderer-name.js");
/* harmony import */ var _utils_cell_renderer_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/cell-renderer-number.js */ "./public/javascript/utils/cell-renderer-number.js");
/* harmony import */ var _utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/cell-renderer-currency.js */ "./public/javascript/utils/cell-renderer-currency.js");
/* harmony import */ var _utils_cell_renderer_exchanges_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/cell-renderer-exchanges.js */ "./public/javascript/utils/cell-renderer-exchanges.js");
/* harmony import */ var _utils_cell_renderer_tradingview_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/cell-renderer-tradingview.js */ "./public/javascript/utils/cell-renderer-tradingview.js");
/* harmony import */ var _utils_cell_on_click_exchanges_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/cell-on-click-exchanges.js */ "./public/javascript/utils/cell-on-click-exchanges.js");
/* harmony import */ var _utils_cell_on_click_tradingview_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/cell-on-click-tradingview.js */ "./public/javascript/utils/cell-on-click-tradingview.js");
/* harmony import */ var _utils_sort_numbers_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/sort-numbers.js */ "./public/javascript/utils/sort-numbers.js");
 // Binary Overdose Projects


 // ag-grid cell Renderer Classes

 // ag-grid cell Renderers





 // ag-grid cell on click handlers


 // ag-grid filter comparators


var columnDefs = {
  //
  // TODO: hash the column name (i.e. rowIndex)
  //
  //
  // The numeric index for each row
  // stays the same during sort and filtering
  // always counts from 1 to rows.length
  //
  rowIndex: {
    valueGetter: 'node.rowIndex',
    headerName: '#',
    headerClass: 'CH-col',
    headerTooltip: 'Row Number',
    width: 40,
    pinned: 'left',
    lockPosition: true,
    suppressMenu: true,
    suppressFilter: true,
    cellClass: 'cryptohub-align-right',
    cellRenderer: function cellRenderer(params) {
      return params.value + 1;
    },
    type: ['cryptohubNumeric']
  },
  //
  // Name
  // Asset icon, name & symbol
  //
  name: {
    field: 'cc-total-vol-full-FullName.value',
    headerName: 'Name',
    headerClass: 'CH-col',
    headerTooltip: 'Name',
    width: 180,
    pinned: 'left',
    cellRenderer: _utils_cell_renderer_name_js__WEBPACK_IMPORTED_MODULE_2__["default"]
  },
  //
  // Sector
  // A list of the assets sectors
  //
  sectors: {
    field: 'm-metrics-sectors',
    headerName: 'Sectors',
    headerClass: 'CH-col',
    headerTooltip: 'Sectors',
    width: 180,
    type: ['cryptohubText'],
    valueFormatter: function valueFormatter(params) {
      var value = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value');
      if (!Array.isArray(value) || !value.length) return ch.emptyCellValue;else return value;
    }
  },
  //
  // USD Price
  //
  priceUSD: {
    field: 'cc-total-vol-full-PRICE',
    headerName: 'Price (USD)',
    headerClass: 'CH-col',
    headerTooltip: 'Price in USD\n\nData Source: Cryptocompare',
    width: 120,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__["default"], window.refs),
    cellRendererParams: {
      currency: 'USD'
    } // onCellClicked: partialApplication(cellOnClickTradingview, 'USD'),

  },
  //
  // BTC Price
  //
  priceBTC: {
    field: 'cryptohub-price-btc',
    headerName: 'Price (BTC)',
    headerClass: 'CH-col',
    headerTooltip: 'Price in BTC\n\nData Source: BinaryOverdose, calculated from Cryptocompare data',
    width: 120,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__["default"], window.refs),
    cellRendererParams: {
      currency: 'SAT'
    },
    onCellClicked: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_on_click_tradingview_js__WEBPACK_IMPORTED_MODULE_8__["default"], 'BTC')
  },
  //
  // All Time High (USD)
  //
  athUSD: {
    field: 'm-metrics-ath-price',
    headerName: 'ATH',
    headerClass: 'CH-col',
    headerTooltip: 'All Time High (USD)\n\nData Source: OnChainFX',
    width: 120,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__["default"], window.refs),
    cellRendererParams: {
      currency: 'USD'
    }
  },
  //
  // Cycle low (USD)
  //
  // This is the lowest trading price (in USD) of the asset since its All-Time-High.
  // Notes about how OnChainFX determines Cycle Low:
  //
  // The Cycle Low quote is not necessarily the absolute lowest single trade price.
  // Due to the nature of the historical data we analyze, we are not always able to look at every trade for an asset.
  // For some assets, the Cycle Low quoted may refer to the lowest daily average since the ATH,
  // or a price-sample on the day the Cycle Low occured.
  //
  cycleLowUSD: {
    field: 'm-metrics-cycle-low-price',
    headerName: 'Cycle Low',
    headerClass: 'CH-col',
    headerTooltip: 'The lowest trading price (in USD) of the asset since its All-Time-High\n\nData Source: OnChainFX',
    width: 120,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__["default"], window.refs),
    cellRendererParams: {
      currency: 'USD'
    }
  },
  //
  // 24 Hour Percent Change (USD)
  // NOTE: We want percent change against BTC too!
  //
  percentChange24hUSD: {
    field: 'cc-total-vol-full-CHANGEPCTDAY',
    headerName: 'Δ 24h',
    headerClass: 'CH-col',
    headerTooltip: 'Percent change over 24 hours against USD\n\nData Source: Cryptocompare',
    width: 80,
    type: ['cryptohubDefaults', 'cryptohubNumeric', 'cryptohubPercent']
  },
  //
  // 7 Day Percent change (USD)
  //
  percentChange7dUSD: {
    field: 'm-metrics-percent-change-btc-last-1-week',
    headerName: 'Δ 7D',
    headerClass: 'CH-col',
    headerTooltip: 'Percent change over 7 days against BTC\n\nData Source: Messari',
    width: 80,
    type: ['cryptohubDefaults', 'cryptohubNumeric', 'cryptohubPercent']
  },
  //
  // Sparkline (USD)
  //
  // 7 Day USD price & volume trend
  // Top & bottom numbers are % swing in price (top) & volume (bottom)
  //
  sparklineUSD: {
    field: 'cryptohub-price-history',
    headerName: '7D Trend',
    headerClass: 'CH-col',
    headerTooltip: '7 Day USD price and volume trend\n\nTop & bottom numbers are % swing in price (top) & volume (bottom)\n\nData Source: BinaryOverdose / Cryptocompare',
    width: 124,
    cellRenderer: _utils_class_cell_renderer_sparkline_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    cellRendererParams: {
      range: true,
      price: true,
      volume: true,
      volumeDays: 7
    },
    // NOTE: doesnt work yet this is what the docs say to do
    resizable: false
  },
  //
  // Volume
  //
  // The amount the coin has been traded in 24 hours against ALL its trading pairs displayed in USD
  //
  volume24hUSD: {
    field: 'cc-total-vol-full-TOTALVOLUME24HTO',
    headerName: 'Volume 24h',
    headerClass: 'CH-col',
    headerTooltip: 'The amount the coin has been traded in 24 hours against ALL its trading pairs displayed in USD\n\nData Source: Cryptocompare',
    width: 150,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__["default"], window.refs),
    cellRendererParams: {
      currency: 'USD'
    }
  },
  //
  // Marketcap
  //
  marketcapUSD: {
    field: 'cc-total-vol-full-MKTCAP',
    headerName: 'Market Cap',
    headerClass: 'CH-col',
    headerTooltip: 'The price in USD multiplied by the number of coins or tokens\n\nData Source: Cryptocompare',
    width: 150,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(_utils_cell_renderer_currency_js__WEBPACK_IMPORTED_MODULE_4__["default"], window.refs),
    cellRendererParams: {
      currency: 'USD'
    }
  },
  //
  // Circulating Supply
  //
  circulatingSupply: {
    field: 'cc-total-vol-full-SUPPLY',
    headerName: 'Circulating Supply',
    headerClass: 'CH-col',
    headerTooltip: 'Circulating supply\n\nData Source: Cryptocompare',
    width: 150,
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: _utils_cell_renderer_number_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  //
  // Proof type
  //
  proofType: {
    field: 'cc-total-vol-full-ProofType.value',
    headerName: 'Proof',
    headerClass: 'CH-col',
    headerTooltip: 'Proof Type\n\nData Source: Cryptocompare',
    width: 120,
    type: ['cryptohubText']
  },
  //
  // Algo
  //
  algo: {
    field: 'cc-total-vol-full-Algorithm.value',
    headerName: 'Algorithm',
    headerClass: 'CH-col',
    headerTooltip: 'Algorithm\n\nData Source: Cryptocompare',
    width: 120,
    type: ['cryptohubText']
  },
  //
  // Hashes per second
  //
  hashesPerSecond: {
    field: 'cc-total-vol-full-NetHashesPerSecond',
    headerName: 'Hashes per/s',
    headerClass: 'CH-col',
    headerTooltip: 'Net Hashes per/s\n\nData Source: Cryptocompare',
    width: 180,
    columnGroupShow: 'both',
    comparator: _utils_sort_numbers_js__WEBPACK_IMPORTED_MODULE_9__["default"],
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: _utils_cell_renderer_number_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  //
  // Number of Exchanges
  //
  numberOfExchanges: {
    field: 'cryptohub-numberOfExchanges',
    headerName: 'Exchanges',
    headerClass: 'CH-col',
    headerTooltip: 'Number of Exchanges the token is listed on\n\nData Source: BinaryOverdose / Cryptocompare',
    width: 100,
    columnGroupShow: 'closed',
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellStyle: {
      padding: 0
    },
    cellRenderer: _utils_cell_renderer_exchanges_js__WEBPACK_IMPORTED_MODULE_5__["default"],
    onCellClicked: _utils_cell_on_click_exchanges_js__WEBPACK_IMPORTED_MODULE_7__["default"]
  },
  //
  // Number of pairs
  //
  numberOfPairs: {
    field: 'cryptohub-numberOfPairs',
    headerName: 'Pairs',
    headerTooltip: 'Number of pairs\n\nData Source: BinaryOverdose / Cryptocompare',
    headerClass: 'CH-col',
    width: 100,
    columnGroupShow: 'closed',
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: _utils_cell_renderer_number_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  //
  // Number of Fiat pairs
  //
  numberOfFiatPairs: {
    field: 'cryptohub-numberOfFiatPairs',
    headerName: 'Fiat pairs',
    headerTooltip: 'Number of fiat pairs\n\nData Source: BinaryOverdose / Cryptocompare',
    headerClass: 'CH-col',
    width: 100,
    columnGroupShow: 'closed',
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: _utils_cell_renderer_number_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  //
  // Number of Fiat currencies
  //
  numberOfFiatCurrencies: {
    field: 'cryptohub-numberOfFiatCurrencies',
    headerName: 'Fiat Currencies',
    headerTooltip: 'Number of fiat Currencies\n\nData Source: BinaryOverdose / Cryptocompare',
    headerClass: 'CH-col',
    width: 100,
    columnGroupShow: 'closed',
    type: ['cryptohubDefaults', 'cryptohubNumeric'],
    cellRenderer: _utils_cell_renderer_number_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  }
};
/* harmony default export */ __webpack_exports__["default"] = (columnDefs);

/***/ }),

/***/ "./public/javascript/default-config.js":
/*!*********************************************!*\
  !*** ./public/javascript/default-config.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
 //
// DEFAULT CONFIG
//

/* harmony default export */ __webpack_exports__["default"] = ({
  columns: [{
    id: 'rowIndex'
  }, {
    id: 'name'
  }, {
    id: 'sectors'
  }, {
    id: 'priceUSD'
  }, {
    id: 'priceBTC'
  }, {
    id: 'athUSD'
  }, {
    id: 'cycleLowUSD'
  }, {
    id: 'percentChange24hUSD'
  }, {
    id: 'percentChange7DUSD'
  }, {
    id: 'sparklineUSD'
  }, {
    id: 'volume24hUSD'
  }, {
    id: 'marketcapUSD'
  }, {
    id: 'circulatingSupply'
  }, {
    id: 'proofType'
  }, {
    id: 'algo'
  }, {
    id: 'hashesPerSecond'
  }, {
    id: 'numberOfExchanges'
  }, {
    id: 'numberOfPairs'
  }, {
    id: 'numberOfFiatPairs'
  }, {
    id: 'numberOfFiatCurrencies'
  }],
  portfolio: [{
    id: 1182,
    // use cryptohub symbol Id
    in: 12145,
    // price in satochies
    type: 'long',
    // default to long
    exchange: 'binance' // at some stage we will support prices from exchanged

  }],
  favourites: [//...
  ],
  sort: {
    column: 'volume24hUSD',
    direction: 'desc'
  }
});

/***/ }),

/***/ "./public/javascript/globals.js":
/*!**************************************!*\
  !*** ./public/javascript/globals.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
// TODO: refs? really
// Clear up this dumping ground
//
// Start again...
//
// window.bo = {
//   data: {
//     row: [],
//     emit: ?,
//     store: ?
//   },
//   func: {
//     updated
//   },
//   common: {
//     emptyCellValue: '-',
//   }
// }
//

window.initData = window.initData || {};
window.initStore = window.initStore || {};
window.bo = {
  func: {},
  inst: {}
};
window.refs = {
  store: [],
  // the last version of the packed data
  rowData: null,
  emitData: []
};
window.ch = _objectSpread({
  emptyCellValue: '-'
}, initStore);
window.timestamp = null;
/**
 *
 * Updated
 * @param {Date} when
 * @return void
 *
 */

window.bo.func.updated = function (when) {
  if (when === 'now') window.timestamp = new Date();
  var time = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["timeAgo"])(window.timestamp);
  document.querySelector('#updated').innerHTML = "Updated ".concat(time, " ago");
};

/***/ }),

/***/ "./public/javascript/index.js":
/*!************************************!*\
  !*** ./public/javascript/index.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ "./public/javascript/globals.js");
/* harmony import */ var _libs_bo_datatable_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/bo-datatable-client */ "./public/javascript/libs/bo-datatable-client.js");
/* harmony import */ var _libs_bo_datatable_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_datatable_client__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _classes_class_cell_interactions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/class-cell-interactions.js */ "./public/javascript/classes/class-cell-interactions.js");
/* harmony import */ var _utils_convert_working_data_to_row_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/convert-working-data-to-row-data.js */ "./public/javascript/utils/convert-working-data-to-row-data.js");
/* harmony import */ var _utils_view_update_overview_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/view-update-overview.js */ "./public/javascript/utils/view-update-overview.js");
/* harmony import */ var _ag_grid_options_generate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ag-grid-options-generate.js */ "./public/javascript/ag-grid-options-generate.js");
/* harmony import */ var _stylesheet_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../stylesheet/index.css */ "./public/stylesheet/index.css");
/* harmony import */ var _stylesheet_index_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_stylesheet_index_css__WEBPACK_IMPORTED_MODULE_6__);


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

 // Binary Overdose Projects

 // Cryptohub classes

 // Cryptohub util functions


 // ag-grid config

 // CSS


/**
 *
 * Handle data events
 *
 * @param {Object} data
 * @return void
 *
 */

function dataEmitHandler(data) {
  window.bo.func.updated('now');
  var newSocketData = JSON.parse(data);
  var type = newSocketData.type;
  newSocketData = newSocketData.data;

  if (type === 'changeset') {
    window.DataTable.changesets.applyChanges(window.refs.workingData, newSocketData);
  } else {
    window.refs.workingData = newSocketData;
  }

  window.refs.rowData = Object(_utils_convert_working_data_to_row_data_js__WEBPACK_IMPORTED_MODULE_3__["default"])(window.refs.workingData);
  window.bo.agOptions.api.setRowData(window.refs.rowData);
  Object(_utils_view_update_overview_js__WEBPACK_IMPORTED_MODULE_4__["default"])(window.refs.workingData);
}
/**
 *
 * Handle store events
 *
 * @param {Object} data
 * @return void
 *
 */


function storeEmitHandler(data) {
  window.bo.func.updated('now');
  var newSocketData = JSON.parse(data);
  var type = newSocketData.type;
  newSocketData = newSocketData.data;

  if (type === 'changeset') {
    window.DataTable.changesets.applyChanges(window.ch, newSocketData);
  } else {
    window.ch = _objectSpread({}, window.ch, newSocketData);
  }
}

window.bo.inst.cellInteractions = new _classes_class_cell_interactions_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
var socket = io();
var agOptions = Object(_ag_grid_options_generate_js__WEBPACK_IMPORTED_MODULE_5__["default"])();
var gridElement = document.querySelector('#ch-grid');
var grid = new agGrid.Grid(gridElement, agOptions);
if (!grid) throw new Error('Cant find grid');
window.bo.func.updated('now');
setInterval(window.bo.func.updated, 1000 * 1);
socket.on('data', dataEmitHandler);
socket.on('store', storeEmitHandler);

/***/ }),

/***/ "./public/javascript/libs/bo-datatable-client.js":
/*!*******************************************************!*\
  !*** ./public/javascript/libs/bo-datatable-client.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function webpackUniversalModuleDefinition(root,factory){if(( false?undefined:_typeof(exports))==='object'&&( false?undefined:_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(window,function(){return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};/******/ /******/ // The require function
/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
/******/module.l=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{enumerable:true,get:getter});/******/}/******/};/******/ /******/ // define __esModule on exports
/******/__webpack_require__.r=function(exports){/******/if(typeof Symbol!=='undefined'&&Symbol.toStringTag){/******/Object.defineProperty(exports,Symbol.toStringTag,{value:'Module'});/******/}/******/Object.defineProperty(exports,'__esModule',{value:true});/******/};/******/ /******/ // create a fake namespace object
/******/ // mode & 1: value is a module id, require it
/******/ // mode & 2: merge all properties of value into the ns
/******/ // mode & 4: return value when already ns object
/******/ // mode & 8|1: behave like require
/******/__webpack_require__.t=function(value,mode){/******/if(mode&1)value=__webpack_require__(value);/******/if(mode&8)return value;/******/if(mode&4&&_typeof(value)==='object'&&value&&value.__esModule)return value;/******/var ns=Object.create(null);/******/__webpack_require__.r(ns);/******/Object.defineProperty(ns,'default',{enumerable:true,value:value});/******/if(mode&2&&typeof value!='string')for(var key in value){__webpack_require__.d(ns,key,function(key){return value[key];}.bind(null,key));}/******/return ns;/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
/******/__webpack_require__.p="";/******/ /******/ /******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s="./src/index.client.js");/******/}(/************************************************************************/ /******/{/***/"../../../../../home/alan/.nvm/versions/node/v9.11.1/lib/node_modules/webpack/buildin/global.js":/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/ /*! no static exports found */ /***/function homeAlanNvmVersionsNodeV9111LibNode_modulesWebpackBuildinGlobalJs(module,exports){eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://DataTable/(webpack)/buildin/global.js?");/***/},/***/"../../../../../home/alan/.nvm/versions/node/v9.11.1/lib/node_modules/webpack/buildin/module.js":/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/ /*! no static exports found */ /***/function homeAlanNvmVersionsNodeV9111LibNode_modulesWebpackBuildinModuleJs(module,exports){eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://DataTable/(webpack)/buildin/module.js?");/***/},/***/"./node_modules/diff-json/dist/changesets.js":/*!***************************************************!*\
  !*** ./node_modules/diff-json/dist/changesets.js ***!
  \***************************************************/ /*! no static exports found */ /***/function node_modulesDiffJsonDistChangesetsJs(module,exports,__webpack_require__){eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  (function() {\n    var _, addKeyValue, applyArrayChange, applyBranchChange, applyLeafChange, changeset, compare, compareArray, compareObject, comparePrimitives, convertArrayToObj, exports, getKey, getTypeOfObj, indexOfItemInArray, isEmbeddedKey, modifyKeyValue, parseEmbeddedKeyValue, removeKey, revertArrayChange, revertBranchChange, revertLeafChange;\n    changeset = {\n      VERSION: '0.1.4'\n    };\n    if ( true && module.exports) {\n      _ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n      module.exports = exports = changeset;\n    } else {\n      this.changeset = changeset;\n    }\n    getTypeOfObj = function(obj) {\n      if (typeof obj === 'undefined') {\n        return 'undefined';\n      }\n      if (obj === null) {\n        return null;\n      }\n      return Object.prototype.toString.call(obj).match(/^\\[object\\s(.*)\\]$/)[1];\n    };\n    getKey = function(path) {\n      var ref;\n      return (ref = path[path.length - 1]) != null ? ref : '$root';\n    };\n    compare = function(oldObj, newObj, path, embededObjKeys, keyPath) {\n      var changes, diffs, typeOfNewObj, typeOfOldObj;\n      changes = [];\n      typeOfOldObj = getTypeOfObj(oldObj);\n      typeOfNewObj = getTypeOfObj(newObj);\n      if (typeOfOldObj !== typeOfNewObj) {\n        changes.push({\n          type: changeset.op.REMOVE,\n          key: getKey(path),\n          value: oldObj\n        });\n        changes.push({\n          type: changeset.op.ADD,\n          key: getKey(path),\n          value: newObj\n        });\n        return changes;\n      }\n      switch (typeOfOldObj) {\n        case 'Date':\n          changes = changes.concat(comparePrimitives(oldObj.getTime(), newObj.getTime(), path));\n          break;\n        case 'Object':\n          diffs = compareObject(oldObj, newObj, path, embededObjKeys, keyPath);\n          if (diffs.length) {\n            if (path.length) {\n              changes.push({\n                type: changeset.op.UPDATE,\n                key: getKey(path),\n                changes: diffs\n              });\n            } else {\n              changes = changes.concat(diffs);\n            }\n          }\n          break;\n        case 'Array':\n          changes = changes.concat(compareArray(oldObj, newObj, path, embededObjKeys, keyPath));\n          break;\n        case 'Function':\n          break;\n        default:\n          changes = changes.concat(comparePrimitives(oldObj, newObj, path));\n      }\n      return changes;\n    };\n    compareObject = function(oldObj, newObj, path, embededObjKeys, keyPath, skipPath) {\n      var addedKeys, changes, deletedKeys, diffs, i, intersectionKeys, j, k, l, len, len1, len2, newKeyPath, newObjKeys, newPath, oldObjKeys;\n      if (skipPath == null) {\n        skipPath = false;\n      }\n      changes = [];\n      oldObjKeys = Object.keys(oldObj);\n      newObjKeys = Object.keys(newObj);\n      intersectionKeys = _.intersection(oldObjKeys, newObjKeys);\n      for (i = 0, len = intersectionKeys.length; i < len; i++) {\n        k = intersectionKeys[i];\n        newPath = path.concat([k]);\n        newKeyPath = skipPath ? keyPath : keyPath.concat([k]);\n        diffs = compare(oldObj[k], newObj[k], newPath, embededObjKeys, newKeyPath);\n        if (diffs.length) {\n          changes = changes.concat(diffs);\n        }\n      }\n      addedKeys = _.difference(newObjKeys, oldObjKeys);\n      for (j = 0, len1 = addedKeys.length; j < len1; j++) {\n        k = addedKeys[j];\n        newPath = path.concat([k]);\n        newKeyPath = skipPath ? keyPath : keyPath.concat([k]);\n        changes.push({\n          type: changeset.op.ADD,\n          key: getKey(newPath),\n          value: newObj[k]\n        });\n      }\n      deletedKeys = _.difference(oldObjKeys, newObjKeys);\n      for (l = 0, len2 = deletedKeys.length; l < len2; l++) {\n        k = deletedKeys[l];\n        newPath = path.concat([k]);\n        newKeyPath = skipPath ? keyPath : keyPath.concat([k]);\n        changes.push({\n          type: changeset.op.REMOVE,\n          key: getKey(newPath),\n          value: oldObj[k]\n        });\n      }\n      return changes;\n    };\n    compareArray = function(oldObj, newObj, path, embededObjKeys, keyPath) {\n      var diffs, indexedNewObj, indexedOldObj, ref, uniqKey;\n      uniqKey = (ref = embededObjKeys != null ? embededObjKeys[keyPath.join('.')] : void 0) != null ? ref : '$index';\n      indexedOldObj = convertArrayToObj(oldObj, uniqKey);\n      indexedNewObj = convertArrayToObj(newObj, uniqKey);\n      diffs = compareObject(indexedOldObj, indexedNewObj, path, embededObjKeys, keyPath, true);\n      if (diffs.length) {\n        return [\n          {\n            type: changeset.op.UPDATE,\n            key: getKey(path),\n            embededKey: uniqKey,\n            changes: diffs\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    convertArrayToObj = function(arr, uniqKey) {\n      var index, obj, value;\n      obj = {};\n      if (uniqKey !== '$index') {\n        obj = _.keyBy(arr, uniqKey);\n      } else {\n        for (index in arr) {\n          value = arr[index];\n          obj[index] = value;\n        }\n      }\n      return obj;\n    };\n    comparePrimitives = function(oldObj, newObj, path) {\n      var changes;\n      changes = [];\n      if (oldObj !== newObj) {\n        changes.push({\n          type: changeset.op.UPDATE,\n          key: getKey(path),\n          value: newObj,\n          oldValue: oldObj\n        });\n      }\n      return changes;\n    };\n    isEmbeddedKey = function(key) {\n      return /\\$.*=/gi.test(key);\n    };\n    removeKey = function(obj, key, embededKey) {\n      var index;\n      if (Array.isArray(obj)) {\n        if (embededKey !== '$index' || !obj[key]) {\n          index = indexOfItemInArray(obj, embededKey, key);\n        }\n        return obj.splice(index != null ? index : key, 1);\n      } else {\n        return delete obj[key];\n      }\n    };\n    indexOfItemInArray = function(arr, key, value) {\n      var index, item;\n      for (index in arr) {\n        item = arr[index];\n        if (key === '$index') {\n          if (item === value) {\n            return index;\n          }\n        } else if (item[key] === value) {\n          return index;\n        }\n      }\n      return -1;\n    };\n    modifyKeyValue = function(obj, key, value) {\n      return obj[key] = value;\n    };\n    addKeyValue = function(obj, key, value) {\n      if (Array.isArray(obj)) {\n        return obj.push(value);\n      } else {\n        return obj[key] = value;\n      }\n    };\n    parseEmbeddedKeyValue = function(key) {\n      var uniqKey, value;\n      uniqKey = key.substring(1, key.indexOf('='));\n      value = key.substring(key.indexOf('=') + 1);\n      return {\n        uniqKey: uniqKey,\n        value: value\n      };\n    };\n    applyLeafChange = function(obj, change, embededKey) {\n      var key, type, value;\n      type = change.type, key = change.key, value = change.value;\n      switch (type) {\n        case changeset.op.ADD:\n          return addKeyValue(obj, key, value);\n        case changeset.op.UPDATE:\n          return modifyKeyValue(obj, key, value);\n        case changeset.op.REMOVE:\n          return removeKey(obj, key, embededKey);\n      }\n    };\n    applyArrayChange = function(arr, change) {\n      var element, i, len, ref, results, subchange;\n      ref = change.changes;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        subchange = ref[i];\n        if ((subchange.value != null) || subchange.type === changeset.op.REMOVE) {\n          results.push(applyLeafChange(arr, subchange, change.embededKey));\n        } else {\n          if (change.embededKey === '$index') {\n            element = arr[+subchange.key];\n          } else {\n            element = _.find(arr, function(el) {\n              return el[change.embededKey] === subchange.key;\n            });\n          }\n          results.push(changeset.applyChanges(element, subchange.changes));\n        }\n      }\n      return results;\n    };\n    applyBranchChange = function(obj, change) {\n      if (Array.isArray(obj)) {\n        return applyArrayChange(obj, change);\n      } else {\n        return changeset.applyChanges(obj, change.changes);\n      }\n    };\n    revertLeafChange = function(obj, change, embededKey) {\n      var key, oldValue, type, value;\n      type = change.type, key = change.key, value = change.value, oldValue = change.oldValue;\n      switch (type) {\n        case changeset.op.ADD:\n          return removeKey(obj, key, embededKey);\n        case changeset.op.UPDATE:\n          return modifyKeyValue(obj, key, oldValue);\n        case changeset.op.REMOVE:\n          return addKeyValue(obj, key, value);\n      }\n    };\n    revertArrayChange = function(arr, change) {\n      var element, i, len, ref, results, subchange;\n      ref = change.changes;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        subchange = ref[i];\n        if ((subchange.value != null) || subchange.type === changeset.op.REMOVE) {\n          results.push(revertLeafChange(arr, subchange, change.embededKey));\n        } else {\n          if (change.embededKey === '$index') {\n            element = arr[+subchange.key];\n          } else {\n            element = _.find(arr, function(el) {\n              return el[change.embededKey] === subchange.key;\n            });\n          }\n          results.push(changeset.revertChanges(element, subchange.changes));\n        }\n      }\n      return results;\n    };\n    revertBranchChange = function(obj, change) {\n      if (Array.isArray(obj)) {\n        return revertArrayChange(obj, change);\n      } else {\n        return changeset.revertChanges(obj, change.changes);\n      }\n    };\n    changeset.diff = function(oldObj, newObj, embededObjKeys) {\n      return compare(oldObj, newObj, [], embededObjKeys, []);\n    };\n    changeset.applyChanges = function(obj, changesets) {\n      var change, i, len, results;\n      results = [];\n      for (i = 0, len = changesets.length; i < len; i++) {\n        change = changesets[i];\n        if ((change.value != null) || change.type === changeset.op.REMOVE) {\n          results.push(applyLeafChange(obj, change, change.embededKey));\n        } else {\n          results.push(applyBranchChange(obj[change.key], change));\n        }\n      }\n      return results;\n    };\n    changeset.revertChanges = function(obj, changeset) {\n      var change, i, len, ref, results;\n      ref = changeset.reverse();\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        change = ref[i];\n        if (!change.changes) {\n          results.push(revertLeafChange(obj, change));\n        } else {\n          results.push(revertBranchChange(obj[change.key], change));\n        }\n      }\n      return results;\n    };\n    changeset.op = {\n      REMOVE: 'remove',\n      ADD: 'add',\n      UPDATE: 'update'\n    };\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack://DataTable/./node_modules/diff-json/dist/changesets.js?");/***/},/***/"./node_modules/lodash/lodash.js":/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/ /*! no static exports found */ /***/function node_modulesLodashLodashJs(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.11';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n\n        return result;\n      }\n\n      if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n\n        return result;\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        if (isObject(srcValue)) {\n          stack || (stack = new Stack);\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1;\n      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array == null ? 0 : array.length,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('d\xE9j\xE0 vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = (lodashFunc.name + ''),\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../home/alan/.nvm/versions/node/v9.11.1/lib/node_modules/webpack/buildin/global.js */ \"../../../../../home/alan/.nvm/versions/node/v9.11.1/lib/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../../home/alan/.nvm/versions/node/v9.11.1/lib/node_modules/webpack/buildin/module.js */ \"../../../../../home/alan/.nvm/versions/node/v9.11.1/lib/node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://DataTable/./node_modules/lodash/lodash.js?");/***/},/***/"./src/index.client.js":/*!*****************************!*\
  !*** ./src/index.client.js ***!
  \*****************************/ /*! exports provided: changesets */ /***/function srcIndexClientJs(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_diff_json_dist_changesets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/diff-json/dist/changesets */ \"./node_modules/diff-json/dist/changesets.js\");\n/* harmony import */ var _node_modules_diff_json_dist_changesets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_diff_json_dist_changesets__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"changesets\", function() { return _node_modules_diff_json_dist_changesets__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n\n\n\n\n//# sourceURL=webpack://DataTable/./src/index.client.js?");/***/}/******/}));});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./public/javascript/libs/bo-utils-client.js":
/*!***************************************************!*\
  !*** ./public/javascript/libs/bo-utils-client.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(window, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) {
          __webpack_require__.d(ns, key, function (key) {
            return value[key];
          }.bind(null, key));
        }
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = "./index.client.generated.js");
      /******/
    }(
    /************************************************************************/

    /******/
    {
      /***/
      "./index.client.generated.js":
      /*!***********************************!*\
        !*** ./index.client.generated.js ***!
        \***********************************/

      /*! no static exports found */

      /***/
      function indexClientGeneratedJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./src/array-average.js */ \"./src/array-average.js\"), __webpack_require__(/*! ./src/array-normalize.js */ \"./src/array-normalize.js\"), __webpack_require__(/*! ./src/array-percent-range.js */ \"./src/array-percent-range.js\"), __webpack_require__(/*! ./src/array-to-object.js */ \"./src/array-to-object.js\"), __webpack_require__(/*! ./src/check-data-types-equal.js */ \"./src/check-data-types-equal.js\"), __webpack_require__(/*! ./src/create-svg-in-memory-node.js */ \"./src/create-svg-in-memory-node.js\"), __webpack_require__(/*! ./src/d3-simple-bar-chart.js */ \"./src/d3-simple-bar-chart.js\"), __webpack_require__(/*! ./src/d3-sparkline.js */ \"./src/d3-sparkline.js\"), __webpack_require__(/*! ./src/diff-numeric-strings.js */ \"./src/diff-numeric-strings.js\"), __webpack_require__(/*! ./src/format-number-as-currency.js */ \"./src/format-number-as-currency.js\"), __webpack_require__(/*! ./src/format-number-as.js */ \"./src/format-number-as.js\"), __webpack_require__(/*! ./src/get-random-int.js */ \"./src/get-random-int.js\"), __webpack_require__(/*! ./src/html-poll-element.js */ \"./src/html-poll-element.js\"), __webpack_require__(/*! ./src/html-toggle-class.js */ \"./src/html-toggle-class.js\"), __webpack_require__(/*! ./src/is-float.js */ \"./src/is-float.js\"), __webpack_require__(/*! ./src/is-integer.js */ \"./src/is-integer.js\"), __webpack_require__(/*! ./src/is-number.js */ \"./src/is-number.js\"), __webpack_require__(/*! ./src/number-group-digits.js */ \"./src/number-group-digits.js\"), __webpack_require__(/*! ./src/number-normalize.js */ \"./src/number-normalize.js\"), __webpack_require__(/*! ./src/number-scale.js */ \"./src/number-scale.js\"), __webpack_require__(/*! ./src/object-get-nested-property.js */ \"./src/object-get-nested-property.js\"), __webpack_require__(/*! ./src/object-is-empty-object.js */ \"./src/object-is-empty-object.js\"), __webpack_require__(/*! ./src/object-is-object.js */ \"./src/object-is-object.js\"), __webpack_require__(/*! ./src/object-to-array.js */ \"./src/object-to-array.js\"), __webpack_require__(/*! ./src/partial-application.js */ \"./src/partial-application.js\"), __webpack_require__(/*! ./src/string-camelcase.js */ \"./src/string-camelcase.js\"), __webpack_require__(/*! ./src/string-capitalize-first-letter.js */ \"./src/string-capitalize-first-letter.js\"), __webpack_require__(/*! ./src/time-ago.js */ \"./src/time-ago.js\"), __webpack_require__(/*! ./src/timeseries-prune.js */ \"./src/timeseries-prune.js\"), __webpack_require__(/*! ./src/timeseries-rescale.js */ \"./src/timeseries-rescale.js\"), __webpack_require__(/*! ./src/timeseries-scale.js */ \"./src/timeseries-scale.js\"), __webpack_require__(/*! ./src/timeseries-thin.js */ \"./src/timeseries-thin.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _arrayAverage, _arrayNormalize, _arrayPercentRange, _arrayToObject, _checkDataTypesEqual, _createSvgInMemoryNode, _d3SimpleBarChart, _d3Sparkline, _diffNumericStrings, _formatNumberAsCurrency, _formatNumberAs, _getRandomInt, _htmlPollElement, _htmlToggleClass, _isFloat, _isInteger, _isNumber, _numberGroupDigits, _numberNormalize, _numberScale, _objectGetNestedProperty, _objectIsEmptyObject, _objectIsObject, _objectToArray, _partialApplication, _stringCamelcase, _stringCapitalizeFirstLetter, _timeAgo, _timeseriesPrune, _timeseriesRescale, _timeseriesScale, _timeseriesThin) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  Object.defineProperty(_exports, \"arrayAverage\", {\n    enumerable: true,\n    get: function get() {\n      return _arrayAverage.default;\n    }\n  });\n  Object.defineProperty(_exports, \"arrayNormalize\", {\n    enumerable: true,\n    get: function get() {\n      return _arrayNormalize.default;\n    }\n  });\n  Object.defineProperty(_exports, \"arrayPercentRange\", {\n    enumerable: true,\n    get: function get() {\n      return _arrayPercentRange.default;\n    }\n  });\n  Object.defineProperty(_exports, \"arrayToObject\", {\n    enumerable: true,\n    get: function get() {\n      return _arrayToObject.default;\n    }\n  });\n  Object.defineProperty(_exports, \"checkDataTypesEqual\", {\n    enumerable: true,\n    get: function get() {\n      return _checkDataTypesEqual.default;\n    }\n  });\n  Object.defineProperty(_exports, \"createSvgInMemoryNode\", {\n    enumerable: true,\n    get: function get() {\n      return _createSvgInMemoryNode.default;\n    }\n  });\n  Object.defineProperty(_exports, \"d3SimpleBarChart\", {\n    enumerable: true,\n    get: function get() {\n      return _d3SimpleBarChart.default;\n    }\n  });\n  Object.defineProperty(_exports, \"d3Sparkline\", {\n    enumerable: true,\n    get: function get() {\n      return _d3Sparkline.default;\n    }\n  });\n  Object.defineProperty(_exports, \"diffNumericStrings\", {\n    enumerable: true,\n    get: function get() {\n      return _diffNumericStrings.default;\n    }\n  });\n  Object.defineProperty(_exports, \"formatNumberAsCurrency\", {\n    enumerable: true,\n    get: function get() {\n      return _formatNumberAsCurrency.default;\n    }\n  });\n  Object.defineProperty(_exports, \"formatNumberAs\", {\n    enumerable: true,\n    get: function get() {\n      return _formatNumberAs.default;\n    }\n  });\n  Object.defineProperty(_exports, \"getRandomInt\", {\n    enumerable: true,\n    get: function get() {\n      return _getRandomInt.default;\n    }\n  });\n  Object.defineProperty(_exports, \"htmlPollElement\", {\n    enumerable: true,\n    get: function get() {\n      return _htmlPollElement.default;\n    }\n  });\n  Object.defineProperty(_exports, \"htmlToggleClass\", {\n    enumerable: true,\n    get: function get() {\n      return _htmlToggleClass.default;\n    }\n  });\n  Object.defineProperty(_exports, \"isFloat\", {\n    enumerable: true,\n    get: function get() {\n      return _isFloat.default;\n    }\n  });\n  Object.defineProperty(_exports, \"isInteger\", {\n    enumerable: true,\n    get: function get() {\n      return _isInteger.default;\n    }\n  });\n  Object.defineProperty(_exports, \"isNumber\", {\n    enumerable: true,\n    get: function get() {\n      return _isNumber.default;\n    }\n  });\n  Object.defineProperty(_exports, \"numberGroupDigits\", {\n    enumerable: true,\n    get: function get() {\n      return _numberGroupDigits.default;\n    }\n  });\n  Object.defineProperty(_exports, \"numberNormalize\", {\n    enumerable: true,\n    get: function get() {\n      return _numberNormalize.default;\n    }\n  });\n  Object.defineProperty(_exports, \"numberScale\", {\n    enumerable: true,\n    get: function get() {\n      return _numberScale.default;\n    }\n  });\n  Object.defineProperty(_exports, \"objectGetNestedProperty\", {\n    enumerable: true,\n    get: function get() {\n      return _objectGetNestedProperty.default;\n    }\n  });\n  Object.defineProperty(_exports, \"objectIsEmptyObject\", {\n    enumerable: true,\n    get: function get() {\n      return _objectIsEmptyObject.default;\n    }\n  });\n  Object.defineProperty(_exports, \"objectIsObject\", {\n    enumerable: true,\n    get: function get() {\n      return _objectIsObject.default;\n    }\n  });\n  Object.defineProperty(_exports, \"objectToArray\", {\n    enumerable: true,\n    get: function get() {\n      return _objectToArray.default;\n    }\n  });\n  Object.defineProperty(_exports, \"partialApplication\", {\n    enumerable: true,\n    get: function get() {\n      return _partialApplication.default;\n    }\n  });\n  Object.defineProperty(_exports, \"stringCamelcase\", {\n    enumerable: true,\n    get: function get() {\n      return _stringCamelcase.default;\n    }\n  });\n  Object.defineProperty(_exports, \"stringCapitalizeFirstLetter\", {\n    enumerable: true,\n    get: function get() {\n      return _stringCapitalizeFirstLetter.default;\n    }\n  });\n  Object.defineProperty(_exports, \"timeAgo\", {\n    enumerable: true,\n    get: function get() {\n      return _timeAgo.default;\n    }\n  });\n  Object.defineProperty(_exports, \"timeseriesPrune\", {\n    enumerable: true,\n    get: function get() {\n      return _timeseriesPrune.default;\n    }\n  });\n  Object.defineProperty(_exports, \"timeseriesRescale\", {\n    enumerable: true,\n    get: function get() {\n      return _timeseriesRescale.default;\n    }\n  });\n  Object.defineProperty(_exports, \"timeseriesScale\", {\n    enumerable: true,\n    get: function get() {\n      return _timeseriesScale.default;\n    }\n  });\n  Object.defineProperty(_exports, \"timeseriesThin\", {\n    enumerable: true,\n    get: function get() {\n      return _timeseriesThin.default;\n    }\n  });\n  _arrayAverage = _interopRequireDefault(_arrayAverage);\n  _arrayNormalize = _interopRequireDefault(_arrayNormalize);\n  _arrayPercentRange = _interopRequireDefault(_arrayPercentRange);\n  _arrayToObject = _interopRequireDefault(_arrayToObject);\n  _checkDataTypesEqual = _interopRequireDefault(_checkDataTypesEqual);\n  _createSvgInMemoryNode = _interopRequireDefault(_createSvgInMemoryNode);\n  _d3SimpleBarChart = _interopRequireDefault(_d3SimpleBarChart);\n  _d3Sparkline = _interopRequireDefault(_d3Sparkline);\n  _diffNumericStrings = _interopRequireDefault(_diffNumericStrings);\n  _formatNumberAsCurrency = _interopRequireDefault(_formatNumberAsCurrency);\n  _formatNumberAs = _interopRequireDefault(_formatNumberAs);\n  _getRandomInt = _interopRequireDefault(_getRandomInt);\n  _htmlPollElement = _interopRequireDefault(_htmlPollElement);\n  _htmlToggleClass = _interopRequireDefault(_htmlToggleClass);\n  _isFloat = _interopRequireDefault(_isFloat);\n  _isInteger = _interopRequireDefault(_isInteger);\n  _isNumber = _interopRequireDefault(_isNumber);\n  _numberGroupDigits = _interopRequireDefault(_numberGroupDigits);\n  _numberNormalize = _interopRequireDefault(_numberNormalize);\n  _numberScale = _interopRequireDefault(_numberScale);\n  _objectGetNestedProperty = _interopRequireDefault(_objectGetNestedProperty);\n  _objectIsEmptyObject = _interopRequireDefault(_objectIsEmptyObject);\n  _objectIsObject = _interopRequireDefault(_objectIsObject);\n  _objectToArray = _interopRequireDefault(_objectToArray);\n  _partialApplication = _interopRequireDefault(_partialApplication);\n  _stringCamelcase = _interopRequireDefault(_stringCamelcase);\n  _stringCapitalizeFirstLetter = _interopRequireDefault(_stringCapitalizeFirstLetter);\n  _timeAgo = _interopRequireDefault(_timeAgo);\n  _timeseriesPrune = _interopRequireDefault(_timeseriesPrune);\n  _timeseriesRescale = _interopRequireDefault(_timeseriesRescale);\n  _timeseriesScale = _interopRequireDefault(_timeseriesScale);\n  _timeseriesThin = _interopRequireDefault(_timeseriesThin);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n});\n\n//# sourceURL=webpack://bo/./index.client.generated.js?");
        /***/
      },

      /***/
      "./src/array-average.js":
      /*!******************************!*\
        !*** ./src/array-average.js ***!
        \******************************/

      /*! no static exports found */

      /***/
      function srcArrayAverageJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  /**\n   *\n   * Array Average\n   *\n   * Take the average of all the numbers in an array\n   *\n   * @param {Array} array - array of numbers\n   * @return {Number}\n   *\n   */\n  var _default = function _default(array) {\n    var total = 0;\n    array.forEach(function (x) {\n      return total += x;\n    });\n    return total / array.length;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/array-average.js?");
        /***/
      },

      /***/
      "./src/array-normalize.js":
      /*!********************************!*\
        !*** ./src/array-normalize.js ***!
        \********************************/

      /*! no static exports found */

      /***/
      function srcArrayNormalizeJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./number-normalize.js */ \"./src/number-normalize.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _numberNormalize) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _numberNormalize = _interopRequireDefault(_numberNormalize);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\n  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n  /**\n   *\n   * Array Normalize\n   *\n   * Applies the normalize function to an array of numbers\n   *\n   * @param {Array} array - the array to be normalized\n   * @param {Number} min - the min range to apply\n   * @param {Number} max - the max range to apply\n   * @return {Array} return the normalized array\n   *\n   */\n  var _default = function _default(array, min, max) {\n    var aMax = Math.max.apply(Math, _toConsumableArray(array));\n    var aMin = Math.min.apply(Math, _toConsumableArray(array));\n    var result = array.map(function (n) {\n      return (0, _numberNormalize.default)(n, min, max, aMin, aMax);\n    });\n    return result;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/array-normalize.js?");
        /***/
      },

      /***/
      "./src/array-percent-range.js":
      /*!************************************!*\
        !*** ./src/array-percent-range.js ***!
        \************************************/

      /*! no static exports found */

      /***/
      function srcArrayPercentRangeJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  /**\n   *\n   * Percent Range\n   *\n   * Calculate the percentage change between the maximum and minimum values\n   * in the array compared to the first value\n   *\n   * @param {Array} array - array of numbers\n   * @return {Number}\n   *\n   *\n   */\n  var _default = function _default(array) {\n    var oldest = array[0];\n    var min = d3.min(array);\n    var max = d3.max(array);\n    var diff = max - min;\n    var result = Math.round(diff / (oldest / 100));\n    return result;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/array-percent-range.js?");
        /***/
      },

      /***/
      "./src/array-to-object.js":
      /*!********************************!*\
        !*** ./src/array-to-object.js ***!
        \********************************/

      /*! no static exports found */

      /***/
      function srcArrayToObjectJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  /**\n   *\n   * Array to Object\n   *\n   * Convert an array of Objects to an Object of Objects\n   * via one of the Objects fields as the Id\n   *\n   * ```\n   * // input\n   * const array = [\n   *   {id: 1, foo: 'bar'},\n   *   {id: 2, baz: 'qux'},\n   * ]\n   *\n   * arrayToObject(array, 'id');\n   *\n   * // output\n   * {\n   *   1: {id: 1, foo: 'bar'}\n   *   2: {id: 2, baz: 'qux'}\n   * }\n   * ```\n   *\n   * @param {Array} array - an Array of Objects\n   * @param {field} field - field to use as a key\n   * @return {Objecct}\n   *\n   */\n  var _default = function _default(array, field) {\n    var result = {};\n    var obj;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        obj = _step.value;\n        result[obj[field]] = obj;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/array-to-object.js?");
        /***/
      },

      /***/
      "./src/check-data-types-equal.js":
      /*!***************************************!*\
        !*** ./src/check-data-types-equal.js ***!
        \***************************************/

      /*! no static exports found */

      /***/
      function srcCheckDataTypesEqualJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  'use strict';\n  /**\n   *\n   * Check Data Types Equal\n   *\n   * TODO: update to support an arbritary number of arguments\n   *\n   */\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = checkDataTypesEqual;\n\n  function checkDataTypesEqual(data1, data2) {\n    return Object.prototype.toString.call(data1) === Object.prototype.toString.call(data2);\n  }\n});\n\n//# sourceURL=webpack://bo/./src/check-data-types-equal.js?");
        /***/
      },

      /***/
      "./src/create-svg-in-memory-node.js":
      /*!******************************************!*\
        !*** ./src/create-svg-in-memory-node.js ***!
        \******************************************/

      /*! no static exports found */

      /***/
      function srcCreateSvgInMemoryNodeJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  /**\n   *\n   * Create an SVG node without adding it to the DOM\n   * @param {String} type - the type of node to create, e.g. 'rect', 'g' etc\n   * @return {D3NodeObject} - a D3 node\n   *\n   */\n  var _default = function _default(type) {\n    var elm = document.createElementNS('http://www.w3.org/2000/svg', type);\n    return d3.select(elm);\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/create-svg-in-memory-node.js?");
        /***/
      },

      /***/
      "./src/d3-simple-bar-chart.js":
      /*!************************************!*\
        !*** ./src/d3-simple-bar-chart.js ***!
        \************************************/

      /*! no static exports found */

      /***/
      function srcD3SimpleBarChartJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./create-svg-in-memory-node.js */ \"./src/create-svg-in-memory-node.js\"), __webpack_require__(/*! ./array-percent-range.js */ \"./src/array-percent-range.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _createSvgInMemoryNode, _arrayPercentRange) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _createSvgInMemoryNode = _interopRequireDefault(_createSvgInMemoryNode);\n  _arrayPercentRange = _interopRequireDefault(_arrayPercentRange);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\n  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n  /**\n   *\n   * D3 Simple Bar Chart\n   *\n   * @param {Array} data\n   * @param {Boolean} range - show the percent fluctuation of the data\n   * @param {Number} [width]\n   * @param {Number} [height]\n   * @param {String} [styles]\n   * @param {String} [fill]\n   * @return {SVGElement}\n   *\n   */\n  var _default = function _default(_ref) {\n    var data = _ref.data,\n        range = _ref.range,\n        _ref$width = _ref.width,\n        width = _ref$width === void 0 ? 100 : _ref$width,\n        _ref$height = _ref.height,\n        height = _ref$height === void 0 ? 30 : _ref$height,\n        _ref$styles = _ref.styles,\n        styles = _ref$styles === void 0 ? '' : _ref$styles,\n        _ref$fill = _ref.fill,\n        fill = _ref$fill === void 0 ? '#eee' : _ref$fill;\n    var rangeXOffset = range ? 20 : 0;\n    var xArray = data.map(function (d) {\n      return d.x;\n    });\n    var yArray = data.map(function (d) {\n      return d.y;\n    });\n    var yMax = Math.max.apply(Math, _toConsumableArray(yArray));\n    var yMin = Math.min.apply(Math, _toConsumableArray(yArray));\n    var svgElement = (0, _createSvgInMemoryNode.default)('svg').attr('style', 'position: absolute; bottom: 0');\n    var svg = svgElement.attr('width', width).attr('height', height).attr('style', styles).append('g');\n    var x = d3.scaleBand().rangeRound([rangeXOffset, width]).padding(0.1);\n    var y = d3.scaleLinear().rangeRound([height, 0]);\n    x.domain(xArray);\n    y.domain([0, yMax]);\n    svg.selectAll().data(data).enter().append('rect').attr('x', function (d) {\n      return x(d.x);\n    }).attr('y', function (d) {\n      return y(d.y);\n    }).attr('fill', fill).attr('width', x.bandwidth()).attr('height', function (d) {\n      return height - y(d.y);\n    });\n\n    if (range) {\n      var volumeArray = data.map(function (v) {\n        return v.y;\n      });\n      var percentSwing = (0, _arrayPercentRange.default)(volumeArray);\n      var rangeGroup = svg.append('g').attr('class', 'cryptohub-sparkline-range');\n      rangeGroup.append('title').text('Percent fluctuation over 7 days'); // rangeGroup.append('rect')\n      //   .attr('width', '20')\n      //   .attr('height', '12')\n      //   .attr('fill', '#fff')\n      //   .attr('fill-opacity', '0.8')\n      //   .attr('x', 0)\n      //   .attr('y', 0)\n      //   .attr('rx', 0)\n      //   .attr('ry', 0);\n\n      rangeGroup.append('text').attr('x', '2').attr('y', 8).attr('fill', '#00A3E5').attr('font-size', '10px').attr('text-anchor', 'start').text(percentSwing);\n    }\n\n    return svgElement;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/d3-simple-bar-chart.js?");
        /***/
      },

      /***/
      "./src/d3-sparkline.js":
      /*!*****************************!*\
        !*** ./src/d3-sparkline.js ***!
        \*****************************/

      /*! no static exports found */

      /***/
      function srcD3SparklineJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./create-svg-in-memory-node.js */ \"./src/create-svg-in-memory-node.js\"), __webpack_require__(/*! ./array-percent-range.js */ \"./src/array-percent-range.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _createSvgInMemoryNode, _arrayPercentRange) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _createSvgInMemoryNode = _interopRequireDefault(_createSvgInMemoryNode);\n  _arrayPercentRange = _interopRequireDefault(_arrayPercentRange);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /**\n   *\n   * D3 Sparkline\n   *\n   * @param {Array} data\n   * @param {Boolean} range - show the percent fluctuation of the data\n   * @param {Number} [width]\n   * @param {Number} [height]\n   * @param {String} [styles]\n   * @return {SVGElement}\n   *\n   */\n  var _default = function _default(_ref) {\n    var data = _ref.data,\n        range = _ref.range,\n        _ref$width = _ref.width,\n        width = _ref$width === void 0 ? 100 : _ref$width,\n        _ref$height = _ref.height,\n        height = _ref$height === void 0 ? 30 : _ref$height,\n        _ref$styles = _ref.styles,\n        styles = _ref$styles === void 0 ? '' : _ref$styles;\n    var rangeXOffset = range ? 20 : 0;\n    var svgElement = (0, _createSvgInMemoryNode.default)('svg');\n    var len = data.length;\n    if (!len) return svgElement; //initialize scales\n\n    var xExtent = d3.extent(data, function (d) {\n      return d.x;\n    });\n    var yExtent = d3.extent(data, function (d) {\n      return d.y;\n    });\n    var x = d3.scaleLinear().domain(xExtent).range([rangeXOffset, width - 2]);\n    var y = d3.scaleLinear().domain(yExtent).range([height - 4, 0]);\n    var line = d3.line().x(function (d) {\n      return x(d.x);\n    }).y(function (d) {\n      return y(d.y);\n    }).curve(d3.curveBasis);\n    var svg = svgElement.attr('width', width).attr('height', height).attr('style', styles).append('g').attr('transform', 'translate(0, 2)');\n    svg.append('path').datum(data).attr('class', 'cryptohub-sparkline').attr('fill', 'none').attr('stroke', '#000').attr('stroke-width', '0.5px').attr('d', line);\n    svg.append('circle').attr('class', 'cryptohub-sparkline-circle').attr('cx', x(data[len - 1].x)).attr('cy', y(data[len - 1].y)).attr('fill', '#00A3E5').attr('stroke', 'none').attr('r', 1.5);\n\n    if (range) {\n      var priceArray = data.map(function (v) {\n        return v.y;\n      });\n      var percentSwing = (0, _arrayPercentRange.default)(priceArray);\n      var rangeGroup = svg.append('g').attr('class', 'cryptohub-sparkline-range');\n      rangeGroup.append('title').text('Percent fluctuation over 7 days'); // rangeGroup.append('rect')\n      //   .attr('width', '20')\n      //   .attr('height', '12')\n      //   .attr('fill', '#fff')\n      //   .attr('fill-opacity', '0.8')\n      //   .attr('x', 0)\n      //   .attr('y', 0)\n      //   .attr('rx', 0)\n      //   .attr('ry', 0);\n\n      rangeGroup.append('text').attr('x', '2').attr('y', '8').attr('fill', '#555').attr('font-size', '10px').attr('text-anchor', 'start').text(percentSwing);\n    }\n\n    return svgElement;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/d3-sparkline.js?");
        /***/
      },

      /***/
      "./src/diff-numeric-strings.js":
      /*!*************************************!*\
        !*** ./src/diff-numeric-strings.js ***!
        \*************************************/

      /*! no static exports found */

      /***/
      function srcDiffNumericStringsJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = diffNumericStrings;\n\n  /**\n   *\n   * Diff Numeric Strings\n   * This function is for identifying the changes between 2 numbers\n   * For example in stock data if you wanted to know by how much a value\n   * has increased or decreased\n   *\n   * v1     v2     return\n   * 1234   1244   {start: 12, end: 44}\n   * 10010  11000  {start: 1,  end: 1000}\n   * 20000  12345  {start: ,   end: 12345}\n   *\n   * @param {String} v1\n   * @param {String} v2\n   * @return {Object}\n   *\n   */\n  function diffNumericStrings(v1, v2) {\n    var s1;\n    var s2;\n    v1 = String(v1);\n    v2 = String(v2);\n\n    if (v2.length > v1.length) {\n      s1 = '';\n      s2 = v2;\n    } else {\n      var i = v1.length - 1;\n      var idx;\n\n      for (; i > -1; i--) {\n        if (v1.charAt(i) !== v2.charAt(i)) {\n          idx = i;\n        }\n      }\n\n      s1 = v2.substring(0, idx);\n      s2 = v2.substring(idx);\n    }\n\n    if (s1 === s2) s1 = '';\n    return {\n      start: s1,\n      end: s2\n    };\n  }\n});\n\n//# sourceURL=webpack://bo/./src/diff-numeric-strings.js?");
        /***/
      },

      /***/
      "./src/format-number-as-currency.js":
      /*!******************************************!*\
        !*** ./src/format-number-as-currency.js ***!
        \******************************************/

      /*! no static exports found */

      /***/
      function srcFormatNumberAsCurrencyJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = formatNumberAsCurrency;\n\n  /**\n   *\n   * Format Number as Bitcoin\n   *\n   * num      precision     return\n   * 12345    2             Ƀ12,345.00\n   * 0.001    2             Ƀ0.00\n   *\n   * @param {Number} num\n   * @param {String} code - currency code\n   * @param {Number} [precision]\n   * @return {String}\n   *\n   */\n  function formatNumberAsCurrency(num, code, precision) {\n    var special = {\n      'BTC': '฿',\n      'SAT': 'sat'\n    };\n\n    if (special[code]) {\n      if (!precision) {\n        if (code === 'BTC') precision = 8;\n        if (code === 'SAT') precision = 0;\n      }\n\n      var output = new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD',\n        minimumFractionDigits: precision,\n        maximumFractionDigits: precision\n      }).format(num).replace('$', '');\n      if (code === 'SAT') output += \" \".concat(special[code]);else output = special[code] + output;\n      return output;\n    } else {\n      if (!precision) {\n        precision = 2;\n      }\n\n      return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: code,\n        minimumFractionDigits: precision,\n        maximumFractionDigits: precision\n      }).format(num);\n    }\n  }\n});\n\n//# sourceURL=webpack://bo/./src/format-number-as-currency.js?");
        /***/
      },

      /***/
      "./src/format-number-as.js":
      /*!*********************************!*\
        !*** ./src/format-number-as.js ***!
        \*********************************/

      /*! no static exports found */

      /***/
      function srcFormatNumberAsJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = formatNumberAsCurrency;\n\n  /**\n   *\n   * Format Number as Bitcoin\n   *\n   * num      precision     return\n   * 12345    2             Ƀ12,345.00\n   * 0.001    2             Ƀ0.00\n   *\n   * @param {Number} num\n   * @param {Number} precision\n   * @param {String} code - currency code\n   * @return {String}\n   *\n   */\n  function formatNumberAsCurrency(num, precision, code) {\n    var special = {\n      'BTC': 'Ƀ'\n    };\n\n    if (special[code]) {\n      return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD',\n        minimumFractionDigits: precision\n      }).format(num).replace('$', 'Ƀ');\n    } else {\n      return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: code,\n        minimumFractionDigits: precision\n      }).format(num);\n    }\n  }\n});\n\n//# sourceURL=webpack://bo/./src/format-number-as.js?");
        /***/
      },

      /***/
      "./src/get-random-int.js":
      /*!*******************************!*\
        !*** ./src/get-random-int.js ***!
        \*******************************/

      /*! no static exports found */

      /***/
      function srcGetRandomIntJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = getRandomInt;\n\n  /**\n   *\n   * GET RANDOM INT\n   *\n   * Get a random integer between the min and max values provided\n   * If no values are provided it will return an integer between 0 and 1,000,000\n   *\n   * NOTE: The min and max are inclusive\n   *\n   * @param {Number} [min]\n   * @param {Number} [max]\n   * @return {Number}\n   *\n   */\n  function getRandomInt() {\n    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000000;\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/get-random-int.js?");
        /***/
      },

      /***/
      "./src/html-poll-element.js":
      /*!**********************************!*\
        !*** ./src/html-poll-element.js ***!
        \**********************************/

      /*! no static exports found */

      /***/
      function srcHtmlPollElementJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = htmlPollElement;\n\n  /**\n   *\n   * HTML POLL ELEMENT\n   *\n   * Repeatidly check if an element is available in the DOM.\n   * Call the callback function when it becomes available\n   * and clear the interval\n   *\n   * @param {String} selector\n   * @param {Number} interval\n   * @param {Function} callback\n   * @return {undefined}\n   *\n   */\n  function htmlPollElement(selector, interval, callback) {\n    var inter = setInterval(function () {\n      if (document.querySelectorAll(selector)[0]) {\n        clearInterval(inter);\n        callback();\n      }\n    }, interval);\n  }\n});\n\n//# sourceURL=webpack://bo/./src/html-poll-element.js?");
        /***/
      },

      /***/
      "./src/html-toggle-class.js":
      /*!**********************************!*\
        !*** ./src/html-toggle-class.js ***!
        \**********************************/

      /*! no static exports found */

      /***/
      function srcHtmlToggleClassJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = htmlToggleClass;\n\n  /**\n  *\n  * HTML TOGGLE CLASS\n  *\n  * Toggle a class on a DOM node\n  *\n  * @param {HTMLElement} element\n  * @param {String} cssClass\n  * @return {undefined}\n  *\n  */\n  function htmlToggleClass(element, cssClass) {\n    element.classList.contains(cssClass) ? element.classList.remove(cssClass) : element.classList.add(cssClass);\n  }\n});\n\n//# sourceURL=webpack://bo/./src/html-toggle-class.js?");
        /***/
      },

      /***/
      "./src/is-float.js":
      /*!*************************!*\
        !*** ./src/is-float.js ***!
        \*************************/

      /*! no static exports found */

      /***/
      function srcIsFloatJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = isFloat;\n\n  /**\n   *\n   * Is Float\n   *\n   * @param {*} x\n   * @return {Boolean}\n   *\n   */\n  function isFloat(x) {\n    return Number(x) === x && x % 1 !== 0;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/is-float.js?");
        /***/
      },

      /***/
      "./src/is-integer.js":
      /*!***************************!*\
        !*** ./src/is-integer.js ***!
        \***************************/

      /*! no static exports found */

      /***/
      function srcIsIntegerJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = isInteger;\n\n  /**\n   *\n   * Is Integer\n   *\n   * @param {*} x\n   * @return {Boolean}\n   *\n   */\n  function isInteger(x) {\n    return Number(x) === x && x % 1 === 0;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/is-integer.js?");
        /***/
      },

      /***/
      "./src/is-number.js":
      /*!**************************!*\
        !*** ./src/is-number.js ***!
        \**************************/

      /*! no static exports found */

      /***/
      function srcIsNumberJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./is-integer.js */ \"./src/is-integer.js\"), __webpack_require__(/*! ./is-float.js */ \"./src/is-float.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _isInteger, _isFloat) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = isNumber;\n  _isInteger = _interopRequireDefault(_isInteger);\n  _isFloat = _interopRequireDefault(_isFloat);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /**\n   *\n   * Is Number\n   * Check if the value is an Integer or a Float\n   *\n   * @param {*} x\n   * @return {Boolean}\n   *\n   */\n  function isNumber(x) {\n    return (0, _isInteger.default)(x) || (0, _isFloat.default)(x);\n  }\n});\n\n//# sourceURL=webpack://bo/./src/is-number.js?");
        /***/
      },

      /***/
      "./src/number-group-digits.js":
      /*!************************************!*\
        !*** ./src/number-group-digits.js ***!
        \************************************/

      /*! no static exports found */

      /***/
      function srcNumberGroupDigitsJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./is-integer.js */ \"./src/is-integer.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _isInteger) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = numberGroupDigits;\n  _isInteger = _interopRequireDefault(_isInteger);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /**\n   *\n   * NUMBER GROUP DIGITS\n   *\n   * Group numbers with a delimiter\n   *\n   * func(1234)      // 1,234\n   * func(123456)    // 123,456\n   * func(1234, ' ') // 1 234\n   *\n   * @see https://en.wikipedia.org/wiki/Decimal_separator for further enhancements\n   *\n   * @param {Number} number\n   * @param {String} [delimiter]\n   * @return {String|Boolean}\n   *\n   */\n  function numberGroupDigits(number) {\n    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n    if (!(0, _isInteger.default)(number)) return void false;\n    return Math.floor(number).toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1\".concat(delimiter));\n  }\n\n  ;\n});\n\n//# sourceURL=webpack://bo/./src/number-group-digits.js?");
        /***/
      },

      /***/
      "./src/number-normalize.js":
      /*!*********************************!*\
        !*** ./src/number-normalize.js ***!
        \*********************************/

      /*! no static exports found */

      /***/
      function srcNumberNormalizeJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  /**\n   *\n   * Number Normalize\n   *\n   * Normalize a number from one range to another\n   *\n   * @param {Number} num - the number to be normalized\n   * @param {Number} min - the min range of the original numbers\n   * @param {Number} max - the max range of the original number\n   * @param {Number} nMin - the new min range to apply\n   * @param {Number} nMax - the new max range to apply\n   * @return {Number} return the normalized number\n   *\n   */\n  var _default = function _default(num, min, max, nMin, nMax) {\n    var percent = (num - nMin) / (nMax - nMin);\n    var output = percent * (max - min) + min;\n    return output;\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/number-normalize.js?");
        /***/
      },

      /***/
      "./src/number-scale.js":
      /*!*****************************!*\
        !*** ./src/number-scale.js ***!
        \*****************************/

      /*! no static exports found */

      /***/
      function srcNumberScaleJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  'use strict';\n  /**\n   *\n   * Number Scale\n   *\n   * @param {Number} num\n   * @param {Number} min\n   * @param {Number} max\n   * @param {Number} newMin\n   * @param {Number} newMax\n   * @return {Nuber}\n   *\n   */\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = numberScale;\n\n  function numberScale(num, min, max) {\n    var newMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var newMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;\n    if (num < min) num = min;\n    if (num > max) num = max; // If the ranges suck\n\n    if (min === max) min *= 0.99, max *= 1.01;\n    if (newMin === newMax) throw new Error(\"numberScale(): Incorrect range \".concat(min, \"-\").concat(max));\n    var percent = (num - min) / (max - min);\n    return percent * (newMax - newMin) + newMin;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/number-scale.js?");
        /***/
      },

      /***/
      "./src/object-get-nested-property.js":
      /*!*******************************************!*\
        !*** ./src/object-get-nested-property.js ***!
        \*******************************************/

      /*! no static exports found */

      /***/
      function srcObjectGetNestedPropertyJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = objectGetNestedProperty;\n\n  /**\n   *\n   * Get nested property\n   *\n   * @param {Object} obj\n   * @param {String} str\n   * @return {Object|String} return the property, can be any value\n   *\n   */\n  function objectGetNestedProperty(obj, str) {\n    var pathArr = str.split('.');\n    return pathArr.reduce(function (o, k) {\n      return o && o[k] !== void 0 ? o[k] : void 0;\n    }, obj);\n  }\n});\n\n//# sourceURL=webpack://bo/./src/object-get-nested-property.js?");
        /***/
      },

      /***/
      "./src/object-is-empty-object.js":
      /*!***************************************!*\
        !*** ./src/object-is-empty-object.js ***!
        \***************************************/

      /*! no static exports found */

      /***/
      function srcObjectIsEmptyObjectJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./object-is-object */ \"./src/object-is-object.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _objectIsObject) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = objectIsEmptyObject;\n  _objectIsObject = _interopRequireDefault(_objectIsObject);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /**\n   *\n   * IS EMPTY OBJECT\n   *\n   * @param {Object} object - object or any other type\n   * @return {Boolean}\n   *\n   */\n  function objectIsEmptyObject(data) {\n    return (0, _objectIsObject.default)(data) && !Object.keys(data).length;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/object-is-empty-object.js?");
        /***/
      },

      /***/
      "./src/object-is-object.js":
      /*!*********************************!*\
        !*** ./src/object-is-object.js ***!
        \*********************************/

      /*! no static exports found */

      /***/
      function srcObjectIsObjectJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = objectIsObject;\n\n  /**\n   *\n   * objectIsObject\n   *\n   * @param {Object} object - object or any other type\n   * @return {Boolean}\n   *\n   */\n  function objectIsObject(object) {\n    return Object.prototype.toString.call(object) === '[object Object]';\n  }\n});\n\n//# sourceURL=webpack://bo/./src/object-is-object.js?");
        /***/
      },

      /***/
      "./src/object-to-array.js":
      /*!********************************!*\
        !*** ./src/object-to-array.js ***!
        \********************************/

      /*! no static exports found */

      /***/
      function srcObjectToArrayJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function () {\n  \"use strict\";\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\n  function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  /**\n   *\n   * @param {Object} data\n   * @return {Array}\n   *\n   */\n  module.exports = function objectToArray(data) {\n    var arrayData = [];\n\n    var _arr = Object.entries(data);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var _arr$_i = _slicedToArray(_arr[_i], 2),\n          id = _arr$_i[0],\n          obj = _arr$_i[1];\n\n      obj.id = obj.Id;\n      arrayData.push(obj);\n    }\n\n    return arrayData;\n  };\n});\n\n//# sourceURL=webpack://bo/./src/object-to-array.js?");
        /***/
      },

      /***/
      "./src/partial-application.js":
      /*!************************************!*\
        !*** ./src/partial-application.js ***!
        \************************************/

      /*! no static exports found */

      /***/
      function srcPartialApplicationJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\n  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n  /**\n   *\n   * partialApplication\n   *\n   * @param {Function} fn\n   * @param {Arguments} cache\n   * @return {Function}\n   *\n   */\n  var _default = function _default(fn) {\n    for (var _len = arguments.length, cache = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      cache[_key - 1] = arguments[_key];\n    }\n\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var all = cache.concat(args);\n      return all.length >= fn.length ? fn.apply(void 0, _toConsumableArray(all)) : pApply.apply(void 0, [fn].concat(_toConsumableArray(all)));\n    };\n  };\n\n  _exports.default = _default;\n});\n\n//# sourceURL=webpack://bo/./src/partial-application.js?");
        /***/
      },

      /***/
      "./src/string-camelcase.js":
      /*!*********************************!*\
        !*** ./src/string-camelcase.js ***!
        \*********************************/

      /*! no static exports found */

      /***/
      function srcStringCamelcaseJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./string-capitalize-first-letter */ \"./src/string-capitalize-first-letter.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _stringCapitalizeFirstLetter) {\n  'use strict'; // bo-utils\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = camelcase;\n  _stringCapitalizeFirstLetter = _interopRequireDefault(_stringCapitalizeFirstLetter);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /**\n   *\n   * @param {String} str\n   * @param {String} delimiter\n   * @return {String}\n   *\n   */\n  function camelcase(str, delimiter) {\n    return str.split('-').map(function (x, i) {\n      return !i ? x : (0, _stringCapitalizeFirstLetter.default)(x);\n    }).join('');\n  }\n});\n\n//# sourceURL=webpack://bo/./src/string-camelcase.js?");
        /***/
      },

      /***/
      "./src/string-capitalize-first-letter.js":
      /*!***********************************************!*\
        !*** ./src/string-capitalize-first-letter.js ***!
        \***********************************************/

      /*! no static exports found */

      /***/
      function srcStringCapitalizeFirstLetterJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = capitalizeFirstLetter;\n\n  /**\n   *\n   * @param {String} str\n   * @return {String}\n   *\n   */\n  function capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n});\n\n//# sourceURL=webpack://bo/./src/string-capitalize-first-letter.js?");
        /***/
      },

      /***/
      "./src/time-ago.js":
      /*!*************************!*\
        !*** ./src/time-ago.js ***!
        \*************************/

      /*! no static exports found */

      /***/
      function srcTimeAgoJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = timeAgo;\n\n  /**\n   *\n   * Timeago\n   *\n   * NOTE: Requires moment\n   *\n   * @param {String|Date|Number} timestamp\n   * @return {String} e.g. 'a few seconds'\n   *\n   */\n  function timeAgo(timestamp) {\n    var timeago;\n\n    if (timestamp !== void 0) {\n      var startDate = moment(timestamp);\n      var endDate = moment(new Date());\n      var ms = Math.abs(startDate.diff(endDate));\n      var duration = moment.duration(ms).humanize();\n      timeago = \"\".concat(duration);\n    }\n\n    return timeago;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/time-ago.js?");
        /***/
      },

      /***/
      "./src/timeseries-prune.js":
      /*!*********************************!*\
        !*** ./src/timeseries-prune.js ***!
        \*********************************/

      /*! no static exports found */

      /***/
      function srcTimeseriesPruneJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  'use strict';\n  /**\n   *\n   * Timeseries prune\n   *\n   * @param {Array} ts - Array of timeseries objects\n   * @param {Number} maxAge - Remove all items older than now - maxAge in ms\n   * @param {String} [timestampField] - The name of the timestamp field\n   *\n   */\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = timeseriesPrune;\n\n  function timeseriesPrune(ts, maxAge) {\n    var timestampField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'timestamp';\n    var timeNow = +new Date();\n    return ts.filter(function (v, i) {\n      return timeNow - v[timestampField] < maxAge;\n    });\n  }\n});\n\n//# sourceURL=webpack://bo/./src/timeseries-prune.js?");
        /***/
      },

      /***/
      "./src/timeseries-rescale.js":
      /*!***********************************!*\
        !*** ./src/timeseries-rescale.js ***!
        \***********************************/

      /*! no static exports found */

      /***/
      function srcTimeseriesRescaleJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./timeseries-thin */ \"./src/timeseries-thin.js\"), __webpack_require__(/*! ./timeseries-prune */ \"./src/timeseries-prune.js\"), __webpack_require__(/*! ./timeseries-scale */ \"./src/timeseries-scale.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _timeseriesThin, _timeseriesPrune, _timeseriesScale) {\n  'use strict';\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = timeseriesRescale;\n  _timeseriesThin = _interopRequireDefault(_timeseriesThin);\n  _timeseriesPrune = _interopRequireDefault(_timeseriesPrune);\n  _timeseriesScale = _interopRequireDefault(_timeseriesScale);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /**\n   *\n   * Timeseries Rescale\n   *\n   * @param {Array} ts - Array of timeseries objects\n   * @return {Array} - Array of updated timeseries object\n   *\n   */\n  function timeseriesRescale(item) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n    var maxAge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000 * 60 * 60 * 24 * 7;\n    var price = item['cc-total-vol-full-PRICE'];\n    var volume = item['cc-total-vol-full-TOTALVOLUME24HTO'];\n    var ts = item['cryptohub-price-history'];\n    var minP = item['cryptohub-price-history-min'] || price - 1;\n    var maxP = item['cryptohub-price-history-max'] || price;\n    var minV = item['cryptohub-volume-history-min'] || volume - 1;\n    var maxV = item['cryptohub-volume-history-max'] || volume;\n    var timestamp = item['cc-total-vol-full-PRICE-timestamp'];\n    (0, _timeseriesPrune.default)(ts, maxAge);\n    (0, _timeseriesThin.default)(ts, limit); // scale up\n\n    (0, _timeseriesScale.default)({\n      ts: ts,\n      min: minP,\n      max: maxP,\n      scaleField: 'price'\n    });\n    (0, _timeseriesScale.default)({\n      ts: ts,\n      min: minV,\n      max: maxV,\n      scaleField: 'volume'\n    }); // add item\n\n    var last = ts[ts.length - 1];\n    var next = {\n      price: price,\n      volume: volume,\n      timestamp: +new Date(timestamp)\n    };\n    if (JSON.stringify(last) !== JSON.stringify(next)) ts.push(next); // scale down\n\n    (0, _timeseriesScale.default)({\n      ts: ts,\n      min: 0,\n      max: 1000,\n      scaleField: 'price'\n    });\n    (0, _timeseriesScale.default)({\n      ts: ts,\n      min: 0,\n      max: 1000,\n      scaleField: 'volume'\n    }); // return {\n    //   timeseries: tsArr,\n    //   priceMin: newPriceMin,\n    //   priceMax: newPriceMax,\n    //   volumeMin: newVolMin,\n    //   volumeMax: newVolMax,\n    // };\n  }\n});\n\n//# sourceURL=webpack://bo/./src/timeseries-rescale.js?");
        /***/
      },

      /***/
      "./src/timeseries-scale.js":
      /*!*********************************!*\
        !*** ./src/timeseries-scale.js ***!
        \*********************************/

      /*! no static exports found */

      /***/
      function srcTimeseriesScaleJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./number-scale */ \"./src/number-scale.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports, _numberScale) {\n  'use strict';\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = timeseriesScale;\n  _numberScale = _interopRequireDefault(_numberScale);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\n  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n  /**\n   *\n   * Timeseries Scale\n   *\n   * @param {Array} ts - Array of timeseries objects\n   * @param {Number} min - Minimum value of range to scale to\n   * @param {Number} max - Maximim value of the range to scale to\n   * @param {String} scaleField - The name of the field to scale\n   * @param {String} [timestampField] - The name of the timestamp field\n   * @param {String} [ceil] - Rount the value up\n   * @return {Array} - Array of updated timeseries object\n   *\n   */\n  function timeseriesScale(_ref) {\n    var ts = _ref.ts,\n        min = _ref.min,\n        max = _ref.max,\n        scaleField = _ref.scaleField,\n        _ref$timestampField = _ref.timestampField,\n        timestampField = _ref$timestampField === void 0 ? 'timestamp' : _ref$timestampField,\n        _ref$ceil = _ref.ceil,\n        ceil = _ref$ceil === void 0 ? true : _ref$ceil;\n    var arr = ts.map(function (x) {\n      return x[scaleField];\n    });\n    var minOld = Math.min.apply(Math, _toConsumableArray(arr));\n    var maxOld = Math.max.apply(Math, _toConsumableArray(arr));\n    var val;\n    var scale;\n\n    var _arr = Object.values(ts);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      val = _arr[_i];\n      scale = (0, _numberScale.default)(val[scaleField], minOld, maxOld, min, max);\n      val[scaleField] = ceil ? Math.ceil(scale) : scale;\n    }\n\n    return ts;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/timeseries-scale.js?");
        /***/
      },

      /***/
      "./src/timeseries-thin.js":
      /*!********************************!*\
        !*** ./src/timeseries-thin.js ***!
        \********************************/

      /*! no static exports found */

      /***/
      function srcTimeseriesThinJs(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (_exports) {\n  'use strict';\n  /**\n   *\n   * Timeseries thin\n   *\n   * Remove the timeseries items that have the\n   * shortest time span between them and their siblings\n   * Keep removing until the limit has been reached\n   *\n   * @param {Array} ts\n   * @param {Number} limit\n   * @param {String} [timestampField]\n   * @return {Array}\n   *\n   */\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = timeseriesThin;\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\n  function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  function timeseriesThin(ts, limit) {\n    var timestampField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'timestamp';\n    var numToRemove = ts.length - limit;\n\n    if (!numToRemove) {\n      return ts;\n    } else {\n      var idx;\n      var diff;\n      var diffs = {};\n\n      var _arr = Object.keys(ts);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        idx = _arr[_i];\n\n        if (idx > 0) {\n          diff = Math.abs(ts[idx - 1][timestampField] - ts[idx][timestampField]);\n          diffs[diff] = idx;\n        }\n\n        ;\n      }\n\n      var i;\n      var itemsToRemove = Object.keys(diffs).sort().splice(0, numToRemove);\n\n      var _arr2 = Object.entries(itemsToRemove);\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var _arr2$_i = _slicedToArray(_arr2[_i2], 2);\n\n        i = _arr2$_i[0];\n        idx = _arr2$_i[1];\n        ts.splice(diffs[idx] - i, 1);\n      }\n    }\n\n    return ts;\n  }\n});\n\n//# sourceURL=webpack://bo/./src/timeseries-thin.js?");
        /***/
      }
      /******/

    })
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./public/javascript/utils/cell-on-click-exchanges.js":
/*!************************************************************!*\
  !*** ./public/javascript/utils/cell-on-click-exchanges.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellOnClickExchanges; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _popdiv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./popdiv.js */ "./public/javascript/utils/popdiv.js");
/* harmony import */ var _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../generated/init-pug.generated.js */ "./public/javascript/generated/init-pug.generated.js");
/* harmony import */ var _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2__);
 // Binary Overdose Projects

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




 // Cryptohub



/**
 *
 *
 *
 *
 */

function cellOnClickExchanges(params) {
  function exchangeDataModel() {
    // Exchange data
    // -------------------
    // CentralizationType : "Centralized"
    // Country : "United Kingdom"
    // ItemType : (2) ["Cryptocurrency", "Fiat"]
    // Url: "/exchanges/bitstamp/overview"
    // LogoUrl : "/media/34478497/bitstamp.jpg"
    // Name : "Bitstamp"
    // id : "2431"
    // name : "Bitstamp"
    // pairs : Set(18) {"XRP,EUR", "XRP,BTC", "XRP,USD", "BTC,USD", "BTC,EUR", …}
    // _cryptoCurrencies : Set(6) {"XRP", "BTC", "ETH", "BCH", "BCHABC", …}
    // _fiatCurrencies : Set(2) {"EUR", "USD"}
    // _numberOfCryptoCurrencies : 6
    // _numberOfCryptoPairs : 5
    // _numberOfCurrencies : 8
    // _numberOfFiatCurrencies : 2
    // _numberOfFiatPairs : 13
    // _numberOfPairs : 18
    // _points : 0
    var fiatIds = params.data['cryptohub-exchangesListAcceptsBoth'] || [];
    var cryptoIds = params.data['cryptohub-exchangesListCryptoOnly'] || [];
    var exchanges = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(window.ch, 'exchanges'); //
    // Step 1: Create the below data structure
    //
    // ```
    // {
    //   UK: {fiat: [], crypto: []},
    //   US: {fiat: [], crypto: []},
    // }
    // ```
    //

    var outputObject = {};
    {
      var _id;

      var ids;
      var type;
      var country;
      var exchange;

      for (var _i = 0, _Object$entries = Object.entries({
        fiat: fiatIds,
        crypto: cryptoIds
      }); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2);

        type = _Object$entries$_i[0];
        ids = _Object$entries$_i[1];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = ids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            _id = _step.value;
            exchange = exchanges[_id];
            if (!exchange) continue;
            country = exchange.Country;

            if (!outputObject[country]) {
              outputObject[country] = {
                fiat: [],
                crypto: []
              };
            }

            outputObject[country][type].push({
              // TODO: get exchange urls
              url: "https://www.cryptocompare.com".concat(exchange.Url),
              name: exchange.Name,
              logoUrl: exchange.LogoUrl,
              dex: exchange.CentralizationType === 'Decentralized',
              numberOfFiatCurrencies: exchange._numberOfFiatCurrencies,
              numberOfCryptocurrencies: exchange._numberOfCryptoCurrencies
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    } //
    // Step 2: Sort the data into an Array based on the most
    // popular geographic location (as below)
    //
    // ```
    // [
    //   {
    //     country: 'UK',
    //     fiat: [{name: 'Kraken', dex: true, url, fiatPairs: 3, cryptoPairs: 4}],
    //     crypto: [{name: 'Binance', dex: false, url, cryptoPairs: 55}],
    //   }
    // ]
    // ```
    //

    var outputArray = [];
    {
      var _country;

      var properties;

      for (var _i2 = 0, _Object$entries2 = Object.entries(outputObject); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2);

        country = _Object$entries2$_i[0];
        properties = _Object$entries2$_i[1];
        outputArray.push(_objectSpread({
          country: _country
        }, properties));
      }
    }
    return outputArray;
  }

  function exchangeHtmlContent() {
    var name = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'data.cc-total-vol-full-FullName.value');
    var total = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["numberGroupDigits"])(Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value'));
    var classes = 'ch-numberofexchanges';
    var dexList = params.data['cryptohub-exchangesListDex'] || [];
    var fiatIds = params.data['cryptohub-exchangesListAcceptsBoth'] || [];
    var cryptoIds = params.data['cryptohub-exchangesListCryptoOnly'] || [];
    var outputArray = exchangeDataModel();
    var numberOfPairs = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'data.cryptohub-numberOfPairs.value');
    var output = {
      header: {
        name: name,
        total: total,
        classes: classes,
        numberOfPairs: numberOfPairs,
        numberOfDex: dexList.length,
        numberOfFiat: fiatIds.length,
        numberOfCrypto: cryptoIds.length
      },
      body: outputArray
    };
    var contentHtml = _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default.a['ch-tippy-click'](output);
    return contentHtml;
  }

  var $cell = params.event.target.closest('.ag-cell');
  var id = "ch-tippy-".concat(Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["getRandomInt"])());
  var cssId = "#".concat(id);
  var contentPopdiv = _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default.a['ch-tippy-click-tradingview']({
    id: id
  });
  var contentExchange = exchangeHtmlContent();
  Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["htmlToggleClass"])($cell, 'ch-cell-active');
  Object(_popdiv_js__WEBPACK_IMPORTED_MODULE_1__["default"])($cell, contentPopdiv);
  document.querySelector(cssId).innerHTML = contentExchange;
}

/***/ }),

/***/ "./public/javascript/utils/cell-on-click-tradingview.js":
/*!**************************************************************!*\
  !*** ./public/javascript/utils/cell-on-click-tradingview.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellOnClickTradingview; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _popdiv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./popdiv.js */ "./public/javascript/utils/popdiv.js");
/* harmony import */ var _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../generated/init-pug.generated.js */ "./public/javascript/generated/init-pug.generated.js");
/* harmony import */ var _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2__);
 // Binary Overdose Projects




 // Cryptohub Util functions



/**
 *
 * NOTE: Not currently used
 *
 */

function exchangeSupported(exchanges) {
  var mapNameId = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(ch, 'exchange-map-nameId'); // TODO: rank by exchange ranking that we havnt created yet

  var supported = ['POLONIEX', 'BINANCE', 'BITFINEX', 'BITSTAMP', 'COINBASE', 'BITFLYER', 'KORBIT', 'BITTREX', 'MERCADO', 'GEMINI', 'BITHUMB', 'CEX.IO', 'BTCYOU', 'BITSO', 'OKCOIN', 'COINFLOOR', 'THEROCKTRADING', 'ITBIT', 'HITBTC', 'HUOBI', 'FOREXCOM'];
  var map = Object.entries(mapNameId).reduce(function (acc, val) {
    acc[val[0].toUpperCase()] = val[1];
    return acc;
  }, {});
  var supportedIds = supported.map(function (a) {
    return map[a];
  });
  return supportedIds;
}

;
/**
 *
 * TRADINGVIEW GET SYMBOL
 *
 * Tradingview symbols looks like:
 *
 *   symbolFromSymbolTo
 *   ---------------------------
 *   BTCUSD
 *   ETHBTC
 *
 * @param {Object} params - ag-grid cell params object
 * @param {STring} [symbolTo] - to symbol, defaults to BTC
 * @return {String|undefined} symbol - tradingview symbol
 *
 */

function tradingviewGetSymbol(params) {
  var symbolTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'BTC';
  var map = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(ch, 'exchange-map-idName');
  var symbolFrom = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'data.cc-coinlist-Symbol.value'); //
  // NOTE: don't use exchange, tradingview finds a default
  //
  // Try an exchange that supports fiat first
  // const exchangeList1 = exchangeSupported(gnp(params, 'data.cryptohub-exchangesListAcceptsBoth'));
  // const exchangeList2 = exchangeSupported(gnp(params, 'data.cryptohub-exchangesListCryptoOnly'));
  // const exchange = map && exchangeList1.length
  //   ? map[exchangeList1[0]]
  //   : map && exchangeList2.length
  //     ? map[exchangeList2[0]]
  //     : void 0;

  if (symbolFrom && symbolTo) {
    var pair = symbolFrom.toUpperCase() + symbolTo.toUpperCase();
    var symbol = "".concat(pair);
    return symbol;
  } else {
    console.warn('Cannot construct tradingview symbol');
  }
}
/**
 *
 * LOAD TRADINGVIEW
 *
 * Load a trading view widget using ag-grid cell params as data
 *
 * @param {Object} params - ag-grid cell params object
 * @param {String} container_id - html id of where to load the widget
 * @param {STring} [symbolTo] - to symbol, defaults to BTC
 * @return {undefined}
 *
 */


function loadTradingview(params, container_id) {
  var symbolTo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'BTC';
  var symbol = tradingviewGetSymbol(params, symbolTo);

  if (symbol) {
    new TradingView.widget({
      symbol: symbol,
      container_id: container_id,
      autosize: true,
      interval: 'D',
      timezone: 'Etc/UTC',
      theme: 'Light',
      style: '1',
      locale: 'uk',
      toolbar_bg: 'rgba(255, 255, 255, 1)',
      enable_publishing: false,
      allow_symbol_change: true,
      save_image: false,
      studies: ['MAExp@tv-basicstudies']
    });
  } else {
    console.warn('Cannot load tradingview window, missing initialization data');
  }
}
/**
 *
 *
 *
 *
 *
 */


function cellOnClickTradingview(symbolTo, params) {
  var id = "ch-tippy-".concat(Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["getRandomInt"])());
  var cssId = "#".concat(id);
  var content = _generated_init_pug_generated_js__WEBPACK_IMPORTED_MODULE_2___default.a['ch-tippy-click-tradingview']({
    id: id
  });
  var $cell = params.event.target.closest('.ag-cell');
  Object(_popdiv_js__WEBPACK_IMPORTED_MODULE_1__["default"])($cell, content);
  Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["htmlPollElement"])(cssId, 100, Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["partialApplication"])(loadTradingview, params, id, symbolTo));
}

/***/ }),

/***/ "./public/javascript/utils/cell-renderer-currency.js":
/*!***********************************************************!*\
  !*** ./public/javascript/utils/cell-renderer-currency.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellRendererCurrency; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _get_cell_css_class_diff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-cell-css-class-diff.js */ "./public/javascript/utils/get-cell-css-class-diff.js");
 // Binary Overdose Projects




 // Cryptohub Util functions


/**
 *
 * Cell Renderer Currency
 *
 * Render numbers in the following format: $123,456,789.00
 * Highlight changes between previous versions like so: <span>$123,45</span><span>1,789.00</span>
 * Colour the changed part of the number in green or red depending on change direction
 *
 * @param {Object} refs
 * @param {String} currency
 * @param {Object} params
 * @return {HTMLElement}
 *
 */

function cellRendererCurrency(refs, params) {
  var result = ch.emptyCellValue;
  if (!params.value) return result;
  var colDef = params.colDef,
      data = params.data;
  var html = document.createElement('div');
  var newValue = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value');
  var oldValue = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, "data.".concat(params.colDef.field, ":last")); // format number

  var newVal;
  var oldVal;
  var digits = newValue >= 1 ? 2 : 6;
  if (Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(newValue)) newVal = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["formatNumberAsCurrency"])(newValue, params.currency);
  if (Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(oldValue)) oldVal = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["formatNumberAsCurrency"])(oldValue, params.currency);

  if (Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(newValue) && !Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(oldValue)) {
    result = newVal;
  } else {
    var _diffNumericStrings = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["diffNumericStrings"])(oldVal, newVal),
        start = _diffNumericStrings.start,
        end = _diffNumericStrings.end;

    var cssClass = Object(_get_cell_css_class_diff_js__WEBPACK_IMPORTED_MODULE_1__["default"])(oldVal, newVal);
    result = "<span>".concat(start, "</span><span class=\"").concat(cssClass, "\">").concat(end, "</span>");
  }

  html.innerHTML = result;
  return html;
}

/***/ }),

/***/ "./public/javascript/utils/cell-renderer-exchanges.js":
/*!************************************************************!*\
  !*** ./public/javascript/utils/cell-renderer-exchanges.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellRendererExchanges; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
 // Binary Overdose Projects



/**
 *
 * Cell Renderer Exchanges
 *
 * @param {Object} params
 * @return {HTMLElement}
 *
 */

function cellRendererExchanges(params) {
  var total = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["numberGroupDigits"])(Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value'));
  var linkHtml = document.createElement('span');
  linkHtml.setAttribute('class', "cryptohub-link ch-numberofexchanges-link");
  linkHtml.innerHTML = total;
  return linkHtml;
}

/***/ }),

/***/ "./public/javascript/utils/cell-renderer-name.js":
/*!*******************************************************!*\
  !*** ./public/javascript/utils/cell-renderer-name.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellRendererName; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);



/**
 *
 * CELL RENDERER NAME
 *
 */

function cellRendererName(params) {
  var fileName = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'data.cc-total-vol-full-ImageUrl.value');
  var imgUrl = "https://www.cryptocompare.com".concat(fileName);
  var symbol = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'data.cc-coinlist-Symbol.value');
  var img = imgUrl ? "<img src=\"".concat(imgUrl, "\" class=\"ch-icons\" />") : '';
  var output = "\n    <div class=\"ch-col-name\">\n      ".concat(img, "\n      <strong>").concat(params.value, "</strong><span> (").concat(symbol, ")</span>\n    </div>\n  ");
  return output;
}
;

/***/ }),

/***/ "./public/javascript/utils/cell-renderer-number.js":
/*!*********************************************************!*\
  !*** ./public/javascript/utils/cell-renderer-number.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellRendererNumber; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);




/**
 *
 *
 */

function cellRendererNumber(params) {
  var number = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value');
  return Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["numberGroupDigits"])(number) || '-';
}
;

/***/ }),

/***/ "./public/javascript/utils/cell-renderer-tradingview.js":
/*!**************************************************************!*\
  !*** ./public/javascript/utils/cell-renderer-tradingview.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellRendererTradingview; });

/**
 *
 * Cell Renderer Exchanges
 *
 * @param {Object} params
 * @return {HTMLElement}
 *
 */

function cellRendererTradingview(params) {}

/***/ }),

/***/ "./public/javascript/utils/cell-tooltip.js":
/*!*************************************************!*\
  !*** ./public/javascript/utils/cell-tooltip.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellTooltip; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);



/**
 *
 * CELL TOOLTIP
 *
 * @param {Object} params
 * @return {String}
 *
 */

function cellTooltip(params) {
  var data = params.data,
      colDef = params.colDef;
  var field = data[colDef.field];
  var timestamp = field && field.timestamp;
  var t = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["timeAgo"])(timestamp) || 'unknown time ago';
  return "Last updated ".concat(t);
}

/***/ }),

/***/ "./public/javascript/utils/class-cell-renderer-sparkline.js":
/*!******************************************************************!*\
  !*** ./public/javascript/utils/class-cell-renderer-sparkline.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cellRendererSparkline; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




/**
 *
 * Price
 *
 * @param {Array} arr
 * @param {Boolean} range
 *
 */

function price(arr, range) {
  var priceData = arr.reduce(function (acc, val) {
    acc.push({
      x: val.timestamp,
      y: val.price
    });
    return acc;
  }, []);
  return Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["d3Sparkline"])({
    range: range,
    data: priceData,
    width: 100,
    height: 32,
    styles: 'position: absolute; top: 0; right: 11px'
  });
}
/**
 *
 * Volume
 *
 * @param {Array} arr
 * @param {Boolean} range
 * @param {Object} [volumeDays]
 *
 */


function volume(arr, range) {
  var volumeDays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7;
  var volumeData = [];
  var data = arr.reduce(function (acc, val) {
    acc.push({
      x: val.timestamp,
      y: val.volume
    });
    return acc;
  }, []);
  var numDays = volumeDays;
  var steps = Math.max(Math.floor(data.length / numDays), 1);

  for (var i = 0; i < data.length; i = i + steps) {
    var p0 = data[i];
    var p1 = data[i + 1];
    var p2 = data[i + 2];
    var y0 = p0.y;
    var y1 = p1 ? p1.y : y0;
    var y2 = p2 ? p2.y : y1; // Take the average of 3 volumes and the middle timestamp

    volumeData.push({
      x: p1 ? p1.x : p0.x,
      y: Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["arrayAverage"])([y0, y1, y2])
    });
  }

  return Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["d3SimpleBarChart"])({
    range: range,
    data: volumeData,
    width: 100,
    height: 10,
    fill: '#caecfc',
    styles: 'position: absolute; bottom: 0; right: 11px'
  });
}
/**
 *
 * Cell renderer class
 *
 */


var cellRendererSparkline =
/*#__PURE__*/
function () {
  function cellRendererSparkline() {
    _classCallCheck(this, cellRendererSparkline);
  }

  _createClass(cellRendererSparkline, [{
    key: "init",
    // gets called once before the renderer is used
    value: function init(params) {
      if (!params.value) return;
      var ts = JSON.parse(JSON.stringify(params.value));
      if (params.price) this.price = price(ts, !!params.range);
      if (params.volume) this.volume = volume(ts, !!params.range, params.volumeDays);
    } // gets called once when grid ready to insert the element

  }, {
    key: "getGui",
    value: function getGui() {
      var div = document.createElement('div');

      if (this.volume) {
        div.appendChild(this.volume.node());
      }

      if (this.price) {
        div.appendChild(this.price.node());
      }

      this.eGui = div;
      return this.eGui;
    }
  }]);

  return cellRendererSparkline;
}();



/***/ }),

/***/ "./public/javascript/utils/class-compound-cell-renderer.js":
/*!*****************************************************************!*\
  !*** ./public/javascript/utils/class-compound-cell-renderer.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CompoundCellRenderer; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _get_cell_css_class_diff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-cell-css-class-diff.js */ "./public/javascript/utils/get-cell-css-class-diff.js");
 // Binary Overdose Projects

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // Cryptohub Util functions


/**
 *
 * Cell renderer class
 *
 */

var CompoundCellRenderer =
/*#__PURE__*/
function () {
  function CompoundCellRenderer() {
    _classCallCheck(this, CompoundCellRenderer);
  }

  _createClass(CompoundCellRenderer, [{
    key: "init",
    // gets called once before the renderer is used
    value: function init(params) {
      this.eGui = document.createElement('div');
      this.cryptohubLoadCell(params);
    } // gets called once when grid ready to insert the element

  }, {
    key: "getGui",
    value: function getGui() {
      return this.eGui;
    } // gets called whenever the user gets the cell to refresh

  }, {
    key: "refresh",
    value: function refresh(params) {
      this.cryptohubLoadCell(params);
    }
  }, {
    key: "cryptohubLoadCell",
    value: function cryptohubLoadCell(params) {
      var value = params.valueFormatted ? params.valueFormatted : Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value');
      var data = "<span class=\"cryptohub-cell-data\">-</span>";
      this.eGui.innerHTML = data; // get references to the elements we want

      this.eValue = this.eGui.querySelector('.cryptohub-cell-data'); // set value into cell

      this.eValue.innerHTML = value;
    }
  }]);

  return CompoundCellRenderer;
}();



/***/ }),

/***/ "./public/javascript/utils/convert-working-data-to-row-data.js":
/*!*********************************************************************!*\
  !*** ./public/javascript/utils/convert-working-data-to-row-data.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return convertWorkingDataToRowData; });

/**
 *
 * Convert Working Data to Row Data
 *
 * UnMinify data & expand timestamps / value into object
 * Creates ag-grid Array row data
 *
 * @param {Array} data - array of data objects to unpack
 * @return {Array} unpacked array data
 *
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function convertWorkingDataToRowData(data) {
  data = JSON.parse(JSON.stringify(data));

  if (data.keys) {
    //
    // UnMinify
    //
    var id, item;
    var key, val;
    var newObj;
    var newData = {};
    var keys = data.keys;
    delete data.keys;

    for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2);

      id = _Object$entries$_i[0];
      item = _Object$entries$_i[1];
      newObj = {};

      for (var _i2 = 0, _Object$entries2 = Object.entries(item); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2);

        key = _Object$entries2$_i[0];
        val = _Object$entries2$_i[1];
        newObj[keys[key]] = val;
      }

      newData[id] = newObj;
    }

    data = newData;
  } //
  // Convert data Object to Array
  //


  var arrayData = [];

  for (var _i3 = 0, _Object$entries3 = Object.entries(data); _i3 < _Object$entries3.length; _i3++) {
    var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
        _id = _Object$entries3$_i[0],
        obj = _Object$entries3$_i[1];

    obj.id = obj.Id;
    arrayData.push(obj);
  }

  data = arrayData; //
  // Expand timestamp / value
  //

  var regex = /-timestamp$/g;
  var match;
  var value;
  var valueKey;
  var timestamp;
  var d, k, v;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      d = _step.value;

      for (var _i4 = 0, _Object$entries4 = Object.entries(d); _i4 < _Object$entries4.length; _i4++) {
        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i4], 2);

        k = _Object$entries4$_i[0];
        v = _Object$entries4$_i[1];
        match = k.match(regex);

        if (match && match.length) {
          valueKey = k.replace(regex, '');
          value = d[valueKey];
          timestamp = d[k];
          d[valueKey] = {
            timestamp: timestamp,
            value: value
          };
          delete d[k];
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return data;
}

/***/ }),

/***/ "./public/javascript/utils/filter-floating-number.js":
/*!***********************************************************!*\
  !*** ./public/javascript/utils/filter-floating-number.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


function NumberFloatingFilter() {}

NumberFloatingFilter.prototype.init = function (params) {
  this.onFloatingFilterChanged = params.onFloatingFilterChanged;
  this.eGui = document.createElement('div');
  this.eGui.innerHTML = '<input type="text"/>';
  this.currentValue = null;
  this.eFilterInput = this.eGui.querySelector('input');
  var that = this;

  function onInputBoxChanged() {
    if (that.eFilterInput.value === '') {
      //Remove the filter
      that.onFloatingFilterChanged(null);
      return;
    }

    that.currentValue = that.eFilterInput.value;
    that.onFloatingFilterChanged(that.currentValue);
  }

  this.eFilterInput.addEventListener('input', onInputBoxChanged);
};

NumberFloatingFilter.prototype.onParentModelChanged = function (parentModel) {
  // When the filter is empty we will receive a null message her
  if (!parentModel) {
    this.eFilterInput.value = '';
  } else {
    this.eFilterInput.value = parentModel + '';
  }

  this.currentValue = parentModel;
};

NumberFloatingFilter.prototype.getGui = function () {
  return this.eGui;
};

/* harmony default export */ __webpack_exports__["default"] = (NumberFloatingFilter);

/***/ }),

/***/ "./public/javascript/utils/filter-number.js":
/*!**************************************************!*\
  !*** ./public/javascript/utils/filter-number.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


function NumberFilter() {}

NumberFilter.prototype.init = function (params) {
  this.valueGetter = params.valueGetter;
  this.filterText = null;
  this.params = params;
  this.setupGui();
}; // not called by ag-Grid, just for us to help setup


NumberFilter.prototype.setupGui = function () {
  this.gui = document.createElement('div');
  this.gui.innerHTML = '<div style="padding: 4px; width=100px">' + '<div style="font-weight: bold;">Greater than: </div>' + '<div><input style="margin: 4px 0px 4px 0px; width: 100px" type="text" id="filterText" placeholder="Number of medals..."/></div>' + '</div>';
  var that = this;

  this.onFilterChanged = function () {
    that.extractFilterText();
    that.params.filterChangedCallback();
  };

  this.eFilterText = this.gui.querySelector('#filterText');
  this.eFilterText.addEventListener("input", this.onFilterChanged);
};

NumberFilter.prototype.extractFilterText = function () {
  this.filterText = this.eFilterText.value;
};

NumberFilter.prototype.getGui = function () {
  return this.gui;
}; //
// TODO: =0 doesnt work
// TODO: decimals dont work
//


NumberFilter.prototype.doesFilterPass = function (params) {
  var valueGetter = this.valueGetter;
  var value = valueGetter(params).value;
  var input = this.filterText.replace(/\s/g, '');
  var split = input.match(/[0-9]+|>=|<=|[<>&|()]/gi);
  var whitelist = ['<', '>', '<=', '>=', '&', '|', '(', ')'];
  var signs = split.filter(isNaN);
  var areAllValid = signs.some(function (sign) {
    return whitelist.includes(sign);
  });
  var numBeforeSigns = ['<', '>', '<=', '>='];
  var num = 80;

  var generateExpression = function generateExpression(num) {
    return split.reduce(function (acc, val, idx) {
      if (numBeforeSigns.includes(val)) acc.push(num);
      acc.push(isNaN(val) ? val : Number(val));
      return acc;
    }, []).join('');
  };

  var expressionStr = generateExpression(value);
  var passed;

  try {
    passed = new Function("return ".concat(expressionStr))();
  } catch (error) {
    passed = 1;
  }

  return passed;
};

NumberFilter.prototype.isFilterActive = function () {
  return this.filterText !== null && this.filterText !== undefined && this.filterText !== '';
};

NumberFilter.prototype.getModel = function () {
  return this.isFilterActive() ? this.eFilterText.value : null;
};

NumberFilter.prototype.setModel = function (model) {
  this.eFilterText.value = model;
  this.extractFilterText();
};

NumberFilter.prototype.destroy = function () {
  this.eFilterText.removeEventListener("input", this.onFilterChanged);
};

/* harmony default export */ __webpack_exports__["default"] = (NumberFilter);

/***/ }),

/***/ "./public/javascript/utils/get-cell-css-class-diff.js":
/*!************************************************************!*\
  !*** ./public/javascript/utils/get-cell-css-class-diff.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCellCssClassDiff; });

/**
 *
 * Get Cell CSS Class Diff
 *
 * @param {String} oldVal
 * @param {String} newVal
 * @return {String} a CSS class name
 *
 */

function getCellCssClassDiff(oldVal, newVal) {
  var cssClass = newVal < oldVal ? 'cryptohub-text-default cryptohub-text-bad-fade' : newVal > oldVal ? 'cryptohub-text-default cryptohub-text-good-fade' : 'cryptohub-text-default';
  return cssClass;
}

/***/ }),

/***/ "./public/javascript/utils/popdiv.js":
/*!*******************************************!*\
  !*** ./public/javascript/utils/popdiv.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return popDiv; });

/**
 *
 * POPDIV
 *
 * Initialize a Tippy popdiv on a HTML element
 * By default the popdiv is shown on initialization via the `showOnInit` property
 *
 * @param {HTMLElement} element
 * @param {String|HTMLElement|Function} content
 * @param {Object} tippyOptions - use to overwrite the default options setup here
 *
 * @see https://atomiks.github.io/tippyjs/
 *
 */

function popDiv(element, content) {
  var tippyOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var appendTo = document.querySelector('.ag-body');
  var defaultTippyOptions = {
    popperOptions: {
      modifiers: {
        preventOverflow: {
          escapeWithReference: true
        },
        hide: {
          enabled: false
        }
      }
    },
    content: content,
    appendTo: appendTo,
    flip: false,
    arrow: false,
    theme: 'light',
    trigger: 'click',
    multiple: true,
    allowHTML: true,
    placement: 'bottom-start',
    showOnInit: true,
    hideOnClick: 'toggle',
    interactive: true,
    interactiveBorder: 5,
    interactiveDebounce: 1
  };
  tippy(element, Object.assign(defaultTippyOptions, tippyOptions));
  return element;
}

/***/ }),

/***/ "./public/javascript/utils/should-cell-update.js":
/*!*******************************************************!*\
  !*** ./public/javascript/utils/should-cell-update.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shouldCellUpdate; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);



/**
 *
 * SHOULD CELL UPDATE
 *
 * Decide whether to update the cell or not.
 * Note we DO want to update the cell even if the data hasnt changed so
 * that the HTML reloads. That said we don't want to update if we have no data.
 *
 * @param {String} oldValue
 * @param {String} newValue
 * @return {Boolean}
 *
 */

function shouldCellUpdate(oldValue, newValue) {
  try {
    return Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(oldValue, 'value') === Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(newValue, 'value') && Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(oldValue, 'timestamp') === Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(newValue, 'timestamp');
  } catch (error) {
    debugger;
  }
}

/***/ }),

/***/ "./public/javascript/utils/sort-numbers.js":
/*!*************************************************!*\
  !*** ./public/javascript/utils/sort-numbers.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sortNumbers; });

/**
 *
 * SORT NUMBERS
 *
 * Compare numbers that are provided on the `value` property of objects
 *
 * @param {Object} d1 - the first item to compare
 * @param {Object} d1 - the second item to compare
 * @return {Boolean}
 *
 */

function sortNumbers(d1, d2) {
  return (d1 && d1.value || -Infinity) - (d2 && d2.value || -Infinity);
}

/***/ }),

/***/ "./public/javascript/utils/value-formatter-percent-change.js":
/*!*******************************************************************!*\
  !*** ./public/javascript/utils/value-formatter-percent-change.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return valueFormatterPercentChange; });
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);



/**
 *
 * valueFormatterPercentChange
 *
 * @param {}
 * @return {}
 *
 */

function valueFormatterPercentChange(params) {
  var value = Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectGetNestedProperty"])(params, 'value.value');
  var num = Number.parseFloat(value).toFixed(2);
  return isNaN(num) ? '-' : "".concat(num, "%");
}
;

/***/ }),

/***/ "./public/javascript/utils/view-update-overview.js":
/*!*********************************************************!*\
  !*** ./public/javascript/utils/view-update-overview.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/bo-utils-client */ "./public/javascript/libs/bo-utils-client.js");
/* harmony import */ var _libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__);



/**
 *
 * @param {Object} data
 * @return {Object}
 *
 */

/* harmony default export */ __webpack_exports__["default"] = (function (data) {
  if (!Object(_libs_bo_utils_client__WEBPACK_IMPORTED_MODULE_0__["objectIsObject"])(data)) return false;
  var key;
  var val;
  var up = 0;
  var dn = 0;
  var nc = 0;

  for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
    key = _Object$keys[_i];
    if (!data[key]) continue;
    val = data[key]['cc-total-vol-full-CHANGEPCTDAY'];
    if (val > 0) up++;else if (val < 0) dn++;else nc++;
  }

  var total = up + dn + nc;
  var placeholder = '-';
  var upPer = Math.floor(up / (total / 100));
  var dnPer = Math.floor(dn / (total / 100));
  var ncPer = Math.floor(nc / (total / 100));
  upPer = isNaN(upPer) ? placeholder : upPer;
  dnPer = isNaN(upPer) ? placeholder : dnPer;
  ncPer = isNaN(upPer) ? placeholder : ncPer;
  document.querySelector('.ch-direction .ch-up .ch-val').innerHTML = "".concat(upPer, "%");
  document.querySelector('.ch-direction .ch-dn .ch-val').innerHTML = "".concat(dnPer, "%");
  document.querySelector('.ch-direction .ch-nc .ch-val').innerHTML = "".concat(ncPer, "%");
  document.querySelector('.ch-direction .ch-total .ch-val').innerHTML = "".concat(total);
});

/***/ }),

/***/ "./public/stylesheet/index.css":
/*!*************************************!*\
  !*** ./public/stylesheet/index.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC9hZy1ncmlkLW9wdGlvbnMtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC9hZy1ncmlkLW9wdGlvbnMtZ2VuZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvY2xhc3Nlcy9jbGFzcy1jZWxsLWludGVyYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC9jb2x1bW4tbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC9kZWZhdWx0LWNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC9nbG9iYWxzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L2xpYnMvYm8tZGF0YXRhYmxlLWNsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC9saWJzL2JvLXV0aWxzLWNsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC91dGlscy9jZWxsLW9uLWNsaWNrLWV4Y2hhbmdlcy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC91dGlscy9jZWxsLW9uLWNsaWNrLXRyYWRpbmd2aWV3LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL2NlbGwtcmVuZGVyZXItY3VycmVuY3kuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvdXRpbHMvY2VsbC1yZW5kZXJlci1leGNoYW5nZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvdXRpbHMvY2VsbC1yZW5kZXJlci1uYW1lLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL2NlbGwtcmVuZGVyZXItbnVtYmVyLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL2NlbGwtcmVuZGVyZXItdHJhZGluZ3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvdXRpbHMvY2VsbC10b29sdGlwLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL2NsYXNzLWNlbGwtcmVuZGVyZXItc3BhcmtsaW5lLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL2NsYXNzLWNvbXBvdW5kLWNlbGwtcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvdXRpbHMvY29udmVydC13b3JraW5nLWRhdGEtdG8tcm93LWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvdXRpbHMvZmlsdGVyLWZsb2F0aW5nLW51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC91dGlscy9maWx0ZXItbnVtYmVyLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL2dldC1jZWxsLWNzcy1jbGFzcy1kaWZmLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL3BvcGRpdi5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC91dGlscy9zaG91bGQtY2VsbC11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2phdmFzY3JpcHQvdXRpbHMvc29ydC1udW1iZXJzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qYXZhc2NyaXB0L3V0aWxzL3ZhbHVlLWZvcm1hdHRlci1wZXJjZW50LWNoYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdC91dGlscy92aWV3LXVwZGF0ZS1vdmVydmlldy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvc3R5bGVzaGVldC9pbmRleC5jc3M/ZTBhNSJdLCJuYW1lcyI6WyJjb21wb25lbnRzIiwiY29sdW1uVHlwZXMiLCJjcnlwdG9odWJEZWZhdWx0cyIsImVxdWFscyIsInNob3VsZENlbGxVcGRhdGUiLCJ0b29sdGlwIiwiY2VsbFRvb2x0aXAiLCJjcnlwdG9odWJOdW1lcmljIiwiZmlsdGVyIiwiZmlsdGVyTnVtYmVyIiwic3VwcHJlc3NNZW51IiwiZmxvYXRpbmdGaWx0ZXJDb21wb25lbnQiLCJmaWx0ZXJGbG9hdGluZ051bWJlciIsImZsb2F0aW5nRmlsdGVyQ29tcG9uZW50UGFyYW1zIiwic3VwcHJlc3NGaWx0ZXJCdXR0b24iLCJjb21wYXJhdG9yIiwic29ydE51bWJlcnMiLCJjZWxsQ2xhc3MiLCJjcnlwdG9odWJQZXJjZW50IiwiY2VsbENsYXNzUnVsZXMiLCJ4IiwidmFsdWUiLCJ2YWx1ZUZvcm1hdHRlciIsInZhbHVlRm9ybWF0dGVyUGVyY2VudENoYW5nZSIsImNlbGxSZW5kZXJlciIsIkNvbXBvdW5kQ2VsbFJlbmRlcmVyIiwiY3J5cHRvaHViVGV4dCIsImNvbHVtbkRlZnMiLCJvbkNlbGxNb3VzZU92ZXIiLCJwYXJhbXMiLCJmaWVsZCIsImNvbERlZiIsImFjdGlvbiIsIndpbmRvdyIsImJvIiwiaW5zdCIsImNlbGxJbnRlcmFjdGlvbnMiLCJtb3VzZU92ZXIiLCJvbkNlbGxNb3VzZU91dCIsIm1vdXNlT3V0Iiwib25WaXJ0dWFsQ29sdW1uc0NoYW5nZWQiLCJjb25zb2xlIiwibG9nIiwib25WaXJ0dWFsUm93UmVtb3ZlZCIsInJvd0hlaWdodCIsInJvd0RhdGEiLCJyZWZzIiwiZW5hYmxlQ2VsbENoYW5nZUZsYXNoIiwiZW5hYmxlRmlsdGVyIiwiZW5hYmxlU29ydGluZyIsImZsb2F0aW5nRmlsdGVyIiwiZW5hYmxlQ29sUmVzaXplIiwiZGVsdGFSb3dEYXRhTW9kZSIsImFuaW1hdGVSb3dzIiwicm93U2VsZWN0aW9uIiwiZ2V0Um93Tm9kZUlkIiwiZGF0YSIsImRlZmF1bHRDb2xEZWYiLCJlZGl0YWJsZSIsInJlc2l6YWJsZSIsImdlbmVyYXRlQ29sdW1uRGVmcyIsImNvbHVtbnMiLCJpZCIsImNvbHVtbiIsIm91dHB1dCIsImNvbHVtbkxpYnJhcnkiLCJwdXNoIiwib25HcmlkUmVhZHkiLCJhcGkiLCJzZXRTb3J0TW9kZWwiLCJjb2xJZCIsImRlZmF1bHRDb25maWciLCJzb3J0IiwiZGlyZWN0aW9uIiwiZnVuYyIsInVwZGF0ZWQiLCJ3b3JraW5nRGF0YSIsImluaXREYXRhIiwiY29udmVydFdvcmtpbmdEYXRhVG9Sb3dEYXRhIiwic2V0Um93RGF0YSIsInVwZGF0ZU92ZXJ2aWV3IiwiZ2VuZXJhdGVBZ09wdGlvbnMiLCJFcnJvciIsIm9wdGlvbnMiLCJhZ09wdGlvbnMiLCJhZ0dyaWRPcHRpb25zQmFzZSIsIkNlbGxJbnRlcmFjdGlvbnMiLCJob3ZlcmluZyRjZWxsIiwib3Blbkl0ZW1zIiwidGlwcHlPcHRpb25zIiwidGhlbWUiLCJwbGFjZW1lbnQiLCJoaWRlT25DbGljayIsImludGVyYWN0aXZlQm9yZGVyIiwiaW50ZXJhY3RpdmVEZWJvdW5jZSIsIm9uSGlkZSIsInRpcHB5Iiwib3BlbmVkIiwicmVmZXJlbmNlIiwiZGF0YXNldCIsImNoT3BlbiIsImhvdmVyaW5nIiwiY2hIb3ZlciIsIiRjZWxsIiwiY29udGVudCIsInBvcERpdiIsIiR0cmlnZ2VyVGlwcHkiLCJfdGlwcHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJkZXN0cm95IiwiJHRyaWdnZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidHJpZ2dlckNsaWNrSGFuZGxlciIsImNvbnRleHQiLCJldmVudCIsInNyY0VsZW1lbnQiLCJjbG9zZXN0Iiwic2V0TW91c2VPdXRTdGF0ZSIsImNsb3NlIiwib3BlbiIsImdldFJhbmRvbUludCIsIndpZHRoIiwic2Nyb2xsV2lkdGgiLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJpbml0UHVnIiwiaG92ZXJpbmckY2VsbE9wZW4iLCJzZXRNb3VzZU92ZXJTdGF0ZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXJ0aWFsQXBwbGljYXRpb24iLCJzZXQiLCJjZWxsT25DbGlja1RyYWRpbmd2aWV3IiwiJHBvcERpdlRpcHB5Iiwicm93SW5kZXgiLCJ2YWx1ZUdldHRlciIsImhlYWRlck5hbWUiLCJoZWFkZXJDbGFzcyIsImhlYWRlclRvb2x0aXAiLCJwaW5uZWQiLCJsb2NrUG9zaXRpb24iLCJzdXBwcmVzc0ZpbHRlciIsInR5cGUiLCJuYW1lIiwiY2VsbFJlbmRlcmVyTmFtZSIsInNlY3RvcnMiLCJnbnAiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJjaCIsImVtcHR5Q2VsbFZhbHVlIiwicHJpY2VVU0QiLCJjZWxsUmVuZGVyZXJDdXJyZW5jeSIsImNlbGxSZW5kZXJlclBhcmFtcyIsImN1cnJlbmN5IiwicHJpY2VCVEMiLCJvbkNlbGxDbGlja2VkIiwiYXRoVVNEIiwiY3ljbGVMb3dVU0QiLCJwZXJjZW50Q2hhbmdlMjRoVVNEIiwicGVyY2VudENoYW5nZTdkVVNEIiwic3BhcmtsaW5lVVNEIiwiQ2VsbFJlbmRlcmVyU3BhcmtsaW5lIiwicmFuZ2UiLCJwcmljZSIsInZvbHVtZSIsInZvbHVtZURheXMiLCJ2b2x1bWUyNGhVU0QiLCJtYXJrZXRjYXBVU0QiLCJjaXJjdWxhdGluZ1N1cHBseSIsImNlbGxSZW5kZXJlck51bWJlciIsInByb29mVHlwZSIsImFsZ28iLCJoYXNoZXNQZXJTZWNvbmQiLCJjb2x1bW5Hcm91cFNob3ciLCJudW1iZXJPZkV4Y2hhbmdlcyIsImNlbGxTdHlsZSIsInBhZGRpbmciLCJjZWxsUmVuZGVyZXJFeGNoYW5nZXMiLCJjZWxsT25DbGlja0V4Y2hhbmdlcyIsIm51bWJlck9mUGFpcnMiLCJudW1iZXJPZkZpYXRQYWlycyIsIm51bWJlck9mRmlhdEN1cnJlbmNpZXMiLCJwb3J0Zm9saW8iLCJpbiIsImV4Y2hhbmdlIiwiZmF2b3VyaXRlcyIsImluaXRTdG9yZSIsInN0b3JlIiwiZW1pdERhdGEiLCJ0aW1lc3RhbXAiLCJ3aGVuIiwiRGF0ZSIsInRpbWUiLCJ0aW1lQWdvIiwiaW5uZXJIVE1MIiwiZGF0YUVtaXRIYW5kbGVyIiwibmV3U29ja2V0RGF0YSIsIkpTT04iLCJwYXJzZSIsIkRhdGFUYWJsZSIsImNoYW5nZXNldHMiLCJhcHBseUNoYW5nZXMiLCJzdG9yZUVtaXRIYW5kbGVyIiwic29ja2V0IiwiaW8iLCJncmlkRWxlbWVudCIsImdyaWQiLCJhZ0dyaWQiLCJHcmlkIiwic2V0SW50ZXJ2YWwiLCJvbiIsIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiZXZhbCIsIl9fd2VicGFja19leHBvcnRzX18iLCJleGNoYW5nZURhdGFNb2RlbCIsImZpYXRJZHMiLCJjcnlwdG9JZHMiLCJleGNoYW5nZXMiLCJvdXRwdXRPYmplY3QiLCJpZHMiLCJjb3VudHJ5IiwiZW50cmllcyIsImZpYXQiLCJjcnlwdG8iLCJDb3VudHJ5IiwidXJsIiwiVXJsIiwiTmFtZSIsImxvZ29VcmwiLCJMb2dvVXJsIiwiZGV4IiwiQ2VudHJhbGl6YXRpb25UeXBlIiwiX251bWJlck9mRmlhdEN1cnJlbmNpZXMiLCJudW1iZXJPZkNyeXB0b2N1cnJlbmNpZXMiLCJfbnVtYmVyT2ZDcnlwdG9DdXJyZW5jaWVzIiwib3V0cHV0QXJyYXkiLCJwcm9wZXJ0aWVzIiwiZXhjaGFuZ2VIdG1sQ29udGVudCIsInRvdGFsIiwibnVtYmVyR3JvdXBEaWdpdHMiLCJjbGFzc2VzIiwiZGV4TGlzdCIsImhlYWRlciIsIm51bWJlck9mRGV4IiwibnVtYmVyT2ZGaWF0IiwibnVtYmVyT2ZDcnlwdG8iLCJib2R5IiwiY29udGVudEh0bWwiLCJ0YXJnZXQiLCJjc3NJZCIsImNvbnRlbnRQb3BkaXYiLCJjb250ZW50RXhjaGFuZ2UiLCJodG1sVG9nZ2xlQ2xhc3MiLCJleGNoYW5nZVN1cHBvcnRlZCIsIm1hcE5hbWVJZCIsInN1cHBvcnRlZCIsIm1hcCIsInJlZHVjZSIsImFjYyIsInZhbCIsInRvVXBwZXJDYXNlIiwic3VwcG9ydGVkSWRzIiwiYSIsInRyYWRpbmd2aWV3R2V0U3ltYm9sIiwic3ltYm9sVG8iLCJzeW1ib2xGcm9tIiwicGFpciIsInN5bWJvbCIsIndhcm4iLCJsb2FkVHJhZGluZ3ZpZXciLCJjb250YWluZXJfaWQiLCJUcmFkaW5nVmlldyIsIndpZGdldCIsImF1dG9zaXplIiwiaW50ZXJ2YWwiLCJ0aW1lem9uZSIsInN0eWxlIiwibG9jYWxlIiwidG9vbGJhcl9iZyIsImVuYWJsZV9wdWJsaXNoaW5nIiwiYWxsb3dfc3ltYm9sX2NoYW5nZSIsInNhdmVfaW1hZ2UiLCJzdHVkaWVzIiwiaHRtbFBvbGxFbGVtZW50IiwicmVzdWx0IiwiaHRtbCIsImNyZWF0ZUVsZW1lbnQiLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwibmV3VmFsIiwib2xkVmFsIiwiZGlnaXRzIiwiaXNOdW1iZXIiLCJmb3JtYXROdW1iZXJBc0N1cnJlbmN5IiwiZGlmZk51bWVyaWNTdHJpbmdzIiwic3RhcnQiLCJlbmQiLCJjc3NDbGFzcyIsImdldENzc0NsYXNzIiwibGlua0h0bWwiLCJzZXRBdHRyaWJ1dGUiLCJmaWxlTmFtZSIsImltZ1VybCIsImltZyIsIm51bWJlciIsImNlbGxSZW5kZXJlclRyYWRpbmd2aWV3IiwiYXJyIiwicHJpY2VEYXRhIiwieSIsImQzU3BhcmtsaW5lIiwic3R5bGVzIiwidm9sdW1lRGF0YSIsIm51bURheXMiLCJzdGVwcyIsIk1hdGgiLCJtYXgiLCJmbG9vciIsInAwIiwicDEiLCJwMiIsInkwIiwieTEiLCJ5MiIsImFycmF5QXZlcmFnZSIsImQzU2ltcGxlQmFyQ2hhcnQiLCJmaWxsIiwiY2VsbFJlbmRlcmVyU3BhcmtsaW5lIiwidHMiLCJzdHJpbmdpZnkiLCJkaXYiLCJhcHBlbmRDaGlsZCIsIm5vZGUiLCJlR3VpIiwiY3J5cHRvaHViTG9hZENlbGwiLCJ2YWx1ZUZvcm1hdHRlZCIsImVWYWx1ZSIsImtleXMiLCJpdGVtIiwibmV3T2JqIiwibmV3RGF0YSIsImFycmF5RGF0YSIsIm9iaiIsIklkIiwicmVnZXgiLCJtYXRjaCIsInZhbHVlS2V5IiwiayIsInYiLCJyZXBsYWNlIiwiTnVtYmVyRmxvYXRpbmdGaWx0ZXIiLCJpbml0Iiwib25GbG9hdGluZ0ZpbHRlckNoYW5nZWQiLCJjdXJyZW50VmFsdWUiLCJlRmlsdGVySW5wdXQiLCJ0aGF0Iiwib25JbnB1dEJveENoYW5nZWQiLCJvblBhcmVudE1vZGVsQ2hhbmdlZCIsInBhcmVudE1vZGVsIiwiZ2V0R3VpIiwiTnVtYmVyRmlsdGVyIiwiZmlsdGVyVGV4dCIsInNldHVwR3VpIiwiZ3VpIiwib25GaWx0ZXJDaGFuZ2VkIiwiZXh0cmFjdEZpbHRlclRleHQiLCJmaWx0ZXJDaGFuZ2VkQ2FsbGJhY2siLCJlRmlsdGVyVGV4dCIsImRvZXNGaWx0ZXJQYXNzIiwiaW5wdXQiLCJzcGxpdCIsIndoaXRlbGlzdCIsInNpZ25zIiwiaXNOYU4iLCJhcmVBbGxWYWxpZCIsInNvbWUiLCJzaWduIiwiaW5jbHVkZXMiLCJudW1CZWZvcmVTaWducyIsIm51bSIsImdlbmVyYXRlRXhwcmVzc2lvbiIsImlkeCIsIk51bWJlciIsImpvaW4iLCJleHByZXNzaW9uU3RyIiwicGFzc2VkIiwiRnVuY3Rpb24iLCJlcnJvciIsImlzRmlsdGVyQWN0aXZlIiwidW5kZWZpbmVkIiwiZ2V0TW9kZWwiLCJzZXRNb2RlbCIsIm1vZGVsIiwiZ2V0Q2VsbENzc0NsYXNzRGlmZiIsImVsZW1lbnQiLCJhcHBlbmRUbyIsImRlZmF1bHRUaXBweU9wdGlvbnMiLCJwb3BwZXJPcHRpb25zIiwibW9kaWZpZXJzIiwicHJldmVudE92ZXJmbG93IiwiZXNjYXBlV2l0aFJlZmVyZW5jZSIsImhpZGUiLCJlbmFibGVkIiwiZmxpcCIsImFycm93IiwidHJpZ2dlciIsIm11bHRpcGxlIiwiYWxsb3dIVE1MIiwic2hvd09uSW5pdCIsImludGVyYWN0aXZlIiwiYXNzaWduIiwiZDEiLCJkMiIsIkluZmluaXR5IiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJpc09iamVjdCIsInVwIiwiZG4iLCJuYyIsInBsYWNlaG9sZGVyIiwidXBQZXIiLCJkblBlciIsIm5jUGVyIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQSwwQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0IsdUJBQXVCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0NBRUE7O0FBQ0E7Q0FHQTs7Q0FHQTs7Q0FHQTs7QUFDQTtDQUdBOztDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ2U7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLFlBQVUsRUFBRSxFQW5CQztBQXFCYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLGFBQVcsRUFBRTtBQUVYQyxxQkFBaUIsRUFBRTtBQUNqQjtBQUNBO0FBQ0FDLFlBQU0sRUFBRUMsb0VBSFM7QUFJakJDLGFBQU8sRUFBRUMsOERBQVdBO0FBSkgsS0FGUjtBQVNYQyxvQkFBZ0IsRUFBRTtBQUVoQjtBQUNBQyxZQUFNLEVBQUVDLCtEQUhRO0FBSWhCQyxrQkFBWSxFQUFFLElBSkU7QUFNaEI7QUFDQUMsNkJBQXVCLEVBQUVDLHdFQVBUO0FBUWhCQyxtQ0FBNkIsRUFBRTtBQUM3Qkgsb0JBQVksRUFBRSxJQURlO0FBRTdCSSw0QkFBb0IsRUFBRTtBQUZPLE9BUmY7QUFhaEI7QUFDQUMsZ0JBQVUsRUFBRUMsOERBZEk7QUFnQmhCO0FBQ0FDLGVBQVMsRUFBRTtBQWpCSyxLQVRQO0FBOEJYQyxvQkFBZ0IsRUFBRTtBQUNoQkMsb0JBQWMsRUFBRTtBQUNkLDhCQUFzQiwwQkFBQUMsQ0FBQztBQUFBLGlCQUFJQSxDQUFDLENBQUNDLEtBQUYsSUFBV0QsQ0FBQyxDQUFDQyxLQUFGLENBQVFBLEtBQVIsR0FBZ0IsQ0FBL0I7QUFBQSxTQURUO0FBRWQsK0JBQXVCLDJCQUFBRCxDQUFDO0FBQUEsaUJBQUlBLENBQUMsQ0FBQ0MsS0FBRixJQUFXRCxDQUFDLENBQUNDLEtBQUYsQ0FBUUEsS0FBUixHQUFnQixDQUEvQjtBQUFBO0FBRlYsT0FEQTtBQUtoQkMsb0JBQWMsRUFBRUMsZ0ZBTEE7QUFNaEI7QUFDQUMsa0JBQVksRUFBRUMsOEVBQW9CQTtBQVBsQixLQTlCUDtBQXdDWEMsaUJBQWEsRUFBRTtBQUNibEIsWUFBTSxFQUFFO0FBREs7QUF4Q0osR0ExQkE7QUF3RWJtQixZQUFVLEVBQUUsRUF4RUM7QUEwRWJDLGlCQTFFYSwyQkEwRUdDLE1BMUVILEVBMEVXO0FBQ3RCLFFBQU1DLEtBQUssR0FBR0QsTUFBTSxDQUFDRSxNQUFQLENBQWNELEtBQTVCO0FBQ0EsUUFBSUUsTUFBTSxHQUFHLElBQWI7O0FBQ0EsUUFBSUYsS0FBSyxLQUFLLHlCQUFkLEVBQXlDO0FBQ3ZDRSxZQUFNLEdBQUcsYUFBVDtBQUNEOztBQUNEQyxVQUFNLENBQUNDLEVBQVAsQ0FBVUMsSUFBVixDQUFlQyxnQkFBZixDQUFnQ0MsU0FBaEMsQ0FBMENSLE1BQTFDLEVBQWtERyxNQUFsRDtBQUNELEdBakZZO0FBbUZiTSxnQkFuRmEsMEJBbUZFVCxNQW5GRixFQW1GVTtBQUNyQkksVUFBTSxDQUFDQyxFQUFQLENBQVVDLElBQVYsQ0FBZUMsZ0JBQWYsQ0FBZ0NHLFFBQWhDLENBQXlDVixNQUF6QztBQUNELEdBckZZO0FBdUZiVyx5QkF2RmEsbUNBdUZXWCxNQXZGWCxFQXVGbUI7QUFDOUJZLFdBQU8sQ0FBQ0MsR0FBUixDQUFZYixNQUFaO0FBQ0QsR0F6Rlk7QUEyRmJjLHFCQTNGYSwrQkEyRk9kLE1BM0ZQLEVBMkZlO0FBQzFCWSxXQUFPLENBQUNDLEdBQVIsQ0FBWWIsTUFBWjtBQUNELEdBN0ZZO0FBK0ZiZSxXQUFTLEVBQUUsRUEvRkU7QUFpR2I7QUFDQUMsU0FBTyxFQUFFWixNQUFNLENBQUNhLElBQVAsQ0FBWUQsT0FsR1I7QUFvR2I7QUFDQUUsdUJBQXFCLEVBQUUsSUFyR1Y7QUF1R2I7QUFDQUMsY0FBWSxFQUFFLElBeEdEO0FBMEdiO0FBQ0E7QUFDQUMsZUFBYSxFQUFFLElBNUdGO0FBOEdiO0FBQ0FDLGdCQUFjLEVBQUUsSUEvR0g7QUFpSGI7QUFDQUMsaUJBQWUsRUFBRSxJQWxISjtBQW9IYjtBQUNBO0FBQ0E7QUFDQUMsa0JBQWdCLEVBQUUsSUF2SEw7QUF5SGI7QUFDQUMsYUFBVyxFQUFFLEtBMUhBO0FBNEhiO0FBQ0FDLGNBQVksRUFBRSxVQTdIRDtBQStIYkMsY0FBWSxFQUFFLHNCQUFBQyxJQUFJLEVBQUk7QUFDcEIsV0FBT0EsSUFBSSxDQUFDLHNCQUFELENBQUosQ0FBNkJuQyxLQUFwQztBQUNELEdBaklZO0FBbUliO0FBQ0FvQyxlQUFhLEVBQUU7QUFDYkMsWUFBUSxFQUFFLEtBREc7QUFFYkMsYUFBUyxFQUFFLElBRkU7QUFHYjlDLGlDQUE2QixFQUFFO0FBQzdCSCxrQkFBWSxFQUFFLElBRGU7QUFFN0JJLDBCQUFvQixFQUFFO0FBRk87QUFIbEI7QUFwSUYsQ0FBZixFOzs7Ozs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Q0FFQTs7Ozs7O0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBUUEsU0FBUzhDLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQztBQUVuQyxNQUFJQyxFQUFKO0FBQ0EsTUFBSUMsTUFBSjtBQUNBLE1BQU1DLE1BQU0sR0FBRyxFQUFmO0FBSm1DO0FBQUE7QUFBQTs7QUFBQTtBQUtuQyx5QkFBZUgsT0FBZiw4SEFBd0I7QUFBbkJFLFlBQW1CO0FBQ3RCRCxRQUFFLEdBQUdDLE1BQU0sQ0FBQ0QsRUFBWjs7QUFDQSxVQUFJQSxFQUFFLElBQUlHLDBEQUFWLEVBQXlCO0FBQ3ZCRCxjQUFNLENBQUNFLElBQVAsQ0FBWUQsMERBQWEsQ0FBQ0gsRUFBRCxDQUF6QjtBQUNEO0FBQ0Y7QUFWa0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFXbkMsU0FBT0UsTUFBUDtBQUVEO0FBRUQ7Ozs7Ozs7QUFLQSxTQUFTRyxXQUFULENBQXFCdEMsTUFBckIsRUFBNkI7QUFFM0I7QUFDQUEsUUFBTSxDQUFDdUMsR0FBUCxDQUFXQyxZQUFYLENBQXdCLENBQ3RCO0FBQ0VDLFNBQUssRUFBRUwsMERBQWEsQ0FBQ00sMERBQWEsQ0FBQ0MsSUFBZCxDQUFtQlQsTUFBcEIsQ0FBYixDQUF5Q2pDLEtBRGxEO0FBRUUwQyxRQUFJLEVBQUVELDBEQUFhLENBQUNDLElBQWQsQ0FBbUJDO0FBRjNCLEdBRHNCLENBQXhCO0FBT0F4QyxRQUFNLENBQUNDLEVBQVAsQ0FBVXdDLElBQVYsQ0FBZUMsT0FBZixDQUF1QixLQUF2QjtBQUNBMUMsUUFBTSxDQUFDYSxJQUFQLENBQVk4QixXQUFaLEdBQTBCM0MsTUFBTSxDQUFDNEMsUUFBakM7QUFDQTVDLFFBQU0sQ0FBQ2EsSUFBUCxDQUFZRCxPQUFaLEdBQXNCaUMsMEZBQTJCLENBQUM3QyxNQUFNLENBQUM0QyxRQUFQLElBQW1CLEVBQXBCLENBQWpEO0FBQ0FoRCxRQUFNLENBQUN1QyxHQUFQLENBQVdXLFVBQVgsQ0FBc0I5QyxNQUFNLENBQUNhLElBQVAsQ0FBWUQsT0FBbEM7QUFFQW1DLGdGQUFjLENBQUMvQyxNQUFNLENBQUNhLElBQVAsQ0FBWThCLFdBQWIsQ0FBZDtBQUVEOztBQUFBO0FBRUQ7Ozs7OztBQUtlLFNBQVNLLGlCQUFULEdBQTZCO0FBRTFDLE1BQUksQ0FBQ2hELE1BQU0sQ0FBQ0MsRUFBWixFQUFnQixNQUFNLElBQUlnRCxLQUFKLENBQVUsMEJBQVYsQ0FBTjtBQUNoQixNQUFJLENBQUNqRCxNQUFNLENBQUNhLElBQVosRUFBa0IsTUFBTSxJQUFJb0MsS0FBSixDQUFVLDRCQUFWLENBQU4sQ0FId0IsQ0FLMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNdkQsVUFBVSxHQUFHaUMsa0JBQWtCLENBQUNXLDBEQUFhLENBQUNWLE9BQWYsQ0FBckM7O0FBRUEsTUFBTXNCLE9BQU8sR0FBR2xELE1BQU0sQ0FBQ0MsRUFBUCxDQUFVa0QsU0FBVixxQkFDWEMsZ0VBRFcsRUFFWDtBQUFFMUQsY0FBVSxFQUFWQTtBQUFGLEdBRlcsRUFHWDtBQUFFd0MsZUFBVyxFQUFYQTtBQUFGLEdBSFcsQ0FBaEI7O0FBTUEsU0FBT2dCLE9BQVA7QUFFRCxDOzs7Ozs7Ozs7Ozs7QUNuRkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtDQUVBOzs7Ozs7OztBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0FBRUE7O0lBRXFCRyxnQjs7O0FBRW5CLDhCQUFjO0FBQUE7O0FBQ1osU0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxTQUFLQyxZQUFMLEdBQW9CO0FBQ2xCQyxXQUFLLEVBQUUsT0FEVztBQUVsQkMsZUFBUyxFQUFFLE9BRk87QUFHbEJDLGlCQUFXLEVBQUUsT0FISztBQUlsQkMsdUJBQWlCLEVBQUUsQ0FKRDtBQUtsQkMseUJBQW1CLEVBQUUsQ0FMSDtBQU1sQkMsWUFOa0Isa0JBTVhDLEtBTlcsRUFNSjtBQUNaLFlBQU1DLE1BQU0sR0FBR0QsS0FBSyxDQUFDRSxTQUFOLENBQWdCQyxPQUFoQixDQUF3QkMsTUFBeEIsS0FBbUMsTUFBbEQ7QUFDQSxZQUFNQyxRQUFRLEdBQUdMLEtBQUssQ0FBQ0UsU0FBTixDQUFnQkMsT0FBaEIsQ0FBd0JHLE9BQXhCLEtBQW9DLE1BQXJEO0FBQ0EsWUFBSUwsTUFBTSxJQUFJSSxRQUFkLEVBQXdCLE9BQU8sS0FBUCxDQUF4QixLQUNLLE9BQU8sSUFBUDtBQUNOO0FBWGlCLEtBQXBCO0FBYUQ7QUFFRDs7Ozs7Ozs7OztBQXNDQTs7Ozs7c0NBS2tCRSxLLEVBQU9DLE8sRUFBUztBQUNoQ0Msc0VBQU0sQ0FBQ0YsS0FBRCxFQUFRQyxPQUFSLEVBQWlCLEtBQUtmLFlBQXRCLENBQU47QUFDQWMsV0FBSyxDQUFDRyxhQUFOLEdBQXNCSCxLQUFLLENBQUNJLE1BQTVCO0FBQ0FKLFdBQUssQ0FBQ0ssU0FBTixDQUFnQkMsR0FBaEIsQ0FBb0IsZUFBcEI7QUFDQU4sV0FBSyxDQUFDSixPQUFOLENBQWNHLE9BQWQsR0FBd0IsTUFBeEI7QUFDQSxXQUFLZixhQUFMLEdBQXFCZ0IsS0FBckI7QUFDRDtBQUVEOzs7Ozs7OztxQ0FLaUJBLEssRUFBTztBQUN0QkEsV0FBSyxDQUFDSixPQUFOLENBQWNHLE9BQWQsR0FBd0IsS0FBeEI7QUFDQUMsV0FBSyxDQUFDSixPQUFOLENBQWNDLE1BQWQsR0FBdUIsS0FBdkI7QUFDQSxXQUFLYixhQUFMLEdBQXFCLElBQXJCOztBQUNBLFVBQUlnQixLQUFLLENBQUNHLGFBQVYsRUFBeUI7QUFDdkJILGFBQUssQ0FBQ0csYUFBTixDQUFvQlIsU0FBcEIsQ0FBOEJVLFNBQTlCLENBQXdDRSxNQUF4QyxDQUErQyxlQUEvQztBQUNBUCxhQUFLLENBQUNHLGFBQU4sQ0FBb0JLLE9BQXBCOztBQUNBLFlBQUlSLEtBQUssQ0FBQ0csYUFBVixFQUF5QjtBQUN2QkgsZUFBSyxDQUFDUyxRQUFOLENBQWVDLG1CQUFmLENBQW1DLE9BQW5DLEVBQTRDLEtBQUtDLG1CQUFqRDtBQUNBWCxlQUFLLENBQUNHLGFBQU4sQ0FBb0JLLE9BQXBCO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7Ozs7Ozs7O3dDQUtvQkksTyxFQUFTdEYsTSxFQUFRRyxNLEVBQVE7QUFDM0MsVUFBTXVFLEtBQUssR0FBRzFFLE1BQU0sQ0FBQ3VGLEtBQVAsQ0FBYUMsVUFBYixDQUF3QkMsT0FBeEIsQ0FBZ0MsVUFBaEMsQ0FBZDs7QUFDQSxVQUFJZixLQUFLLENBQUNKLE9BQU4sQ0FBY0MsTUFBZCxLQUF5QixNQUE3QixFQUFxQztBQUNuQ2UsZUFBTyxDQUFDSSxnQkFBUixDQUF5QmhCLEtBQXpCO0FBQ0FqQix3QkFBZ0IsQ0FBQ2tDLEtBQWpCLENBQXVCM0YsTUFBdkI7QUFDRCxPQUhELE1BSUs7QUFDSHlELHdCQUFnQixDQUFDbUMsSUFBakIsQ0FBc0I1RixNQUF0QixFQUE4QkcsTUFBOUI7QUFDRDtBQUNGO0FBRUQ7Ozs7Ozs7OzZCQUtTSCxNLEVBQVE7QUFFZixVQUFNMEUsS0FBSyxHQUFHMUUsTUFBTSxDQUFDdUYsS0FBUCxDQUFhQyxVQUFiLENBQXdCQyxPQUF4QixDQUFnQyxVQUFoQyxDQUFkOztBQUNBLFVBQUksQ0FBQ2YsS0FBSyxDQUFDUyxRQUFYLEVBQXFCO0FBQ25CLGFBQUtPLGdCQUFMLENBQXNCaEIsS0FBdEI7QUFDRCxPQUxjLENBT2Y7QUFDQTtBQUNBO0FBQ0E7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0M7QUFFRDs7Ozs7Ozs7OEJBS1UxRSxNLEVBQVFHLE0sRUFBUTtBQUV4QixVQUFNOEIsRUFBRSxHQUFHNEQsMEVBQVksRUFBdkI7QUFDQSxVQUFNbkIsS0FBSyxHQUFHMUUsTUFBTSxDQUFDdUYsS0FBUCxDQUFhQyxVQUFiLENBQXdCQyxPQUF4QixDQUFnQyxVQUFoQyxDQUFkO0FBQ0EsVUFBTUssS0FBSyxHQUFHcEIsS0FBSyxDQUFDcUIsV0FBcEI7QUFDQSxVQUFNQyxNQUFNLEdBQUd0QixLQUFLLENBQUN1QixZQUFyQjtBQUNBLFVBQU10QixPQUFPLEdBQUd1Qix1RUFBTyxDQUFDLHFCQUFELENBQVAsQ0FBK0I7QUFBQ2pFLFVBQUUsRUFBRkE7QUFBRCxPQUEvQixDQUFoQjtBQUNBLFVBQU1rRSxpQkFBaUIsR0FBRyxLQUFLekMsYUFBTCxJQUFzQixLQUFLQSxhQUFMLENBQW1CWSxPQUFuQixDQUEyQkMsTUFBM0IsS0FBc0MsTUFBdEYsQ0FQd0IsQ0FTeEI7O0FBQ0EsVUFBSUcsS0FBSyxDQUFDSixPQUFOLENBQWNDLE1BQWQsS0FBeUIsTUFBN0IsRUFBcUMsT0FWYixDQVl4Qjs7QUFDQSxVQUFJRyxLQUFLLEtBQUssS0FBS2hCLGFBQW5CLEVBQWtDOztBQUVsQyxVQUFJLEtBQUtBLGFBQUwsSUFBc0IsQ0FBQ3lDLGlCQUEzQixFQUE4QztBQUM1QyxhQUFLVCxnQkFBTCxDQUFzQixLQUFLaEMsYUFBM0I7QUFDRCxPQWpCdUIsQ0FtQnhCOzs7QUFDQSxVQUFJLENBQUN2RCxNQUFMLEVBQWE7O0FBRWIsVUFBSXVFLEtBQUssQ0FBQ0osT0FBTixDQUFjRyxPQUFkLEtBQTBCLE1BQTlCLEVBQXNDO0FBQ3BDLGFBQUsyQixpQkFBTCxDQUF1QjFCLEtBQXZCLEVBQThCQyxPQUE5QjtBQUNELE9BeEJ1QixDQTBCeEI7OztBQUVBLFVBQU1RLFFBQVEsR0FBR2tCLFFBQVEsQ0FBQ0MsYUFBVCxnQ0FBK0NyRSxFQUEvQyxFQUFqQjtBQUNBLFVBQUksQ0FBQ2tELFFBQUwsRUFBZTtBQUVmVCxXQUFLLENBQUNTLFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0FULFdBQUssQ0FBQ0csYUFBTixHQUFzQkgsS0FBSyxDQUFDSSxNQUE1QjtBQUVBSyxjQUFRLENBQUNvQixnQkFBVCxDQUNFLE9BREYsRUFFRUMsZ0ZBQWtCLENBQUMsS0FBS25CLG1CQUFOLEVBQTJCLElBQTNCLEVBQWlDckYsTUFBakMsRUFBeUNHLE1BQXpDLENBRnBCLEVBR0UsS0FIRjtBQU1EOzs7eUJBMUpXSCxNLEVBQVFHLE0sRUFBUTtBQUUxQixVQUFNdUUsS0FBSyxHQUFHMUUsTUFBTSxDQUFDdUYsS0FBUCxDQUFhQyxVQUFiLENBQXdCQyxPQUF4QixDQUFnQyxVQUFoQyxDQUFkLENBRjBCLENBRzFCO0FBRUE7O0FBQ0EsY0FBUXRGLE1BQVI7QUFDRSxhQUFLLGFBQUw7QUFDRXVFLGVBQUssQ0FBQ0osT0FBTixDQUFjQyxNQUFkLEdBQXVCLElBQXZCOztBQUNBRyxlQUFLLENBQUNJLE1BQU4sQ0FBYTJCLEdBQWIsQ0FBaUI7QUFDZjFDLHVCQUFXLEVBQUU7QUFERSxXQUFqQjs7QUFHQTJDLDZGQUFzQixDQUFDLEtBQUQsRUFBUTFHLE1BQVIsQ0FBdEI7QUFDQTBFLGVBQUssQ0FBQ2lDLFlBQU4sR0FBcUJqQyxLQUFLLENBQUNJLE1BQTNCO0FBQ0E7O0FBQ0YsZ0JBVEYsQ0FVSTs7QUFWSjtBQWFEO0FBRUQ7Ozs7Ozs7OzBCQUthOUUsTSxFQUFRO0FBQ25CLFVBQU0wRSxLQUFLLEdBQUcxRSxNQUFNLENBQUN1RixLQUFQLENBQWFDLFVBQWIsQ0FBd0JDLE9BQXhCLENBQWdDLFVBQWhDLENBQWQ7O0FBQ0EsVUFBSWYsS0FBSyxDQUFDaUMsWUFBVixFQUF3QjtBQUN0QmpDLGFBQUssQ0FBQ2lDLFlBQU4sQ0FBbUJ6QixPQUFuQjtBQUNEO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JFSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Q0FFQTs7QUFDQTtDQUdBOztDQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0NBR0E7O0FBQ0E7Q0FHQTs7QUFDQTtBQUVBLElBQU1wRixVQUFVLEdBQUc7QUFFakI7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOEcsVUFBUSxFQUFFO0FBQ1JDLGVBQVcsRUFBRSxlQURMO0FBRVJDLGNBQVUsRUFBRSxHQUZKO0FBR1JDLGVBQVcsRUFBRSxRQUhMO0FBSVJDLGlCQUFhLEVBQUUsWUFKUDtBQUtSbEIsU0FBSyxFQUFFLEVBTEM7QUFNUm1CLFVBQU0sRUFBRSxNQU5BO0FBT1JDLGdCQUFZLEVBQUUsSUFQTjtBQVFSckksZ0JBQVksRUFBRSxJQVJOO0FBU1JzSSxrQkFBYyxFQUFFLElBVFI7QUFVUi9ILGFBQVMsRUFBRSx1QkFWSDtBQVdSTyxnQkFYUSx3QkFXS0ssTUFYTCxFQVdhO0FBQ25CLGFBQU9BLE1BQU0sQ0FBQ1IsS0FBUCxHQUFlLENBQXRCO0FBQ0QsS0FiTztBQWNSNEgsUUFBSSxFQUFFLENBQ0osa0JBREk7QUFkRSxHQVhPO0FBOEJqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxNQUFJLEVBQUU7QUFDSnBILFNBQUssRUFBRSxrQ0FESDtBQUVKNkcsY0FBVSxFQUFFLE1BRlI7QUFHSkMsZUFBVyxFQUFFLFFBSFQ7QUFJSkMsaUJBQWEsRUFBRSxNQUpYO0FBS0psQixTQUFLLEVBQUUsR0FMSDtBQU1KbUIsVUFBTSxFQUFFLE1BTko7QUFPSnRILGdCQUFZLEVBQUUySCxvRUFBZ0JBO0FBUDFCLEdBbENXO0FBNENqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxTQUFPLEVBQUU7QUFDUHRILFNBQUssRUFBRSxtQkFEQTtBQUVQNkcsY0FBVSxFQUFFLFNBRkw7QUFHUEMsZUFBVyxFQUFFLFFBSE47QUFJUEMsaUJBQWEsRUFBRSxTQUpSO0FBS1BsQixTQUFLLEVBQUUsR0FMQTtBQU1Qc0IsUUFBSSxFQUFFLENBQUMsZUFBRCxDQU5DO0FBT1AzSCxrQkFQTywwQkFPUU8sTUFQUixFQU9nQjtBQUNyQixVQUFNUixLQUFLLEdBQUdnSSxxRkFBRyxDQUFDeEgsTUFBRCxFQUFTLGFBQVQsQ0FBakI7QUFDQSxVQUFJLENBQUN5SCxLQUFLLENBQUNDLE9BQU4sQ0FBY2xJLEtBQWQsQ0FBRCxJQUF5QixDQUFDQSxLQUFLLENBQUNtSSxNQUFwQyxFQUE0QyxPQUFPQyxFQUFFLENBQUNDLGNBQVYsQ0FBNUMsS0FDSyxPQUFPckksS0FBUDtBQUNOO0FBWE0sR0FoRFE7QUE4RGpCO0FBQ0E7QUFDQTtBQUNBc0ksVUFBUSxFQUFFO0FBQ1I3SCxTQUFLLEVBQUUseUJBREM7QUFFUjZHLGNBQVUsRUFBRSxhQUZKO0FBR1JDLGVBQVcsRUFBRSxRQUhMO0FBSVJDLGlCQUFhLEVBQUUsNENBSlA7QUFLUmxCLFNBQUssRUFBRSxHQUxDO0FBTVJzQixRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBTkU7QUFVUnpILGdCQUFZLEVBQUU2RyxnRkFBa0IsQ0FBQ3VCLHdFQUFELEVBQXVCM0gsTUFBTSxDQUFDYSxJQUE5QixDQVZ4QjtBQVdSK0csc0JBQWtCLEVBQUU7QUFDbEJDLGNBQVEsRUFBRTtBQURRLEtBWFosQ0FjUjs7QUFkUSxHQWpFTztBQW1GakI7QUFDQTtBQUNBO0FBQ0FDLFVBQVEsRUFBRTtBQUNSakksU0FBSyxFQUFFLHFCQURDO0FBRVI2RyxjQUFVLEVBQUUsYUFGSjtBQUdSQyxlQUFXLEVBQUUsUUFITDtBQUlSQyxpQkFBYSxFQUFFLGlGQUpQO0FBS1JsQixTQUFLLEVBQUUsR0FMQztBQU1Sc0IsUUFBSSxFQUFFLENBQ0osbUJBREksRUFFSixrQkFGSSxDQU5FO0FBVVJ6SCxnQkFBWSxFQUFFNkcsZ0ZBQWtCLENBQUN1Qix3RUFBRCxFQUF1QjNILE1BQU0sQ0FBQ2EsSUFBOUIsQ0FWeEI7QUFXUitHLHNCQUFrQixFQUFFO0FBQ2xCQyxjQUFRLEVBQUU7QUFEUSxLQVhaO0FBY1JFLGlCQUFhLEVBQUUzQixnRkFBa0IsQ0FBQ0UsMkVBQUQsRUFBeUIsS0FBekI7QUFkekIsR0F0Rk87QUF1R2pCO0FBQ0E7QUFDQTtBQUNBMEIsUUFBTSxFQUFFO0FBQ05uSSxTQUFLLEVBQUUscUJBREQ7QUFFTjZHLGNBQVUsRUFBRSxLQUZOO0FBR05DLGVBQVcsRUFBRSxRQUhQO0FBSU5DLGlCQUFhLEVBQUUsK0NBSlQ7QUFLTmxCLFNBQUssRUFBRSxHQUxEO0FBTU5zQixRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBTkE7QUFVTnpILGdCQUFZLEVBQUU2RyxnRkFBa0IsQ0FBQ3VCLHdFQUFELEVBQXVCM0gsTUFBTSxDQUFDYSxJQUE5QixDQVYxQjtBQVdOK0csc0JBQWtCLEVBQUU7QUFDbEJDLGNBQVEsRUFBRTtBQURRO0FBWGQsR0ExR1M7QUEwSGpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUksYUFBVyxFQUFFO0FBQ1hwSSxTQUFLLEVBQUUsMkJBREk7QUFFWDZHLGNBQVUsRUFBRSxXQUZEO0FBR1hDLGVBQVcsRUFBRSxRQUhGO0FBSVhDLGlCQUFhLEVBQUUsa0dBSko7QUFLWGxCLFNBQUssRUFBRSxHQUxJO0FBTVhzQixRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBTks7QUFVWHpILGdCQUFZLEVBQUU2RyxnRkFBa0IsQ0FBQ3VCLHdFQUFELEVBQXVCM0gsTUFBTSxDQUFDYSxJQUE5QixDQVZyQjtBQVdYK0csc0JBQWtCLEVBQUU7QUFDbEJDLGNBQVEsRUFBRTtBQURRO0FBWFQsR0FySUk7QUFxSmpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0FLLHFCQUFtQixFQUFFO0FBQ25CckksU0FBSyxFQUFFLGdDQURZO0FBRW5CNkcsY0FBVSxFQUFFLE9BRk87QUFHbkJDLGVBQVcsRUFBRSxRQUhNO0FBSW5CQyxpQkFBYSxFQUFFLHdFQUpJO0FBS25CbEIsU0FBSyxFQUFFLEVBTFk7QUFNbkJzQixRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLEVBR0osa0JBSEk7QUFOYSxHQXpKSjtBQXNLakI7QUFDQTtBQUNBO0FBQ0FtQixvQkFBa0IsRUFBRTtBQUNsQnRJLFNBQUssRUFBRSwwQ0FEVztBQUVsQjZHLGNBQVUsRUFBRSxNQUZNO0FBR2xCQyxlQUFXLEVBQUUsUUFISztBQUlsQkMsaUJBQWEsRUFBRSxnRUFKRztBQUtsQmxCLFNBQUssRUFBRSxFQUxXO0FBTWxCc0IsUUFBSSxFQUFFLENBQ0osbUJBREksRUFFSixrQkFGSSxFQUdKLGtCQUhJO0FBTlksR0F6S0g7QUFzTGpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBb0IsY0FBWSxFQUFFO0FBQ1p2SSxTQUFLLEVBQUUseUJBREs7QUFFWjZHLGNBQVUsRUFBRSxVQUZBO0FBR1pDLGVBQVcsRUFBRSxRQUhEO0FBSVpDLGlCQUFhLEVBQUUsc0pBSkg7QUFLWmxCLFNBQUssRUFBRSxHQUxLO0FBTVpuRyxnQkFBWSxFQUFFOEksK0VBTkY7QUFPWlQsc0JBQWtCLEVBQUU7QUFDbEJVLFdBQUssRUFBRSxJQURXO0FBRWxCQyxXQUFLLEVBQUUsSUFGVztBQUdsQkMsWUFBTSxFQUFFLElBSFU7QUFJbEJDLGdCQUFVLEVBQUU7QUFKTSxLQVBSO0FBYVo7QUFDQS9HLGFBQVMsRUFBRTtBQWRDLEdBNUxHO0FBNk1qQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FnSCxjQUFZLEVBQUU7QUFDWjdJLFNBQUssRUFBRSxvQ0FESztBQUVaNkcsY0FBVSxFQUFFLFlBRkE7QUFHWkMsZUFBVyxFQUFFLFFBSEQ7QUFJWkMsaUJBQWEsRUFBRSw4SEFKSDtBQUtabEIsU0FBSyxFQUFFLEdBTEs7QUFNWnNCLFFBQUksRUFBRSxDQUNKLG1CQURJLEVBRUosa0JBRkksQ0FOTTtBQVVaekgsZ0JBQVksRUFBRTZHLGdGQUFrQixDQUFDdUIsd0VBQUQsRUFBdUIzSCxNQUFNLENBQUNhLElBQTlCLENBVnBCO0FBV1orRyxzQkFBa0IsRUFBRTtBQUNsQkMsY0FBUSxFQUFFO0FBRFE7QUFYUixHQWxORztBQWtPakI7QUFDQTtBQUNBO0FBQ0FjLGNBQVksRUFBRTtBQUNaOUksU0FBSyxFQUFFLDBCQURLO0FBRVo2RyxjQUFVLEVBQUUsWUFGQTtBQUdaQyxlQUFXLEVBQUUsUUFIRDtBQUlaQyxpQkFBYSxFQUFFLDRGQUpIO0FBS1psQixTQUFLLEVBQUUsR0FMSztBQU1ac0IsUUFBSSxFQUFFLENBQ0osbUJBREksRUFFSixrQkFGSSxDQU5NO0FBVVp6SCxnQkFBWSxFQUFFNkcsZ0ZBQWtCLENBQUN1Qix3RUFBRCxFQUF1QjNILE1BQU0sQ0FBQ2EsSUFBOUIsQ0FWcEI7QUFXWitHLHNCQUFrQixFQUFFO0FBQ2xCQyxjQUFRLEVBQUU7QUFEUTtBQVhSLEdBck9HO0FBcVBqQjtBQUNBO0FBQ0E7QUFDQWUsbUJBQWlCLEVBQUU7QUFDakIvSSxTQUFLLEVBQUUsMEJBRFU7QUFFakI2RyxjQUFVLEVBQUUsb0JBRks7QUFHakJDLGVBQVcsRUFBRSxRQUhJO0FBSWpCQyxpQkFBYSxFQUFFLGtEQUpFO0FBS2pCbEIsU0FBSyxFQUFFLEdBTFU7QUFNakJzQixRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBTlc7QUFVakJ6SCxnQkFBWSxFQUFFc0osc0VBQWtCQTtBQVZmLEdBeFBGO0FBcVFqQjtBQUNBO0FBQ0E7QUFDQUMsV0FBUyxFQUFFO0FBQ1RqSixTQUFLLEVBQUUsbUNBREU7QUFFVDZHLGNBQVUsRUFBRSxPQUZIO0FBR1RDLGVBQVcsRUFBRSxRQUhKO0FBSVRDLGlCQUFhLEVBQUUsMENBSk47QUFLVGxCLFNBQUssRUFBRSxHQUxFO0FBTVRzQixRQUFJLEVBQUUsQ0FBQyxlQUFEO0FBTkcsR0F4UU07QUFpUmpCO0FBQ0E7QUFDQTtBQUNBK0IsTUFBSSxFQUFFO0FBQ0psSixTQUFLLEVBQUUsbUNBREg7QUFFSjZHLGNBQVUsRUFBRSxXQUZSO0FBR0pDLGVBQVcsRUFBRSxRQUhUO0FBSUpDLGlCQUFhLEVBQUUseUNBSlg7QUFLSmxCLFNBQUssRUFBRSxHQUxIO0FBTUpzQixRQUFJLEVBQUUsQ0FBQyxlQUFEO0FBTkYsR0FwUlc7QUE2UmpCO0FBQ0E7QUFDQTtBQUNBZ0MsaUJBQWUsRUFBRTtBQUNmbkosU0FBSyxFQUFFLHNDQURRO0FBRWY2RyxjQUFVLEVBQUUsY0FGRztBQUdmQyxlQUFXLEVBQUUsUUFIRTtBQUlmQyxpQkFBYSxFQUFFLGdEQUpBO0FBS2ZsQixTQUFLLEVBQUUsR0FMUTtBQU1mdUQsbUJBQWUsRUFBRSxNQU5GO0FBT2ZuSyxjQUFVLEVBQUVDLDhEQVBHO0FBUWZpSSxRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBUlM7QUFZZnpILGdCQUFZLEVBQUVzSixzRUFBa0JBO0FBWmpCLEdBaFNBO0FBK1NqQjtBQUNBO0FBQ0E7QUFDQUssbUJBQWlCLEVBQUU7QUFDakJySixTQUFLLEVBQUUsNkJBRFU7QUFFakI2RyxjQUFVLEVBQUUsV0FGSztBQUdqQkMsZUFBVyxFQUFFLFFBSEk7QUFJakJDLGlCQUFhLEVBQUUsMkZBSkU7QUFLakJsQixTQUFLLEVBQUUsR0FMVTtBQU1qQnVELG1CQUFlLEVBQUUsUUFOQTtBQU9qQmpDLFFBQUksRUFBRSxDQUNKLG1CQURJLEVBRUosa0JBRkksQ0FQVztBQVdqQm1DLGFBQVMsRUFBRTtBQUNUQyxhQUFPLEVBQUU7QUFEQSxLQVhNO0FBY2pCN0osZ0JBQVksRUFBRThKLHlFQWRHO0FBZWpCdEIsaUJBQWEsRUFBRXVCLHlFQUFvQkE7QUFmbEIsR0FsVEY7QUFvVWpCO0FBQ0E7QUFDQTtBQUNBQyxlQUFhLEVBQUU7QUFDYjFKLFNBQUssRUFBRSx5QkFETTtBQUViNkcsY0FBVSxFQUFFLE9BRkM7QUFHYkUsaUJBQWEsRUFBRSxnRUFIRjtBQUliRCxlQUFXLEVBQUUsUUFKQTtBQUtiakIsU0FBSyxFQUFFLEdBTE07QUFNYnVELG1CQUFlLEVBQUUsUUFOSjtBQU9iakMsUUFBSSxFQUFFLENBQ0osbUJBREksRUFFSixrQkFGSSxDQVBPO0FBV2J6SCxnQkFBWSxFQUFFc0osc0VBQWtCQTtBQVhuQixHQXZVRTtBQXFWakI7QUFDQTtBQUNBO0FBQ0FXLG1CQUFpQixFQUFFO0FBQ2pCM0osU0FBSyxFQUFFLDZCQURVO0FBRWpCNkcsY0FBVSxFQUFFLFlBRks7QUFHakJFLGlCQUFhLEVBQUUscUVBSEU7QUFJakJELGVBQVcsRUFBRSxRQUpJO0FBS2pCakIsU0FBSyxFQUFFLEdBTFU7QUFNakJ1RCxtQkFBZSxFQUFFLFFBTkE7QUFPakJqQyxRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBUFc7QUFXakJ6SCxnQkFBWSxFQUFFc0osc0VBQWtCQTtBQVhmLEdBeFZGO0FBc1dqQjtBQUNBO0FBQ0E7QUFDQVksd0JBQXNCLEVBQUU7QUFDdEI1SixTQUFLLEVBQUUsa0NBRGU7QUFFdEI2RyxjQUFVLEVBQUUsaUJBRlU7QUFHdEJFLGlCQUFhLEVBQUUsMEVBSE87QUFJdEJELGVBQVcsRUFBRSxRQUpTO0FBS3RCakIsU0FBSyxFQUFFLEdBTGU7QUFNdEJ1RCxtQkFBZSxFQUFFLFFBTks7QUFPdEJqQyxRQUFJLEVBQUUsQ0FDSixtQkFESSxFQUVKLGtCQUZJLENBUGdCO0FBV3RCekgsZ0JBQVksRUFBRXNKLHNFQUFrQkE7QUFYVjtBQXpXUCxDQUFuQjtBQXlYZW5KLHlFQUFmLEU7Ozs7Ozs7Ozs7OztBQ2haQTtDQUVBO0FBQ0E7QUFDQTs7QUFDZTtBQUNia0MsU0FBTyxFQUFFLENBQ1A7QUFBQ0MsTUFBRSxFQUFFO0FBQUwsR0FETyxFQUVQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBRk8sRUFHUDtBQUFDQSxNQUFFLEVBQUU7QUFBTCxHQUhPLEVBSVA7QUFBQ0EsTUFBRSxFQUFFO0FBQUwsR0FKTyxFQUtQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBTE8sRUFNUDtBQUFDQSxNQUFFLEVBQUU7QUFBTCxHQU5PLEVBT1A7QUFBQ0EsTUFBRSxFQUFFO0FBQUwsR0FQTyxFQVFQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBUk8sRUFTUDtBQUFDQSxNQUFFLEVBQUU7QUFBTCxHQVRPLEVBVVA7QUFBQ0EsTUFBRSxFQUFFO0FBQUwsR0FWTyxFQVdQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBWE8sRUFZUDtBQUFDQSxNQUFFLEVBQUU7QUFBTCxHQVpPLEVBYVA7QUFBQ0EsTUFBRSxFQUFFO0FBQUwsR0FiTyxFQWNQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBZE8sRUFlUDtBQUFDQSxNQUFFLEVBQUU7QUFBTCxHQWZPLEVBZ0JQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBaEJPLEVBaUJQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBakJPLEVBa0JQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBbEJPLEVBbUJQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBbkJPLEVBb0JQO0FBQUNBLE1BQUUsRUFBRTtBQUFMLEdBcEJPLENBREk7QUF1QmI2SCxXQUFTLEVBQUUsQ0FDVDtBQUNFN0gsTUFBRSxFQUFFLElBRE47QUFDVztBQUNUOEgsTUFBRSxFQUFFLEtBRk47QUFFYTtBQUNYM0MsUUFBSSxFQUFFLE1BSFI7QUFHZTtBQUNiNEMsWUFBUSxFQUFFLFNBSlosQ0FJc0I7O0FBSnRCLEdBRFMsQ0F2QkU7QUErQmJDLFlBQVUsRUFBRSxDQUNWO0FBRFUsR0EvQkM7QUFrQ2J0SCxNQUFJLEVBQUU7QUFDSlQsVUFBTSxFQUFFLGNBREo7QUFFSlUsYUFBUyxFQUFFO0FBRlA7QUFsQ08sQ0FBZixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUF4QyxNQUFNLENBQUM0QyxRQUFQLEdBQWtCNUMsTUFBTSxDQUFDNEMsUUFBUCxJQUFtQixFQUFyQztBQUNBNUMsTUFBTSxDQUFDOEosU0FBUCxHQUFtQjlKLE1BQU0sQ0FBQzhKLFNBQVAsSUFBb0IsRUFBdkM7QUFFQTlKLE1BQU0sQ0FBQ0MsRUFBUCxHQUFZO0FBQ1Z3QyxNQUFJLEVBQUUsRUFESTtBQUVWdkMsTUFBSSxFQUFFO0FBRkksQ0FBWjtBQUtBRixNQUFNLENBQUNhLElBQVAsR0FBYztBQUNaa0osT0FBSyxFQUFFLEVBREs7QUFDRDtBQUNYbkosU0FBTyxFQUFFLElBRkc7QUFHWm9KLFVBQVEsRUFBRTtBQUhFLENBQWQ7QUFNQWhLLE1BQU0sQ0FBQ3dILEVBQVA7QUFDRUMsZ0JBQWMsRUFBRTtBQURsQixHQUVLcUMsU0FGTDtBQUtBOUosTUFBTSxDQUFDaUssU0FBUCxHQUFtQixJQUFuQjtBQUVBOzs7Ozs7OztBQU9BakssTUFBTSxDQUFDQyxFQUFQLENBQVV3QyxJQUFWLENBQWVDLE9BQWYsR0FBeUIsVUFBVXdILElBQVYsRUFBZ0I7QUFFdkMsTUFBSUEsSUFBSSxLQUFLLEtBQWIsRUFBb0JsSyxNQUFNLENBQUNpSyxTQUFQLEdBQW1CLElBQUlFLElBQUosRUFBbkI7QUFDcEIsTUFBTUMsSUFBSSxHQUFHQyxxRUFBTyxDQUFDckssTUFBTSxDQUFDaUssU0FBUixDQUFwQjtBQUNBaEUsVUFBUSxDQUFDQyxhQUFULENBQXVCLFVBQXZCLEVBQW1Db0UsU0FBbkMscUJBQTBERixJQUExRDtBQUVELENBTkQsQzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWE7Ozs7OztDQUliOztDQUdBOztDQUdBOztBQUNBO0NBR0E7O0NBR0E7O0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBUUEsU0FBU0csZUFBVCxDQUF5QmhKLElBQXpCLEVBQStCO0FBRTdCdkIsUUFBTSxDQUFDQyxFQUFQLENBQVV3QyxJQUFWLENBQWVDLE9BQWYsQ0FBdUIsS0FBdkI7QUFFQSxNQUFJOEgsYUFBYSxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV25KLElBQVgsQ0FBcEI7QUFDQSxNQUFNeUYsSUFBSSxHQUFHd0QsYUFBYSxDQUFDeEQsSUFBM0I7QUFDQXdELGVBQWEsR0FBR0EsYUFBYSxDQUFDakosSUFBOUI7O0FBRUEsTUFBSXlGLElBQUksS0FBSyxXQUFiLEVBQTBCO0FBQ3hCaEgsVUFBTSxDQUFDMkssU0FBUCxDQUFpQkMsVUFBakIsQ0FBNEJDLFlBQTVCLENBQXlDN0ssTUFBTSxDQUFDYSxJQUFQLENBQVk4QixXQUFyRCxFQUFrRTZILGFBQWxFO0FBQ0QsR0FGRCxNQUdLO0FBQ0h4SyxVQUFNLENBQUNhLElBQVAsQ0FBWThCLFdBQVosR0FBMEI2SCxhQUExQjtBQUNEOztBQUVEeEssUUFBTSxDQUFDYSxJQUFQLENBQVlELE9BQVosR0FBc0JpQywwRkFBMkIsQ0FBQzdDLE1BQU0sQ0FBQ2EsSUFBUCxDQUFZOEIsV0FBYixDQUFqRDtBQUNBM0MsUUFBTSxDQUFDQyxFQUFQLENBQVVrRCxTQUFWLENBQW9CaEIsR0FBcEIsQ0FBd0JXLFVBQXhCLENBQW1DOUMsTUFBTSxDQUFDYSxJQUFQLENBQVlELE9BQS9DO0FBRUFtQyxnRkFBYyxDQUFDL0MsTUFBTSxDQUFDYSxJQUFQLENBQVk4QixXQUFiLENBQWQ7QUFFRDtBQUVEOzs7Ozs7Ozs7O0FBUUEsU0FBU21JLGdCQUFULENBQTBCdkosSUFBMUIsRUFBZ0M7QUFFOUJ2QixRQUFNLENBQUNDLEVBQVAsQ0FBVXdDLElBQVYsQ0FBZUMsT0FBZixDQUF1QixLQUF2QjtBQUVBLE1BQUk4SCxhQUFhLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXbkosSUFBWCxDQUFwQjtBQUNBLE1BQU15RixJQUFJLEdBQUd3RCxhQUFhLENBQUN4RCxJQUEzQjtBQUNBd0QsZUFBYSxHQUFHQSxhQUFhLENBQUNqSixJQUE5Qjs7QUFFQSxNQUFJeUYsSUFBSSxLQUFLLFdBQWIsRUFBMEI7QUFDeEJoSCxVQUFNLENBQUMySyxTQUFQLENBQWlCQyxVQUFqQixDQUE0QkMsWUFBNUIsQ0FBeUM3SyxNQUFNLENBQUN3SCxFQUFoRCxFQUFvRGdELGFBQXBEO0FBQ0QsR0FGRCxNQUdLO0FBQ0h4SyxVQUFNLENBQUN3SCxFQUFQLHFCQUNLeEgsTUFBTSxDQUFDd0gsRUFEWixFQUVLZ0QsYUFGTDtBQUlEO0FBRUY7O0FBRUR4SyxNQUFNLENBQUNDLEVBQVAsQ0FBVUMsSUFBVixDQUFlQyxnQkFBZixHQUFrQyxJQUFJa0QsMkVBQUosRUFBbEM7QUFFQSxJQUFNMEgsTUFBTSxHQUFHQyxFQUFFLEVBQWpCO0FBQ0EsSUFBTTdILFNBQVMsR0FBR0gsNEVBQWlCLEVBQW5DO0FBQ0EsSUFBTWlJLFdBQVcsR0FBR2hGLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixVQUF2QixDQUFwQjtBQUNBLElBQU1nRixJQUFJLEdBQUcsSUFBSUMsTUFBTSxDQUFDQyxJQUFYLENBQWdCSCxXQUFoQixFQUE2QjlILFNBQTdCLENBQWI7QUFFQSxJQUFJLENBQUMrSCxJQUFMLEVBQVcsTUFBTSxJQUFJakksS0FBSixDQUFVLGdCQUFWLENBQU47QUFFWGpELE1BQU0sQ0FBQ0MsRUFBUCxDQUFVd0MsSUFBVixDQUFlQyxPQUFmLENBQXVCLEtBQXZCO0FBQ0EySSxXQUFXLENBQUNyTCxNQUFNLENBQUNDLEVBQVAsQ0FBVXdDLElBQVYsQ0FBZUMsT0FBaEIsRUFBeUIsT0FBTyxDQUFoQyxDQUFYO0FBRUFxSSxNQUFNLENBQUNPLEVBQVAsQ0FBVSxNQUFWLEVBQWtCZixlQUFsQjtBQUNBUSxNQUFNLENBQUNPLEVBQVAsQ0FBVSxPQUFWLEVBQW1CUixnQkFBbkIsRTs7Ozs7Ozs7Ozs7aWNDM0ZBLENBQUMsUUFBU1MsaUNBQVQsQ0FBMENDLElBQTFDLENBQWdEQyxPQUFoRCxDQUF5RCxDQUN6RCxHQUFHLDBCQUFPQyxPQUFQLEtBQW1CLFFBQW5CLEVBQStCLDBCQUFPQyxNQUFQLEtBQWtCLFFBQXBELENBQ0NBLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQkQsT0FBTyxFQUF4QixDQURELElBRUssSUFBRyxJQUFILENBQ0pHLGlDQUFPLEVBQUQsb0NBQUtILE9BQUw7QUFBQTtBQUFBO0FBQUEsb0dBQU4sQ0FESSxJQUVBLEdBSUwsQ0FURCxFQVNHekwsTUFUSCxDQVNXLFVBQVcsQ0FDdEIsTUFBTyxTQUFVLFNBQVM2TCxPQUFULENBQWtCLENBQUU7QUFDckMsUUFEbUMsQ0FDekI7QUFDVixRQUFVLEdBQUlDLGlCQUFnQixDQUFHLEVBQXZCLENBQ1YsUUFIbUMsQ0FJbkMsUUFKbUMsQ0FJekI7QUFDVixRQUFVLFFBQVNDLG9CQUFULENBQTZCQyxRQUE3QixDQUF1QyxDQUNqRCxRQURpRCxDQUVqRCxRQUZpRCxDQUV0QztBQUNYLFFBQVcsR0FBR0YsZ0JBQWdCLENBQUNFLFFBQUQsQ0FBbkIsQ0FBK0IsQ0FDMUMsUUFBWSxNQUFPRixpQkFBZ0IsQ0FBQ0UsUUFBRCxDQUFoQixDQUEyQk4sT0FBbEMsQ0FDWixRQUFZLENBQ1osUUFOaUQsQ0FNdEM7QUFDWCxRQUFXLEdBQUlDLE9BQU0sQ0FBR0csZ0JBQWdCLENBQUNFLFFBQUQsQ0FBaEIsQ0FBNkIsQ0FDckQsUUFBWUMsQ0FBQyxDQUFFRCxRQURzQyxDQUVyRCxRQUFZRSxDQUFDLENBQUUsS0FGc0MsQ0FHckQsUUFBWVIsT0FBTyxDQUFFLEVBQ3JCLFFBSnFELENBQTFDLENBS1gsUUFaaUQsQ0FhakQsUUFiaUQsQ0FhdEM7QUFDWCxRQUFXRyxPQUFPLENBQUNHLFFBQUQsQ0FBUCxDQUFrQkcsSUFBbEIsQ0FBdUJSLE1BQU0sQ0FBQ0QsT0FBOUIsQ0FBdUNDLE1BQXZDLENBQStDQSxNQUFNLENBQUNELE9BQXRELENBQStESyxtQkFBL0QsRUFDWCxRQWZpRCxDQWdCakQsUUFoQmlELENBZ0J0QztBQUNYLFFBQVdKLE1BQU0sQ0FBQ08sQ0FBUCxDQUFXLElBQVgsQ0FDWCxRQWxCaUQsQ0FtQmpELFFBbkJpRCxDQW1CdEM7QUFDWCxRQUFXLE1BQU9QLE9BQU0sQ0FBQ0QsT0FBZCxDQUNYLFFBQVcsQ0FDWCxRQTNCbUMsQ0E0Qm5DLFFBNUJtQyxDQTZCbkMsUUE3Qm1DLENBNkJ6QjtBQUNWLFFBQVVLLG1CQUFtQixDQUFDSyxDQUFwQixDQUF3QlAsT0FBeEIsQ0FDVixRQS9CbUMsQ0FnQ25DLFFBaENtQyxDQWdDekI7QUFDVixRQUFVRSxtQkFBbUIsQ0FBQ00sQ0FBcEIsQ0FBd0JQLGdCQUF4QixDQUNWLFFBbENtQyxDQW1DbkMsUUFuQ21DLENBbUN6QjtBQUNWLFFBQVVDLG1CQUFtQixDQUFDTyxDQUFwQixDQUF3QixTQUFTWixPQUFULENBQWtCekUsSUFBbEIsQ0FBd0JzRixNQUF4QixDQUFnQyxDQUNsRSxRQUFXLEdBQUcsQ0FBQ1IsbUJBQW1CLENBQUNTLENBQXBCLENBQXNCZCxPQUF0QixDQUErQnpFLElBQS9CLENBQUosQ0FBMEMsQ0FDckQsUUFBWXdGLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQmhCLE9BQXRCLENBQStCekUsSUFBL0IsQ0FBcUMsQ0FBRTBGLFVBQVUsQ0FBRSxJQUFkLENBQW9CQyxHQUFHLENBQUVMLE1BQXpCLENBQXJDLEVBQ1osUUFBWSxDQUNaLFFBQVcsQ0FKRCxDQUtWLFFBekNtQyxDQTBDbkMsUUExQ21DLENBMEN6QjtBQUNWLFFBQVVSLG1CQUFtQixDQUFDYyxDQUFwQixDQUF3QixTQUFTbkIsT0FBVCxDQUFrQixDQUNwRCxRQUFXLEdBQUcsTUFBT29CLE9BQVAsR0FBa0IsV0FBbEIsRUFBaUNBLE1BQU0sQ0FBQ0MsV0FBM0MsQ0FBd0QsQ0FDbkUsUUFBWU4sTUFBTSxDQUFDQyxjQUFQLENBQXNCaEIsT0FBdEIsQ0FBK0JvQixNQUFNLENBQUNDLFdBQXRDLENBQW1ELENBQUUzTixLQUFLLENBQUUsUUFBVCxDQUFuRCxFQUNaLFFBQVksQ0FDWixRQUFXcU4sTUFBTSxDQUFDQyxjQUFQLENBQXNCaEIsT0FBdEIsQ0FBK0IsWUFBL0IsQ0FBNkMsQ0FBRXRNLEtBQUssQ0FBRSxJQUFULENBQTdDLEVBQ1gsUUFBVyxDQUxELENBTVYsUUFqRG1DLENBa0RuQyxRQWxEbUMsQ0FrRHpCO0FBQ1YsUUFuRG1DLENBbUR6QjtBQUNWLFFBcERtQyxDQW9EekI7QUFDVixRQXJEbUMsQ0FxRHpCO0FBQ1YsUUF0RG1DLENBc0R6QjtBQUNWLFFBQVUyTSxtQkFBbUIsQ0FBQ2lCLENBQXBCLENBQXdCLFNBQVM1TixLQUFULENBQWdCNk4sSUFBaEIsQ0FBc0IsQ0FDeEQsUUFBVyxHQUFHQSxJQUFJLENBQUcsQ0FBVixDQUFhN04sS0FBSyxDQUFHMk0sbUJBQW1CLENBQUMzTSxLQUFELENBQTNCLENBQ3hCLFFBQVcsR0FBRzZOLElBQUksQ0FBRyxDQUFWLENBQWEsTUFBTzdOLE1BQVAsQ0FDeEIsUUFBVyxHQUFJNk4sSUFBSSxDQUFHLENBQVIsRUFBYyxRQUFPN04sS0FBUCxJQUFpQixRQUEvQixFQUEyQ0EsS0FBM0MsRUFBb0RBLEtBQUssQ0FBQzhOLFVBQTdELENBQXlFLE1BQU85TixNQUFQLENBQ3BGLFFBQVcsR0FBSStOLEdBQUUsQ0FBR1YsTUFBTSxDQUFDVyxNQUFQLENBQWMsSUFBZCxDQUFULENBQ1gsUUFBV3JCLG1CQUFtQixDQUFDYyxDQUFwQixDQUFzQk0sRUFBdEIsRUFDWCxRQUFXVixNQUFNLENBQUNDLGNBQVAsQ0FBc0JTLEVBQXRCLENBQTBCLFNBQTFCLENBQXFDLENBQUVSLFVBQVUsQ0FBRSxJQUFkLENBQW9Cdk4sS0FBSyxDQUFFQSxLQUEzQixDQUFyQyxFQUNYLFFBQVcsR0FBRzZOLElBQUksQ0FBRyxDQUFQLEVBQVksTUFBTzdOLE1BQVAsRUFBZ0IsUUFBL0IsQ0FBeUMsSUFBSSxHQUFJaU8sSUFBUixHQUFlak8sTUFBZixFQUFzQjJNLG1CQUFtQixDQUFDTyxDQUFwQixDQUFzQmEsRUFBdEIsQ0FBMEJFLEdBQTFCLENBQStCLFNBQVNBLEdBQVQsQ0FBYyxDQUFFLE1BQU9qTyxNQUFLLENBQUNpTyxHQUFELENBQVosQ0FBb0IsQ0FBcEMsQ0FBcUNDLElBQXJDLENBQTBDLElBQTFDLENBQWdERCxHQUFoRCxDQUEvQixFQUF0QixDQUNwRCxRQUFXLE1BQU9GLEdBQVAsQ0FDWCxRQUFXLENBVEQsQ0FVVixRQWpFbUMsQ0FrRW5DLFFBbEVtQyxDQWtFekI7QUFDVixRQUFVcEIsbUJBQW1CLENBQUN3QixDQUFwQixDQUF3QixTQUFTNUIsTUFBVCxDQUFpQixDQUNuRCxRQUFXLEdBQUlZLE9BQU0sQ0FBR1osTUFBTSxFQUFJQSxNQUFNLENBQUN1QixVQUFqQixDQUN4QixRQUFZLFFBQVNNLFdBQVQsRUFBc0IsQ0FBRSxNQUFPN0IsT0FBTSxDQUFDLFNBQUQsQ0FBYixDQUEyQixDQUR2QyxDQUV4QixRQUFZLFFBQVM4QixpQkFBVCxFQUE0QixDQUFFLE1BQU85QixPQUFQLENBQWdCLENBRi9DLENBR1gsUUFBV0ksbUJBQW1CLENBQUNPLENBQXBCLENBQXNCQyxNQUF0QixDQUE4QixHQUE5QixDQUFtQ0EsTUFBbkMsRUFDWCxRQUFXLE1BQU9BLE9BQVAsQ0FDWCxRQUFXLENBTkQsQ0FPVixRQTFFbUMsQ0EyRW5DLFFBM0VtQyxDQTJFekI7QUFDVixRQUFVUixtQkFBbUIsQ0FBQ1MsQ0FBcEIsQ0FBd0IsU0FBU2tCLE1BQVQsQ0FBaUJDLFFBQWpCLENBQTJCLENBQUUsTUFBT2xCLE9BQU0sQ0FBQ21CLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDMUIsSUFBaEMsQ0FBcUN1QixNQUFyQyxDQUE2Q0MsUUFBN0MsQ0FBUCxDQUFnRSxDQUFySCxDQUNWLFFBN0VtQyxDQThFbkMsUUE5RW1DLENBOEV6QjtBQUNWLFFBQVU1QixtQkFBbUIsQ0FBQytCLENBQXBCLENBQXdCLEVBQXhCLENBQ1YsUUFoRm1DLENBaUZuQyxRQWpGbUMsQ0FrRm5DLFFBbEZtQyxDQWtGekI7QUFDVixRQUFVLE1BQU8vQixvQkFBbUIsQ0FBQ0EsbUJBQW1CLENBQUNnQyxDQUFwQixDQUF3Qix1QkFBekIsQ0FBMUIsQ0FDVixRQUFVLENBcEZNLENBcUZoQiwwRUFyRmdCLENBc0ZoQixRQUFVLENBRVYsS0FBTSxpR0FDTjs7dUNBRE0sQ0FJTiw4QkFKTSxDQUtOLEtBQU8sMkVBQVNwQyxNQUFULENBQWlCRCxPQUFqQixDQUEwQixDQUVqQ3NDLElBQUksQ0FBQyx5akJBQUQsQ0FBSixDQUVBLEtBQU8sQ0FYRyxDQWFWLEtBQU0saUdBQ047O3VDQURNLENBSU4sOEJBSk0sQ0FLTixLQUFPLDJFQUFTckMsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEIsQ0FFakNzQyxJQUFJLENBQUMsOG5CQUFELENBQUosQ0FFQSxLQUFPLENBdEJHLENBd0JWLEtBQU0sOENBQ047O3VEQURNLENBSU4sOEJBSk0sQ0FLTixLQUFPLDhDQUFTckMsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJLLG1CQUExQixDQUErQyxDQUV0RGlDLElBQUksQ0FBQyxvK1ZBQUQsQ0FBSixDQUVBLEtBQU8sQ0FqQ0csQ0FtQ1YsS0FBTSxrQ0FDTjs7MkNBRE0sQ0FJTiw4QkFKTSxDQUtOLEtBQU8sb0NBQVNyQyxNQUFULENBQWlCRCxPQUFqQixDQUEwQkssbUJBQTFCLENBQStDLENBRXREaUMsSUFBSSxDQUFDLHltaWlCQUFELENBQUosQ0FFQSxLQUFPLENBNUNHLENBOENWLEtBQU0sd0JBQ047O2lDQURNLENBSU4sbUNBSk0sQ0FLTixLQUFPLDBCQUFTckMsTUFBVCxDQUFpQnNDLG1CQUFqQixDQUFzQ2xDLG1CQUF0QyxDQUEyRCxDQUVsRSxhQUNBaUMsSUFBSSxDQUFDLHN2QkFBRCxDQUFKLENBRUEsS0FBTyxDQUVQLFFBMURVLENBdEZNLENBQWhCLEVBaUpDLENBM0pELEU7Ozs7Ozs7Ozs7Ozs7O0FDQUEsQ0FBQyxTQUFTekMsZ0NBQVQsQ0FBMENDLElBQTFDLEVBQWdEQyxPQUFoRCxFQUF5RDtBQUN6RCxNQUFHLDhCQUFPQyxPQUFQLE9BQW1CLFFBQW5CLElBQStCLDhCQUFPQyxNQUFQLE9BQWtCLFFBQXBELEVBQ0NBLE1BQU0sQ0FBQ0QsT0FBUCxHQUFpQkQsT0FBTyxFQUF4QixDQURELEtBRUssSUFBRyxJQUFILEVBQ0pHLGlDQUFPLEVBQUQsb0NBQUtILE9BQUw7QUFBQTtBQUFBO0FBQUEsb0dBQU4sQ0FESSxLQUVBLEVBR0o7QUFDRCxDQVRELEVBU0d6TCxNQVRILEVBU1csWUFBVztBQUN0QjtBQUFPO0FBQVUsY0FBUzZMLE9BQVQsRUFBa0I7QUFBRTs7QUFDckM7QUFBVTs7QUFDVjtBQUFVLFVBQUlDLGdCQUFnQixHQUFHLEVBQXZCO0FBQ1Y7O0FBQ0E7QUFBVTs7QUFDVjs7QUFBVSxlQUFTQyxtQkFBVCxDQUE2QkMsUUFBN0IsRUFBdUM7QUFDakQ7O0FBQ0E7QUFBVzs7QUFDWDtBQUFXLFlBQUdGLGdCQUFnQixDQUFDRSxRQUFELENBQW5CLEVBQStCO0FBQzFDO0FBQVksaUJBQU9GLGdCQUFnQixDQUFDRSxRQUFELENBQWhCLENBQTJCTixPQUFsQztBQUNaO0FBQVk7QUFDWjtBQUFXOztBQUNYOzs7QUFBVyxZQUFJQyxNQUFNLEdBQUdHLGdCQUFnQixDQUFDRSxRQUFELENBQWhCLEdBQTZCO0FBQ3JEO0FBQVlDLFdBQUMsRUFBRUQsUUFEc0M7O0FBRXJEO0FBQVlFLFdBQUMsRUFBRSxLQUZzQzs7QUFHckQ7QUFBWVIsaUJBQU8sRUFBRTtBQUNyQjs7QUFKcUQsU0FBMUM7QUFLWDs7QUFDQTtBQUFXOztBQUNYOztBQUFXRyxlQUFPLENBQUNHLFFBQUQsQ0FBUCxDQUFrQkcsSUFBbEIsQ0FBdUJSLE1BQU0sQ0FBQ0QsT0FBOUIsRUFBdUNDLE1BQXZDLEVBQStDQSxNQUFNLENBQUNELE9BQXRELEVBQStESyxtQkFBL0Q7QUFDWDs7QUFDQTtBQUFXOztBQUNYOztBQUFXSixjQUFNLENBQUNPLENBQVAsR0FBVyxJQUFYO0FBQ1g7O0FBQ0E7QUFBVzs7QUFDWDs7QUFBVyxlQUFPUCxNQUFNLENBQUNELE9BQWQ7QUFDWDtBQUFXO0FBQ1g7O0FBQ0E7O0FBQ0E7QUFBVTs7QUFDVjs7O0FBQVVLLHlCQUFtQixDQUFDSyxDQUFwQixHQUF3QlAsT0FBeEI7QUFDVjs7QUFDQTtBQUFVOztBQUNWOztBQUFVRSx5QkFBbUIsQ0FBQ00sQ0FBcEIsR0FBd0JQLGdCQUF4QjtBQUNWOztBQUNBO0FBQVU7O0FBQ1Y7O0FBQVVDLHlCQUFtQixDQUFDTyxDQUFwQixHQUF3QixVQUFTWixPQUFULEVBQWtCekUsSUFBbEIsRUFBd0JzRixNQUF4QixFQUFnQztBQUNsRTtBQUFXLFlBQUcsQ0FBQ1IsbUJBQW1CLENBQUNTLENBQXBCLENBQXNCZCxPQUF0QixFQUErQnpFLElBQS9CLENBQUosRUFBMEM7QUFDckQ7QUFBWXdGLGdCQUFNLENBQUNDLGNBQVAsQ0FBc0JoQixPQUF0QixFQUErQnpFLElBQS9CLEVBQXFDO0FBQUUwRixzQkFBVSxFQUFFLElBQWQ7QUFBb0JDLGVBQUcsRUFBRUw7QUFBekIsV0FBckM7QUFDWjtBQUFZO0FBQ1o7O0FBQVcsT0FKRDtBQUtWOztBQUNBO0FBQVU7O0FBQ1Y7OztBQUFVUix5QkFBbUIsQ0FBQ2MsQ0FBcEIsR0FBd0IsVUFBU25CLE9BQVQsRUFBa0I7QUFDcEQ7QUFBVyxZQUFHLE9BQU9vQixNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNDLFdBQTNDLEVBQXdEO0FBQ25FO0FBQVlOLGdCQUFNLENBQUNDLGNBQVAsQ0FBc0JoQixPQUF0QixFQUErQm9CLE1BQU0sQ0FBQ0MsV0FBdEMsRUFBbUQ7QUFBRTNOLGlCQUFLLEVBQUU7QUFBVCxXQUFuRDtBQUNaO0FBQVk7QUFDWjs7O0FBQVdxTixjQUFNLENBQUNDLGNBQVAsQ0FBc0JoQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFdE0sZUFBSyxFQUFFO0FBQVQsU0FBN0M7QUFDWDtBQUFXLE9BTEQ7QUFNVjs7QUFDQTtBQUFVOztBQUNWO0FBQVU7O0FBQ1Y7QUFBVTs7QUFDVjtBQUFVOztBQUNWO0FBQVU7O0FBQ1Y7OztBQUFVMk0seUJBQW1CLENBQUNpQixDQUFwQixHQUF3QixVQUFTNU4sS0FBVCxFQUFnQjZOLElBQWhCLEVBQXNCO0FBQ3hEO0FBQVcsWUFBR0EsSUFBSSxHQUFHLENBQVYsRUFBYTdOLEtBQUssR0FBRzJNLG1CQUFtQixDQUFDM00sS0FBRCxDQUEzQjtBQUN4Qjs7QUFBVyxZQUFHNk4sSUFBSSxHQUFHLENBQVYsRUFBYSxPQUFPN04sS0FBUDtBQUN4Qjs7QUFBVyxZQUFJNk4sSUFBSSxHQUFHLENBQVIsSUFBYyxRQUFPN04sS0FBUCxNQUFpQixRQUEvQixJQUEyQ0EsS0FBM0MsSUFBb0RBLEtBQUssQ0FBQzhOLFVBQTdELEVBQXlFLE9BQU85TixLQUFQO0FBQ3BGOztBQUFXLFlBQUkrTixFQUFFLEdBQUdWLE1BQU0sQ0FBQ1csTUFBUCxDQUFjLElBQWQsQ0FBVDtBQUNYOztBQUFXckIsMkJBQW1CLENBQUNjLENBQXBCLENBQXNCTSxFQUF0QjtBQUNYOzs7QUFBV1YsY0FBTSxDQUFDQyxjQUFQLENBQXNCUyxFQUF0QixFQUEwQixTQUExQixFQUFxQztBQUFFUixvQkFBVSxFQUFFLElBQWQ7QUFBb0J2TixlQUFLLEVBQUVBO0FBQTNCLFNBQXJDO0FBQ1g7O0FBQVcsWUFBRzZOLElBQUksR0FBRyxDQUFQLElBQVksT0FBTzdOLEtBQVAsSUFBZ0IsUUFBL0IsRUFBeUMsS0FBSSxJQUFJaU8sR0FBUixJQUFlak8sS0FBZjtBQUFzQjJNLDZCQUFtQixDQUFDTyxDQUFwQixDQUFzQmEsRUFBdEIsRUFBMEJFLEdBQTFCLEVBQStCLFVBQVNBLEdBQVQsRUFBYztBQUFFLG1CQUFPak8sS0FBSyxDQUFDaU8sR0FBRCxDQUFaO0FBQW9CLFdBQXBDLENBQXFDQyxJQUFyQyxDQUEwQyxJQUExQyxFQUFnREQsR0FBaEQsQ0FBL0I7QUFBdEI7QUFDcEQ7O0FBQVcsZUFBT0YsRUFBUDtBQUNYO0FBQVcsT0FURDtBQVVWOztBQUNBO0FBQVU7O0FBQ1Y7OztBQUFVcEIseUJBQW1CLENBQUN3QixDQUFwQixHQUF3QixVQUFTNUIsTUFBVCxFQUFpQjtBQUNuRDtBQUFXLFlBQUlZLE1BQU0sR0FBR1osTUFBTSxJQUFJQSxNQUFNLENBQUN1QixVQUFqQjtBQUN4QjtBQUFZLGlCQUFTTSxVQUFULEdBQXNCO0FBQUUsaUJBQU83QixNQUFNLENBQUMsU0FBRCxDQUFiO0FBQTJCLFNBRHZDO0FBRXhCO0FBQVksaUJBQVM4QixnQkFBVCxHQUE0QjtBQUFFLGlCQUFPOUIsTUFBUDtBQUFnQixTQUYvQztBQUdYOztBQUFXSSwyQkFBbUIsQ0FBQ08sQ0FBcEIsQ0FBc0JDLE1BQXRCLEVBQThCLEdBQTlCLEVBQW1DQSxNQUFuQztBQUNYOzs7QUFBVyxlQUFPQSxNQUFQO0FBQ1g7QUFBVyxPQU5EO0FBT1Y7O0FBQ0E7QUFBVTs7QUFDVjs7O0FBQVVSLHlCQUFtQixDQUFDUyxDQUFwQixHQUF3QixVQUFTa0IsTUFBVCxFQUFpQkMsUUFBakIsRUFBMkI7QUFBRSxlQUFPbEIsTUFBTSxDQUFDbUIsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0MxQixJQUFoQyxDQUFxQ3VCLE1BQXJDLEVBQTZDQyxRQUE3QyxDQUFQO0FBQWdFLE9BQXJIO0FBQ1Y7O0FBQ0E7QUFBVTs7QUFDVjs7O0FBQVU1Qix5QkFBbUIsQ0FBQytCLENBQXBCLEdBQXdCLEVBQXhCO0FBQ1Y7O0FBQ0E7O0FBQ0E7QUFBVTs7QUFDVjs7QUFBVSxhQUFPL0IsbUJBQW1CLENBQUNBLG1CQUFtQixDQUFDZ0MsQ0FBcEIsR0FBd0IsNkJBQXpCLENBQTFCO0FBQ1Y7QUFBVSxLQXBGTTtBQXFGaEI7O0FBQ0E7QUFBVTtBQUVWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sc0NBQVNwQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLHN0V0FBRCxDQUFKO0FBRUE7QUFBTyxPQVhHOztBQWFWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8saUNBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLDBxQ0FBRCxDQUFKO0FBRUE7QUFBTyxPQXRCRzs7QUF3QlY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxtQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsd3lFQUFELENBQUo7QUFFQTtBQUFPLE9BakNHOztBQW1DVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLHNDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyw2ekNBQUQsQ0FBSjtBQUVBO0FBQU8sT0E1Q0c7O0FBOENWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sa0NBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLHVxRUFBRCxDQUFKO0FBRUE7QUFBTyxPQXZERzs7QUF5RFY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyx3Q0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsdWtDQUFELENBQUo7QUFFQTtBQUFPLE9BbEVHOztBQW9FVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLDBDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxxckNBQUQsQ0FBSjtBQUVBO0FBQU8sT0E3RUc7O0FBK0VWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8scUNBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLG80SUFBRCxDQUFKO0FBRUE7QUFBTyxPQXhGRzs7QUEwRlY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxnQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsMjBIQUFELENBQUo7QUFFQTtBQUFPLE9BbkdHOztBQXFHVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLHVDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxzeERBQUQsQ0FBSjtBQUVBO0FBQU8sT0E5R0c7O0FBZ0hWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sMkNBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLHFoRUFBRCxDQUFKO0FBRUE7QUFBTyxPQXpIRzs7QUEySFY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxtQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMscW1EQUFELENBQUo7QUFFQTtBQUFPLE9BcElHOztBQXNJVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLGlDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxxOENBQUQsQ0FBSjtBQUVBO0FBQU8sT0EvSUc7O0FBaUpWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sb0NBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLGczQ0FBRCxDQUFKO0FBRUE7QUFBTyxPQTFKRzs7QUE0SlY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxvQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsNm9DQUFELENBQUo7QUFFQTtBQUFPLE9BcktHOztBQXVLVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLDRCQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxxOEJBQUQsQ0FBSjtBQUVBO0FBQU8sT0FoTEc7O0FBa0xWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sOEJBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLDY4QkFBRCxDQUFKO0FBRUE7QUFBTyxPQTNMRzs7QUE2TFY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyw2QkFBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsdzNDQUFELENBQUo7QUFFQTtBQUFPLE9BdE1HOztBQXdNVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLHNDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyw2dERBQUQsQ0FBSjtBQUVBO0FBQU8sT0FqTkc7O0FBbU5WO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sb0NBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLG85Q0FBRCxDQUFKO0FBRUE7QUFBTyxPQTVORzs7QUE4TlY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxnQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsaWpEQUFELENBQUo7QUFFQTtBQUFPLE9Bdk9HOztBQXlPVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLDRDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyw0ckNBQUQsQ0FBSjtBQUVBO0FBQU8sT0FsUEc7O0FBb1BWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sd0NBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLDZ6Q0FBRCxDQUFKO0FBRUE7QUFBTyxPQTdQRzs7QUErUFY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxtQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMseWlDQUFELENBQUo7QUFFQTtBQUFPLE9BeFFHOztBQTBRVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLGtDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxrMERBQUQsQ0FBSjtBQUVBO0FBQU8sT0FuUkc7O0FBcVJWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sdUNBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLHFtRUFBRCxDQUFKO0FBRUE7QUFBTyxPQTlSRzs7QUFnU1Y7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxvQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsMDVDQUFELENBQUo7QUFFQTtBQUFPLE9BelNHOztBQTJTVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLGdEQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxzL0JBQUQsQ0FBSjtBQUVBO0FBQU8sT0FwVEc7O0FBc1RWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sNEJBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLHN5Q0FBRCxDQUFKO0FBRUE7QUFBTyxPQS9URzs7QUFpVVY7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxvQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsazFDQUFELENBQUo7QUFFQTtBQUFPLE9BMVVHOztBQTRVVjtBQUFNO0FBQ047Ozs7QUFHQTs7QUFDQTtBQUFPLHNDQUFTckMsTUFBVCxFQUFpQkQsT0FBakIsRUFBMEJLLG1CQUExQixFQUErQztBQUV0RGlDLFlBQUksQ0FBQyxzdkdBQUQsQ0FBSjtBQUVBO0FBQU8sT0FyVkc7O0FBdVZWO0FBQU07QUFDTjs7OztBQUdBOztBQUNBO0FBQU8sb0NBQVNyQyxNQUFULEVBQWlCRCxPQUFqQixFQUEwQkssbUJBQTFCLEVBQStDO0FBRXREaUMsWUFBSSxDQUFDLDg4RkFBRCxDQUFKO0FBRUE7QUFBTyxPQWhXRzs7QUFrV1Y7QUFBTTtBQUNOOzs7O0FBR0E7O0FBQ0E7QUFBTyxtQ0FBU3JDLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCSyxtQkFBMUIsRUFBK0M7QUFFdERpQyxZQUFJLENBQUMsMnlGQUFELENBQUo7QUFFQTtBQUFPO0FBRVA7O0FBN1dVLEtBdEZNO0FBQWhCO0FBb2NDLENBOWNELEU7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtDQUVBOzs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtDQUdBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1lLFNBQVMxRSxvQkFBVCxDQUE4QjFKLE1BQTlCLEVBQXNDO0FBRW5ELFdBQVNzTyxpQkFBVCxHQUE2QjtBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsUUFBTUMsT0FBTyxHQUFLdk8sTUFBTSxDQUFDMkIsSUFBUCxDQUFZLG9DQUFaLEtBQXFELEVBQXZFO0FBQ0EsUUFBTTZNLFNBQVMsR0FBR3hPLE1BQU0sQ0FBQzJCLElBQVAsQ0FBWSxtQ0FBWixLQUFvRCxFQUF0RTtBQUNBLFFBQU04TSxTQUFTLEdBQUdqSCxxRkFBRyxDQUFDcEgsTUFBTSxDQUFDd0gsRUFBUixFQUFZLFdBQVosQ0FBckIsQ0F6QjJCLENBMkIzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFNOEcsWUFBWSxHQUFHLEVBQXJCO0FBQ0E7QUFDRSxVQUFJek0sR0FBSjs7QUFDQSxVQUFJME0sR0FBSjtBQUNBLFVBQUl2SCxJQUFKO0FBQ0EsVUFBSXdILE9BQUo7QUFDQSxVQUFJNUUsUUFBSjs7QUFDQSx5Q0FBb0I2QyxNQUFNLENBQUNnQyxPQUFQLENBQWU7QUFBQ0MsWUFBSSxFQUFFUCxPQUFQO0FBQWdCUSxjQUFNLEVBQUVQO0FBQXhCLE9BQWYsQ0FBcEIscUNBQXdFO0FBQUE7O0FBQWxFcEgsWUFBa0U7QUFBNUR1SCxXQUE0RDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUN0RSwrQkFBV0EsR0FBWCw4SEFBZ0I7QUFBWDFNLGVBQVc7QUFDZCtILG9CQUFRLEdBQUd5RSxTQUFTLENBQUN4TSxHQUFELENBQXBCO0FBQ0EsZ0JBQUksQ0FBQytILFFBQUwsRUFBZTtBQUNmNEUsbUJBQU8sR0FBRzVFLFFBQVEsQ0FBQ2dGLE9BQW5COztBQUNBLGdCQUFJLENBQUNOLFlBQVksQ0FBQ0UsT0FBRCxDQUFqQixFQUE0QjtBQUMxQkYsMEJBQVksQ0FBQ0UsT0FBRCxDQUFaLEdBQXdCO0FBQ3RCRSxvQkFBSSxFQUFFLEVBRGdCO0FBRXRCQyxzQkFBTSxFQUFFO0FBRmMsZUFBeEI7QUFJRDs7QUFDREwsd0JBQVksQ0FBQ0UsT0FBRCxDQUFaLENBQXNCeEgsSUFBdEIsRUFBNEIvRSxJQUE1QixDQUFpQztBQUMvQjtBQUNBNE0saUJBQUcseUNBQWtDakYsUUFBUSxDQUFDa0YsR0FBM0MsQ0FGNEI7QUFHL0I3SCxrQkFBSSxFQUFFMkMsUUFBUSxDQUFDbUYsSUFIZ0I7QUFJL0JDLHFCQUFPLEVBQUVwRixRQUFRLENBQUNxRixPQUphO0FBSy9CQyxpQkFBRyxFQUFFdEYsUUFBUSxDQUFDdUYsa0JBQVQsS0FBZ0MsZUFMTjtBQU0vQjFGLG9DQUFzQixFQUFFRyxRQUFRLENBQUN3Rix1QkFORjtBQU8vQkMsc0NBQXdCLEVBQUV6RixRQUFRLENBQUMwRjtBQVBKLGFBQWpDO0FBU0Q7QUFwQnFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxQnZFO0FBQ0YsS0FsRTBCLENBb0UzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFFBQU1DLFdBQVcsR0FBRyxFQUFwQjtBQUNBO0FBQ0UsVUFBSWYsUUFBSjs7QUFDQSxVQUFJZ0IsVUFBSjs7QUFDQSwyQ0FBOEIvQyxNQUFNLENBQUNnQyxPQUFQLENBQWVILFlBQWYsQ0FBOUIsd0NBQTREO0FBQUE7O0FBQXRERSxlQUFzRDtBQUE3Q2dCLGtCQUE2QztBQUMxREQsbUJBQVcsQ0FBQ3ROLElBQVo7QUFBa0J1TSxpQkFBTyxFQUFQQTtBQUFsQixXQUE4QmdCLFVBQTlCO0FBQ0Q7QUFDRjtBQUVELFdBQU9ELFdBQVA7QUFFRDs7QUFFRCxXQUFTRSxtQkFBVCxHQUErQjtBQUU3QixRQUFNeEksSUFBSSxHQUFZRyxxRkFBRyxDQUFDeEgsTUFBRCxFQUFTLHVDQUFULENBQXpCO0FBQ0EsUUFBTThQLEtBQUssR0FBV0MsK0VBQWlCLENBQUN2SSxxRkFBRyxDQUFDeEgsTUFBRCxFQUFTLGFBQVQsQ0FBSixDQUF2QztBQUNBLFFBQU1nUSxPQUFPLEdBQVMsc0JBQXRCO0FBQ0EsUUFBTUMsT0FBTyxHQUFTalEsTUFBTSxDQUFDMkIsSUFBUCxDQUFZLDRCQUFaLEtBQTZDLEVBQW5FO0FBQ0EsUUFBTTRNLE9BQU8sR0FBU3ZPLE1BQU0sQ0FBQzJCLElBQVAsQ0FBWSxvQ0FBWixLQUFxRCxFQUEzRTtBQUNBLFFBQU02TSxTQUFTLEdBQU94TyxNQUFNLENBQUMyQixJQUFQLENBQVksbUNBQVosS0FBb0QsRUFBMUU7QUFDQSxRQUFNZ08sV0FBVyxHQUFLckIsaUJBQWlCLEVBQXZDO0FBQ0EsUUFBTTNFLGFBQWEsR0FBR25DLHFGQUFHLENBQUN4SCxNQUFELEVBQVMsb0NBQVQsQ0FBekI7QUFFQSxRQUFNbUMsTUFBTSxHQUFHO0FBQ2IrTixZQUFNLEVBQUU7QUFDTjdJLFlBQUksRUFBSkEsSUFETTtBQUVOeUksYUFBSyxFQUFMQSxLQUZNO0FBR05FLGVBQU8sRUFBUEEsT0FITTtBQUlOckcscUJBQWEsRUFBYkEsYUFKTTtBQUtOd0csbUJBQVcsRUFBRUYsT0FBTyxDQUFDdEksTUFMZjtBQU1OeUksb0JBQVksRUFBRTdCLE9BQU8sQ0FBQzVHLE1BTmhCO0FBT04wSSxzQkFBYyxFQUFFN0IsU0FBUyxDQUFDN0c7QUFQcEIsT0FESztBQVViMkksVUFBSSxFQUFFWDtBQVZPLEtBQWY7QUFhQSxRQUFNWSxXQUFXLEdBQUdySyx1RUFBTyxDQUFDLGdCQUFELENBQVAsQ0FBMEIvRCxNQUExQixDQUFwQjtBQUNBLFdBQU9vTyxXQUFQO0FBRUQ7O0FBRUQsTUFBTTdMLEtBQUssR0FBRzFFLE1BQU0sQ0FBQ3VGLEtBQVAsQ0FBYWlMLE1BQWIsQ0FBb0IvSyxPQUFwQixDQUE0QixVQUE1QixDQUFkO0FBQ0EsTUFBTXhELEVBQUUsc0JBQWU0RCwwRUFBWSxFQUEzQixDQUFSO0FBQ0EsTUFBTTRLLEtBQUssY0FBT3hPLEVBQVAsQ0FBWDtBQUNBLE1BQU15TyxhQUFhLEdBQUd4Syx1RUFBTyxDQUFDLDRCQUFELENBQVAsQ0FBc0M7QUFBQ2pFLE1BQUUsRUFBRkE7QUFBRCxHQUF0QyxDQUF0QjtBQUNBLE1BQU0wTyxlQUFlLEdBQUdkLG1CQUFtQixFQUEzQztBQUVBZSwrRUFBZSxDQUFDbE0sS0FBRCxFQUFRLGdCQUFSLENBQWY7QUFDQUUsNERBQU0sQ0FBQ0YsS0FBRCxFQUFRZ00sYUFBUixDQUFOO0FBQ0FySyxVQUFRLENBQUNDLGFBQVQsQ0FBdUJtSyxLQUF2QixFQUE4Qi9GLFNBQTlCLEdBQTBDaUcsZUFBMUM7QUFFRCxDOzs7Ozs7Ozs7Ozs7QUMxSkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Q0FFQTs7QUFDQTtBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBLFNBQVNFLGlCQUFULENBQTJCcEMsU0FBM0IsRUFBc0M7QUFDcEMsTUFBTXFDLFNBQVMsR0FBR3RKLHFGQUFHLENBQUNJLEVBQUQsRUFBSyxxQkFBTCxDQUFyQixDQURvQyxDQUVwQzs7QUFDQSxNQUFNbUosU0FBUyxHQUFHLENBQ2hCLFVBRGdCLEVBRWhCLFNBRmdCLEVBR2hCLFVBSGdCLEVBSWhCLFVBSmdCLEVBS2hCLFVBTGdCLEVBTWhCLFVBTmdCLEVBT2hCLFFBUGdCLEVBUWhCLFNBUmdCLEVBU2hCLFNBVGdCLEVBVWhCLFFBVmdCLEVBV2hCLFNBWGdCLEVBWWhCLFFBWmdCLEVBYWhCLFFBYmdCLEVBY2hCLE9BZGdCLEVBZWhCLFFBZmdCLEVBZ0JoQixXQWhCZ0IsRUFpQmhCLGdCQWpCZ0IsRUFrQmhCLE9BbEJnQixFQW1CaEIsUUFuQmdCLEVBb0JoQixPQXBCZ0IsRUFxQmhCLFVBckJnQixDQUFsQjtBQXdCQSxNQUFNQyxHQUFHLEdBQUduRSxNQUFNLENBQUNnQyxPQUFQLENBQWVpQyxTQUFmLEVBQTBCRyxNQUExQixDQUFpQyxVQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBYztBQUN6REQsT0FBRyxDQUFDQyxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU9DLFdBQVAsRUFBRCxDQUFILEdBQTRCRCxHQUFHLENBQUMsQ0FBRCxDQUEvQjtBQUNBLFdBQU9ELEdBQVA7QUFDRCxHQUhXLEVBR1QsRUFIUyxDQUFaO0FBSUEsTUFBTUcsWUFBWSxHQUFHTixTQUFTLENBQUNDLEdBQVYsQ0FBYyxVQUFBTSxDQUFDO0FBQUEsV0FBSU4sR0FBRyxDQUFDTSxDQUFELENBQVA7QUFBQSxHQUFmLENBQXJCO0FBRUEsU0FBT0QsWUFBUDtBQUNEOztBQUFBO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFNBQVNFLG9CQUFULENBQThCdlIsTUFBOUIsRUFBd0Q7QUFBQSxNQUFsQndSLFFBQWtCLHVFQUFQLEtBQU87QUFFdEQsTUFBTVIsR0FBRyxHQUFHeEoscUZBQUcsQ0FBQ0ksRUFBRCxFQUFLLHFCQUFMLENBQWY7QUFDQSxNQUFNNkosVUFBVSxHQUFHaksscUZBQUcsQ0FBQ3hILE1BQUQsRUFBUywrQkFBVCxDQUF0QixDQUhzRCxDQUt0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUl5UixVQUFVLElBQUlELFFBQWxCLEVBQTRCO0FBQzFCLFFBQU1FLElBQUksR0FBR0QsVUFBVSxDQUFDTCxXQUFYLEtBQTJCSSxRQUFRLENBQUNKLFdBQVQsRUFBeEM7QUFDQSxRQUFNTyxNQUFNLGFBQU1ELElBQU4sQ0FBWjtBQUNBLFdBQU9DLE1BQVA7QUFDRCxHQUpELE1BS0s7QUFDSC9RLFdBQU8sQ0FBQ2dSLElBQVIsQ0FBYSxxQ0FBYjtBQUNEO0FBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFZQSxTQUFTQyxlQUFULENBQXlCN1IsTUFBekIsRUFBaUM4UixZQUFqQyxFQUFpRTtBQUFBLE1BQWxCTixRQUFrQix1RUFBUCxLQUFPO0FBQy9ELE1BQU1HLE1BQU0sR0FBR0osb0JBQW9CLENBQUN2UixNQUFELEVBQVN3UixRQUFULENBQW5DOztBQUNBLE1BQUlHLE1BQUosRUFBWTtBQUNWLFFBQUlJLFdBQVcsQ0FBQ0MsTUFBaEIsQ0FBdUI7QUFDckJMLFlBQU0sRUFBTkEsTUFEcUI7QUFFckJHLGtCQUFZLEVBQVpBLFlBRnFCO0FBR3JCRyxjQUFRLEVBQUUsSUFIVztBQUlyQkMsY0FBUSxFQUFFLEdBSlc7QUFLckJDLGNBQVEsRUFBRSxTQUxXO0FBTXJCdE8sV0FBSyxFQUFFLE9BTmM7QUFPckJ1TyxXQUFLLEVBQUUsR0FQYztBQVFyQkMsWUFBTSxFQUFFLElBUmE7QUFTckJDLGdCQUFVLEVBQUUsd0JBVFM7QUFVckJDLHVCQUFpQixFQUFFLEtBVkU7QUFXckJDLHlCQUFtQixFQUFFLElBWEE7QUFZckJDLGdCQUFVLEVBQUUsS0FaUztBQWFyQkMsYUFBTyxFQUFFLENBQ1AsdUJBRE87QUFiWSxLQUF2QjtBQWlCRCxHQWxCRCxNQW1CSztBQUNIOVIsV0FBTyxDQUFDZ1IsSUFBUixDQUFhLDZEQUFiO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7Ozs7QUFPZSxTQUFTbEwsc0JBQVQsQ0FBZ0M4SyxRQUFoQyxFQUEwQ3hSLE1BQTFDLEVBQWtEO0FBRS9ELE1BQU1pQyxFQUFFLHNCQUFlNEQsMEVBQVksRUFBM0IsQ0FBUjtBQUNBLE1BQU00SyxLQUFLLGNBQU94TyxFQUFQLENBQVg7QUFDQSxNQUFNMEMsT0FBTyxHQUFHdUIsdUVBQU8sQ0FBQyw0QkFBRCxDQUFQLENBQXNDO0FBQUNqRSxNQUFFLEVBQUZBO0FBQUQsR0FBdEMsQ0FBaEI7QUFDQSxNQUFNeUMsS0FBSyxHQUFHMUUsTUFBTSxDQUFDdUYsS0FBUCxDQUFhaUwsTUFBYixDQUFvQi9LLE9BQXBCLENBQTRCLFVBQTVCLENBQWQ7QUFDQWIsNERBQU0sQ0FBQ0YsS0FBRCxFQUFRQyxPQUFSLENBQU47QUFDQWdPLCtFQUFlLENBQUNsQyxLQUFELEVBQVEsR0FBUixFQUFhakssZ0ZBQWtCLENBQUNxTCxlQUFELEVBQWtCN1IsTUFBbEIsRUFBMEJpQyxFQUExQixFQUE4QnVQLFFBQTlCLENBQS9CLENBQWY7QUFFRCxDOzs7Ozs7Ozs7Ozs7QUN2SkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtDQUVBOztBQUNBO0FBQ0E7QUFDQTtDQUdBOztBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWNlLFNBQVN6SixvQkFBVCxDQUE4QjlHLElBQTlCLEVBQW9DakIsTUFBcEMsRUFBNEM7QUFFekQsTUFBSTRTLE1BQU0sR0FBR2hMLEVBQUUsQ0FBQ0MsY0FBaEI7QUFDQSxNQUFJLENBQUM3SCxNQUFNLENBQUNSLEtBQVosRUFBbUIsT0FBT29ULE1BQVA7QUFIc0MsTUFLakQxUyxNQUxpRCxHQUtoQ0YsTUFMZ0MsQ0FLakRFLE1BTGlEO0FBQUEsTUFLekN5QixJQUx5QyxHQUtoQzNCLE1BTGdDLENBS3pDMkIsSUFMeUM7QUFNekQsTUFBTWtSLElBQUksR0FBR3hNLFFBQVEsQ0FBQ3lNLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBYjtBQUVBLE1BQU1DLFFBQVEsR0FBR3ZMLHFGQUFHLENBQUN4SCxNQUFELEVBQVMsYUFBVCxDQUFwQjtBQUNBLE1BQU1nVCxRQUFRLEdBQUd4TCxxRkFBRyxDQUFDeEgsTUFBRCxpQkFBaUJBLE1BQU0sQ0FBQ0UsTUFBUCxDQUFjRCxLQUEvQixXQUFwQixDQVR5RCxDQVd6RDs7QUFDQSxNQUFJZ1QsTUFBSjtBQUNBLE1BQUlDLE1BQUo7QUFDQSxNQUFNQyxNQUFNLEdBQUdKLFFBQVEsSUFBSSxDQUFaLEdBQWdCLENBQWhCLEdBQW9CLENBQW5DO0FBQ0EsTUFBSUssc0VBQVEsQ0FBQ0wsUUFBRCxDQUFaLEVBQXdCRSxNQUFNLEdBQUdJLG9GQUFzQixDQUFDTixRQUFELEVBQVcvUyxNQUFNLENBQUNpSSxRQUFsQixDQUEvQjtBQUN4QixNQUFJbUwsc0VBQVEsQ0FBQ0osUUFBRCxDQUFaLEVBQXdCRSxNQUFNLEdBQUdHLG9GQUFzQixDQUFDTCxRQUFELEVBQVdoVCxNQUFNLENBQUNpSSxRQUFsQixDQUEvQjs7QUFFeEIsTUFBSW1MLHNFQUFRLENBQUNMLFFBQUQsQ0FBUixJQUFzQixDQUFDSyxzRUFBUSxDQUFDSixRQUFELENBQW5DLEVBQStDO0FBQzdDSixVQUFNLEdBQUdLLE1BQVQ7QUFDRCxHQUZELE1BR0s7QUFBQSw4QkFFa0JLLGdGQUFrQixDQUFDSixNQUFELEVBQVNELE1BQVQsQ0FGcEM7QUFBQSxRQUVHTSxLQUZILHVCQUVHQSxLQUZIO0FBQUEsUUFFVUMsR0FGVix1QkFFVUEsR0FGVjs7QUFHSCxRQUFNQyxRQUFRLEdBQUdDLDJFQUFXLENBQUNSLE1BQUQsRUFBU0QsTUFBVCxDQUE1QjtBQUNBTCxVQUFNLG1CQUFZVyxLQUFaLGtDQUF3Q0UsUUFBeEMsZ0JBQXFERCxHQUFyRCxZQUFOO0FBRUQ7O0FBRURYLE1BQUksQ0FBQ25JLFNBQUwsR0FBaUJrSSxNQUFqQjtBQUVBLFNBQU9DLElBQVA7QUFFRCxDOzs7Ozs7Ozs7Ozs7QUMxREQ7QUFBQTtBQUFBO0FBQUE7Q0FFQTs7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFlLFNBQVNwSixxQkFBVCxDQUErQnpKLE1BQS9CLEVBQXVDO0FBRXBELE1BQU04UCxLQUFLLEdBQUdDLCtFQUFpQixDQUFDdkkscUZBQUcsQ0FBQ3hILE1BQUQsRUFBUyxhQUFULENBQUosQ0FBL0I7QUFDQSxNQUFNMlQsUUFBUSxHQUFHdE4sUUFBUSxDQUFDeU0sYUFBVCxDQUF1QixNQUF2QixDQUFqQjtBQUNBYSxVQUFRLENBQUNDLFlBQVQsQ0FBc0IsT0FBdEI7QUFDQUQsVUFBUSxDQUFDakosU0FBVCxHQUFxQm9GLEtBQXJCO0FBQ0EsU0FBTzZELFFBQVA7QUFFRCxDOzs7Ozs7Ozs7Ozs7QUN0QkQ7QUFBQTtBQUFBO0FBQUE7QUFBYTs7QUFFYjtBQUVBOzs7Ozs7QUFLZSxTQUFTck0sZ0JBQVQsQ0FBMEJ0SCxNQUExQixFQUFrQztBQUUvQyxNQUFNNlQsUUFBUSxHQUFHck0scUZBQUcsQ0FBQ3hILE1BQUQsRUFBUyx1Q0FBVCxDQUFwQjtBQUNBLE1BQU04VCxNQUFNLDBDQUFtQ0QsUUFBbkMsQ0FBWjtBQUVBLE1BQU1sQyxNQUFNLEdBQUduSyxxRkFBRyxDQUFDeEgsTUFBRCxFQUFTLCtCQUFULENBQWxCO0FBQ0EsTUFBTStULEdBQUcsR0FBR0QsTUFBTSx3QkFBZ0JBLE1BQWhCLGdDQUFnRCxFQUFsRTtBQUVBLE1BQU0zUixNQUFNLHNEQUVONFIsR0FGTSw2QkFHRS9ULE1BQU0sQ0FBQ1IsS0FIVCw4QkFHa0NtUyxNQUhsQyw2QkFBWjtBQU9BLFNBQU94UCxNQUFQO0FBRUQ7QUFBQSxDOzs7Ozs7Ozs7Ozs7QUMxQkQ7QUFBQTtBQUFBO0FBQUE7QUFBYTs7QUFFYjtBQUNBO0FBRUE7Ozs7O0FBSWUsU0FBUzhHLGtCQUFULENBQTRCakosTUFBNUIsRUFBb0M7QUFDakQsTUFBTWdVLE1BQU0sR0FBR3hNLHFGQUFHLENBQUN4SCxNQUFELEVBQVMsYUFBVCxDQUFsQjtBQUNBLFNBQU8rUCwrRUFBaUIsQ0FBQ2lFLE1BQUQsQ0FBakIsSUFBNkIsR0FBcEM7QUFDRDtBQUFBLEM7Ozs7Ozs7Ozs7OztBQ1pEO0FBQUE7QUFBYTtBQUViOzs7Ozs7Ozs7QUFRZSxTQUFTQyx1QkFBVCxDQUFpQ2pVLE1BQWpDLEVBQXlDLENBRXZELEM7Ozs7Ozs7Ozs7OztBQ1pEO0FBQUE7QUFBQTtBQUFBO0FBQWE7O0FBRWI7QUFFQTs7Ozs7Ozs7O0FBUWUsU0FBU3ZCLFdBQVQsQ0FBcUJ1QixNQUFyQixFQUE2QjtBQUFBLE1BQ2xDMkIsSUFEa0MsR0FDakIzQixNQURpQixDQUNsQzJCLElBRGtDO0FBQUEsTUFDNUJ6QixNQUQ0QixHQUNqQkYsTUFEaUIsQ0FDNUJFLE1BRDRCO0FBRTFDLE1BQU1ELEtBQUssR0FBRzBCLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQ0QsS0FBUixDQUFsQjtBQUNBLE1BQU1vSyxTQUFTLEdBQUdwSyxLQUFLLElBQUlBLEtBQUssQ0FBQ29LLFNBQWpDO0FBQ0EsTUFBTStDLENBQUMsR0FBRzNDLHFFQUFPLENBQUNKLFNBQUQsQ0FBUCxJQUFzQixrQkFBaEM7QUFDQSxnQ0FBdUIrQyxDQUF2QjtBQUNELEM7Ozs7Ozs7Ozs7OztBQ2xCRDtBQUFBO0FBQUE7QUFBQTtBQUFhOzs7Ozs7OztBQUViO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7Ozs7QUFRQSxTQUFTekUsS0FBVCxDQUFldUwsR0FBZixFQUFvQnhMLEtBQXBCLEVBQTJCO0FBRXpCLE1BQU15TCxTQUFTLEdBQUdELEdBQUcsQ0FBQ2pELE1BQUosQ0FBVyxVQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBYztBQUN6Q0QsT0FBRyxDQUFDN08sSUFBSixDQUFTO0FBQ1A5QyxPQUFDLEVBQUU0UixHQUFHLENBQUM5RyxTQURBO0FBQ1crSixPQUFDLEVBQUVqRCxHQUFHLENBQUN4STtBQURsQixLQUFUO0FBR0EsV0FBT3VJLEdBQVA7QUFDRCxHQUxpQixFQUtmLEVBTGUsQ0FBbEI7QUFPQSxTQUFPbUQseUVBQVcsQ0FBQztBQUNqQjNMLFNBQUssRUFBTEEsS0FEaUI7QUFFakIvRyxRQUFJLEVBQUV3UyxTQUZXO0FBR2pCck8sU0FBSyxFQUFFLEdBSFU7QUFJakJFLFVBQU0sRUFBRSxFQUpTO0FBS2pCc08sVUFBTSxFQUFFO0FBTFMsR0FBRCxDQUFsQjtBQVFEO0FBRUQ7Ozs7Ozs7Ozs7O0FBU0EsU0FBUzFMLE1BQVQsQ0FBZ0JzTCxHQUFoQixFQUFxQnhMLEtBQXJCLEVBQTRDO0FBQUEsTUFBaEJHLFVBQWdCLHVFQUFILENBQUc7QUFFMUMsTUFBTTBMLFVBQVUsR0FBRyxFQUFuQjtBQUNBLE1BQU01UyxJQUFJLEdBQUd1UyxHQUFHLENBQUNqRCxNQUFKLENBQVcsVUFBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQWM7QUFDcENELE9BQUcsQ0FBQzdPLElBQUosQ0FBUztBQUNQOUMsT0FBQyxFQUFFNFIsR0FBRyxDQUFDOUcsU0FEQTtBQUNXK0osT0FBQyxFQUFFakQsR0FBRyxDQUFDdkk7QUFEbEIsS0FBVDtBQUdBLFdBQU9zSSxHQUFQO0FBQ0QsR0FMWSxFQUtWLEVBTFUsQ0FBYjtBQU9BLE1BQU1zRCxPQUFPLEdBQUczTCxVQUFoQjtBQUNBLE1BQU00TCxLQUFLLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTRCxJQUFJLENBQUNFLEtBQUwsQ0FBV2pULElBQUksQ0FBQ2dHLE1BQUwsR0FBYzZNLE9BQXpCLENBQVQsRUFBNEMsQ0FBNUMsQ0FBZDs7QUFDQSxPQUFLLElBQUluSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMUssSUFBSSxDQUFDZ0csTUFBekIsRUFBaUMwRSxDQUFDLEdBQUdBLENBQUMsR0FBR29JLEtBQXpDLEVBQWdEO0FBRTlDLFFBQU1JLEVBQUUsR0FBR2xULElBQUksQ0FBQzBLLENBQUQsQ0FBZjtBQUNBLFFBQU15SSxFQUFFLEdBQUduVCxJQUFJLENBQUMwSyxDQUFDLEdBQUcsQ0FBTCxDQUFmO0FBQ0EsUUFBTTBJLEVBQUUsR0FBR3BULElBQUksQ0FBQzBLLENBQUMsR0FBRyxDQUFMLENBQWY7QUFDQSxRQUFNMkksRUFBRSxHQUFHSCxFQUFFLENBQUNULENBQWQ7QUFDQSxRQUFNYSxFQUFFLEdBQUdILEVBQUUsR0FBR0EsRUFBRSxDQUFDVixDQUFOLEdBQVVZLEVBQXZCO0FBQ0EsUUFBTUUsRUFBRSxHQUFHSCxFQUFFLEdBQUdBLEVBQUUsQ0FBQ1gsQ0FBTixHQUFVYSxFQUF2QixDQVA4QyxDQVM5Qzs7QUFDQVYsY0FBVSxDQUFDbFMsSUFBWCxDQUFnQjtBQUNkOUMsT0FBQyxFQUFFdVYsRUFBRSxHQUFHQSxFQUFFLENBQUN2VixDQUFOLEdBQVVzVixFQUFFLENBQUN0VixDQURKO0FBRWQ2VSxPQUFDLEVBQUVlLDBFQUFZLENBQUMsQ0FBQ0gsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLEVBQVQsQ0FBRDtBQUZELEtBQWhCO0FBS0Q7O0FBRUQsU0FBT0UsOEVBQWdCLENBQUM7QUFDdEIxTSxTQUFLLEVBQUxBLEtBRHNCO0FBRXRCL0csUUFBSSxFQUFFNFMsVUFGZ0I7QUFHdEJ6TyxTQUFLLEVBQUUsR0FIZTtBQUl0QkUsVUFBTSxFQUFFLEVBSmM7QUFLdEJxUCxRQUFJLEVBQUUsU0FMZ0I7QUFNdEJmLFVBQU0sRUFBRTtBQU5jLEdBQUQsQ0FBdkI7QUFTRDtBQUVEOzs7Ozs7O0lBS3FCZ0IscUI7Ozs7Ozs7OztBQUVuQjt5QkFDS3RWLE0sRUFBUTtBQUVYLFVBQUksQ0FBQ0EsTUFBTSxDQUFDUixLQUFaLEVBQW1CO0FBRW5CLFVBQUkrVixFQUFFLEdBQUcxSyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDMkssU0FBTCxDQUFleFYsTUFBTSxDQUFDUixLQUF0QixDQUFYLENBQVQ7QUFFQSxVQUFJUSxNQUFNLENBQUMySSxLQUFYLEVBQW1CLEtBQUtBLEtBQUwsR0FBY0EsS0FBSyxDQUFDNE0sRUFBRCxFQUFLLENBQUMsQ0FBQ3ZWLE1BQU0sQ0FBQzBJLEtBQWQsQ0FBbkI7QUFDbkIsVUFBSTFJLE1BQU0sQ0FBQzRJLE1BQVgsRUFBbUIsS0FBS0EsTUFBTCxHQUFjQSxNQUFNLENBQUMyTSxFQUFELEVBQUssQ0FBQyxDQUFDdlYsTUFBTSxDQUFDMEksS0FBZCxFQUFxQjFJLE1BQU0sQ0FBQzZJLFVBQTVCLENBQXBCO0FBRXBCLEssQ0FFRDs7Ozs2QkFDUztBQUVQLFVBQU00TSxHQUFHLEdBQUdwUCxRQUFRLENBQUN5TSxhQUFULENBQXVCLEtBQXZCLENBQVo7O0FBRUEsVUFBSSxLQUFLbEssTUFBVCxFQUFpQjtBQUNmNk0sV0FBRyxDQUFDQyxXQUFKLENBQWdCLEtBQUs5TSxNQUFMLENBQVkrTSxJQUFaLEVBQWhCO0FBQ0Q7O0FBQ0QsVUFBSSxLQUFLaE4sS0FBVCxFQUFnQjtBQUNkOE0sV0FBRyxDQUFDQyxXQUFKLENBQWdCLEtBQUsvTSxLQUFMLENBQVdnTixJQUFYLEVBQWhCO0FBQ0Q7O0FBRUQsV0FBS0MsSUFBTCxHQUFZSCxHQUFaO0FBQ0EsYUFBTyxLQUFLRyxJQUFaO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JISDtBQUFBO0FBQUE7QUFBQTtBQUFBO0NBRUE7Ozs7Ozs7O0NBR0E7O0FBQ0E7QUFFQTs7Ozs7O0lBS3FCaFcsb0I7Ozs7Ozs7OztBQUVuQjt5QkFDS0ksTSxFQUFRO0FBRVgsV0FBSzRWLElBQUwsR0FBWXZQLFFBQVEsQ0FBQ3lNLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBLFdBQUsrQyxpQkFBTCxDQUF1QjdWLE1BQXZCO0FBRUQsSyxDQUVEOzs7OzZCQUNTO0FBQ1AsYUFBTyxLQUFLNFYsSUFBWjtBQUNELEssQ0FFRDs7Ozs0QkFDUTVWLE0sRUFBUTtBQUNkLFdBQUs2VixpQkFBTCxDQUF1QjdWLE1BQXZCO0FBQ0Q7OztzQ0FFaUJBLE0sRUFBUTtBQUV4QixVQUFNUixLQUFLLEdBQUdRLE1BQU0sQ0FBQzhWLGNBQVAsR0FDVjlWLE1BQU0sQ0FBQzhWLGNBREcsR0FFVnRPLHFGQUFHLENBQUN4SCxNQUFELEVBQVMsYUFBVCxDQUZQO0FBSUEsVUFBTTJCLElBQUksaURBQVY7QUFFQSxXQUFLaVUsSUFBTCxDQUFVbEwsU0FBVixHQUFzQi9JLElBQXRCLENBUndCLENBVXhCOztBQUNBLFdBQUtvVSxNQUFMLEdBQWMsS0FBS0gsSUFBTCxDQUFVdFAsYUFBVixDQUF3QixzQkFBeEIsQ0FBZCxDQVh3QixDQWF4Qjs7QUFDQSxXQUFLeVAsTUFBTCxDQUFZckwsU0FBWixHQUF3QmxMLEtBQXhCO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pESDtBQUFBO0FBQWE7QUFFYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXZSxTQUFTeUQsMkJBQVQsQ0FBcUN0QixJQUFyQyxFQUEyQztBQUV4REEsTUFBSSxHQUFHa0osSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQzJLLFNBQUwsQ0FBZTdULElBQWYsQ0FBWCxDQUFQOztBQUVBLE1BQUlBLElBQUksQ0FBQ3FVLElBQVQsRUFBZTtBQUViO0FBQ0E7QUFDQTtBQUNBLFFBQUkvVCxFQUFKLEVBQVFnVSxJQUFSO0FBQ0EsUUFBSXhJLEdBQUosRUFBUzBELEdBQVQ7QUFDQSxRQUFJK0UsTUFBSjtBQUNBLFFBQUlDLE9BQU8sR0FBRyxFQUFkO0FBQ0EsUUFBTUgsSUFBSSxHQUFHclUsSUFBSSxDQUFDcVUsSUFBbEI7QUFDQSxXQUFPclUsSUFBSSxDQUFDcVUsSUFBWjs7QUFDQSx1Q0FBbUJuSixNQUFNLENBQUNnQyxPQUFQLENBQWVsTixJQUFmLENBQW5CLHFDQUF5QztBQUFBOztBQUFuQ00sUUFBbUM7QUFBL0JnVSxVQUErQjtBQUN2Q0MsWUFBTSxHQUFHLEVBQVQ7O0FBQ0EsMkNBQW1CckosTUFBTSxDQUFDZ0MsT0FBUCxDQUFlb0gsSUFBZixDQUFuQix3Q0FBeUM7QUFBQTs7QUFBbkN4SSxXQUFtQztBQUE5QjBELFdBQThCO0FBQ3ZDK0UsY0FBTSxDQUFDRixJQUFJLENBQUN2SSxHQUFELENBQUwsQ0FBTixHQUFvQjBELEdBQXBCO0FBQ0Q7O0FBQ0RnRixhQUFPLENBQUNsVSxFQUFELENBQVAsR0FBY2lVLE1BQWQ7QUFDRDs7QUFDRHZVLFFBQUksR0FBR3dVLE9BQVA7QUFFRCxHQXhCdUQsQ0EyQnhEO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHLEVBQWxCOztBQUNBLHVDQUFzQnZKLE1BQU0sQ0FBQ2dDLE9BQVAsQ0FBZWxOLElBQWYsQ0FBdEIsd0NBQTRDO0FBQUE7QUFBQSxRQUFsQ00sR0FBa0M7QUFBQSxRQUE5Qm9VLEdBQThCOztBQUMxQ0EsT0FBRyxDQUFDcFUsRUFBSixHQUFTb1UsR0FBRyxDQUFDQyxFQUFiO0FBQ0FGLGFBQVMsQ0FBQy9ULElBQVYsQ0FBZWdVLEdBQWY7QUFDRDs7QUFDRDFVLE1BQUksR0FBR3lVLFNBQVAsQ0FuQ3dELENBcUN4RDtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUcsS0FBSyxHQUFHLGNBQWQ7QUFDQSxNQUFJQyxLQUFKO0FBQ0EsTUFBSWhYLEtBQUo7QUFDQSxNQUFJaVgsUUFBSjtBQUNBLE1BQUlwTSxTQUFKO0FBQ0EsTUFBSXFDLENBQUosRUFBT2dLLENBQVAsRUFBVUMsQ0FBVjtBQTdDd0Q7QUFBQTtBQUFBOztBQUFBO0FBOEN4RCx5QkFBVWhWLElBQVYsOEhBQWdCO0FBQVgrSyxPQUFXOztBQUNkLDJDQUFlRyxNQUFNLENBQUNnQyxPQUFQLENBQWVuQyxDQUFmLENBQWYsd0NBQWtDO0FBQUE7O0FBQTVCZ0ssU0FBNEI7QUFBekJDLFNBQXlCO0FBQ2hDSCxhQUFLLEdBQUdFLENBQUMsQ0FBQ0YsS0FBRixDQUFRRCxLQUFSLENBQVI7O0FBQ0EsWUFBSUMsS0FBSyxJQUFJQSxLQUFLLENBQUM3TyxNQUFuQixFQUEyQjtBQUN6QjhPLGtCQUFRLEdBQUdDLENBQUMsQ0FBQ0UsT0FBRixDQUFVTCxLQUFWLEVBQWlCLEVBQWpCLENBQVg7QUFDQS9XLGVBQUssR0FBR2tOLENBQUMsQ0FBQytKLFFBQUQsQ0FBVDtBQUNBcE0sbUJBQVMsR0FBR3FDLENBQUMsQ0FBQ2dLLENBQUQsQ0FBYjtBQUNBaEssV0FBQyxDQUFDK0osUUFBRCxDQUFELEdBQWM7QUFDWnBNLHFCQUFTLEVBQVRBLFNBRFk7QUFFWjdLLGlCQUFLLEVBQUxBO0FBRlksV0FBZDtBQUlBLGlCQUFPa04sQ0FBQyxDQUFDZ0ssQ0FBRCxDQUFSO0FBQ0Q7QUFDRjtBQUNGO0FBNUR1RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQThEeEQsU0FBTy9VLElBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUM1RUQ7QUFBYTs7QUFFYixTQUFTa1Ysb0JBQVQsR0FBZ0MsQ0FBRTs7QUFFbENBLG9CQUFvQixDQUFDN0ksU0FBckIsQ0FBK0I4SSxJQUEvQixHQUFzQyxVQUFVOVcsTUFBVixFQUFrQjtBQUNwRCxPQUFLK1csdUJBQUwsR0FBK0IvVyxNQUFNLENBQUMrVyx1QkFBdEM7QUFDQSxPQUFLbkIsSUFBTCxHQUFZdlAsUUFBUSxDQUFDeU0sYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsT0FBSzhDLElBQUwsQ0FBVWxMLFNBQVYsR0FBc0Isc0JBQXRCO0FBQ0EsT0FBS3NNLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxPQUFLQyxZQUFMLEdBQW9CLEtBQUtyQixJQUFMLENBQVV0UCxhQUFWLENBQXdCLE9BQXhCLENBQXBCO0FBQ0EsTUFBSTRRLElBQUksR0FBRyxJQUFYOztBQUNBLFdBQVNDLGlCQUFULEdBQTRCO0FBQ3hCLFFBQUlELElBQUksQ0FBQ0QsWUFBTCxDQUFrQnpYLEtBQWxCLEtBQTRCLEVBQWhDLEVBQW9DO0FBQ2hDO0FBQ0EwWCxVQUFJLENBQUNILHVCQUFMLENBQTZCLElBQTdCO0FBQ0E7QUFDSDs7QUFFREcsUUFBSSxDQUFDRixZQUFMLEdBQW9CRSxJQUFJLENBQUNELFlBQUwsQ0FBa0J6WCxLQUF0QztBQUNBMFgsUUFBSSxDQUFDSCx1QkFBTCxDQUE2QkcsSUFBSSxDQUFDRixZQUFsQztBQUNIOztBQUNELE9BQUtDLFlBQUwsQ0FBa0IxUSxnQkFBbEIsQ0FBbUMsT0FBbkMsRUFBNEM0USxpQkFBNUM7QUFDSCxDQWxCRDs7QUFvQkFOLG9CQUFvQixDQUFDN0ksU0FBckIsQ0FBK0JvSixvQkFBL0IsR0FBc0QsVUFBVUMsV0FBVixFQUF1QjtBQUN6RTtBQUNBLE1BQUksQ0FBQ0EsV0FBTCxFQUFrQjtBQUNkLFNBQUtKLFlBQUwsQ0FBa0J6WCxLQUFsQixHQUEwQixFQUExQjtBQUNILEdBRkQsTUFFTztBQUNILFNBQUt5WCxZQUFMLENBQWtCelgsS0FBbEIsR0FBMEI2WCxXQUFXLEdBQUcsRUFBeEM7QUFDSDs7QUFDRCxPQUFLTCxZQUFMLEdBQW9CSyxXQUFwQjtBQUNILENBUkQ7O0FBVUFSLG9CQUFvQixDQUFDN0ksU0FBckIsQ0FBK0JzSixNQUEvQixHQUF3QyxZQUFZO0FBQ2hELFNBQU8sS0FBSzFCLElBQVo7QUFDSCxDQUZEOztBQUllaUIsbUZBQWYsRTs7Ozs7Ozs7Ozs7O0FDdENBO0FBQWE7O0FBRWIsU0FBU1UsWUFBVCxHQUF3QixDQUFFOztBQUUxQkEsWUFBWSxDQUFDdkosU0FBYixDQUF1QjhJLElBQXZCLEdBQThCLFVBQVU5VyxNQUFWLEVBQWtCO0FBQzVDLE9BQUs2RyxXQUFMLEdBQW1CN0csTUFBTSxDQUFDNkcsV0FBMUI7QUFDQSxPQUFLMlEsVUFBTCxHQUFrQixJQUFsQjtBQUNBLE9BQUt4WCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLeVgsUUFBTDtBQUNILENBTEQsQyxDQU9BOzs7QUFDQUYsWUFBWSxDQUFDdkosU0FBYixDQUF1QnlKLFFBQXZCLEdBQWtDLFlBQVk7QUFDMUMsT0FBS0MsR0FBTCxHQUFXclIsUUFBUSxDQUFDeU0sYUFBVCxDQUF1QixLQUF2QixDQUFYO0FBQ0EsT0FBSzRFLEdBQUwsQ0FBU2hOLFNBQVQsR0FDSSw0Q0FDQSxzREFEQSxHQUVBLGlJQUZBLEdBR0EsUUFKSjtBQU1BLE1BQUl3TSxJQUFJLEdBQUcsSUFBWDs7QUFDQSxPQUFLUyxlQUFMLEdBQXVCLFlBQVc7QUFDOUJULFFBQUksQ0FBQ1UsaUJBQUw7QUFDQVYsUUFBSSxDQUFDbFgsTUFBTCxDQUFZNlgscUJBQVo7QUFDSCxHQUhEOztBQUtBLE9BQUtDLFdBQUwsR0FBbUIsS0FBS0osR0FBTCxDQUFTcFIsYUFBVCxDQUF1QixhQUF2QixDQUFuQjtBQUNBLE9BQUt3UixXQUFMLENBQWlCdlIsZ0JBQWpCLENBQWtDLE9BQWxDLEVBQTJDLEtBQUtvUixlQUFoRDtBQUNILENBaEJEOztBQWtCQUosWUFBWSxDQUFDdkosU0FBYixDQUF1QjRKLGlCQUF2QixHQUEyQyxZQUFZO0FBQ25ELE9BQUtKLFVBQUwsR0FBa0IsS0FBS00sV0FBTCxDQUFpQnRZLEtBQW5DO0FBQ0gsQ0FGRDs7QUFJQStYLFlBQVksQ0FBQ3ZKLFNBQWIsQ0FBdUJzSixNQUF2QixHQUFnQyxZQUFZO0FBQ3hDLFNBQU8sS0FBS0ksR0FBWjtBQUNILENBRkQsQyxDQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQUgsWUFBWSxDQUFDdkosU0FBYixDQUF1QitKLGNBQXZCLEdBQXdDLFVBQVUvWCxNQUFWLEVBQWtCO0FBQ3hELE1BQU02RyxXQUFXLEdBQUcsS0FBS0EsV0FBekI7QUFDQSxNQUFNckgsS0FBSyxHQUFHcUgsV0FBVyxDQUFDN0csTUFBRCxDQUFYLENBQW9CUixLQUFsQztBQUVBLE1BQU13WSxLQUFLLEdBQUcsS0FBS1IsVUFBTCxDQUFnQlosT0FBaEIsQ0FBd0IsS0FBeEIsRUFBOEIsRUFBOUIsQ0FBZDtBQUNBLE1BQU1xQixLQUFLLEdBQUdELEtBQUssQ0FBQ3hCLEtBQU4sQ0FBWSx5QkFBWixDQUFkO0FBQ0EsTUFBTTBCLFNBQVMsR0FBRyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixHQUF2QixFQUE0QixHQUE1QixFQUFpQyxHQUFqQyxFQUFzQyxHQUF0QyxDQUFsQjtBQUNBLE1BQU1DLEtBQUssR0FBR0YsS0FBSyxDQUFDdFosTUFBTixDQUFheVosS0FBYixDQUFkO0FBQ0EsTUFBTUMsV0FBVyxHQUFHRixLQUFLLENBQUNHLElBQU4sQ0FBVyxVQUFBQyxJQUFJLEVBQUk7QUFDckMsV0FBT0wsU0FBUyxDQUFDTSxRQUFWLENBQW1CRCxJQUFuQixDQUFQO0FBQ0QsR0FGbUIsQ0FBcEI7QUFJQSxNQUFNRSxjQUFjLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLElBQVgsRUFBaUIsSUFBakIsQ0FBdkI7QUFDQSxNQUFNQyxHQUFHLEdBQUcsRUFBWjs7QUFDQSxNQUFNQyxrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQXFCLENBQUFELEdBQUcsRUFBSTtBQUNoQyxXQUFPVCxLQUFLLENBQUNoSCxNQUFOLENBQWEsVUFBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQVd5SCxHQUFYLEVBQW1CO0FBQ3JDLFVBQUlILGNBQWMsQ0FBQ0QsUUFBZixDQUF3QnJILEdBQXhCLENBQUosRUFBa0NELEdBQUcsQ0FBQzdPLElBQUosQ0FBU3FXLEdBQVQ7QUFDbEN4SCxTQUFHLENBQUM3TyxJQUFKLENBQVMrVixLQUFLLENBQUNqSCxHQUFELENBQUwsR0FBYUEsR0FBYixHQUFtQjBILE1BQU0sQ0FBQzFILEdBQUQsQ0FBbEM7QUFDQSxhQUFPRCxHQUFQO0FBQ0QsS0FKTSxFQUlKLEVBSkksRUFJQTRILElBSkEsQ0FJSyxFQUpMLENBQVA7QUFLRCxHQU5EOztBQVFBLE1BQU1DLGFBQWEsR0FBR0osa0JBQWtCLENBQUNuWixLQUFELENBQXhDO0FBRUEsTUFBSXdaLE1BQUo7O0FBQ0EsTUFBSTtBQUNGQSxVQUFNLEdBQUksSUFBSUMsUUFBSixrQkFBdUJGLGFBQXZCLEVBQUQsRUFBVDtBQUNELEdBRkQsQ0FHQSxPQUFPRyxLQUFQLEVBQWM7QUFDWkYsVUFBTSxHQUFHLENBQVQ7QUFDRDs7QUFFRCxTQUFPQSxNQUFQO0FBQ0QsQ0FqQ0Q7O0FBbUNBekIsWUFBWSxDQUFDdkosU0FBYixDQUF1Qm1MLGNBQXZCLEdBQXdDLFlBQVk7QUFDaEQsU0FBUSxLQUFLM0IsVUFBTCxLQUFvQixJQUFwQixJQUNKLEtBQUtBLFVBQUwsS0FBb0I0QixTQURoQixJQUVKLEtBQUs1QixVQUFMLEtBQW9CLEVBRnhCO0FBR0gsQ0FKRDs7QUFNQUQsWUFBWSxDQUFDdkosU0FBYixDQUF1QnFMLFFBQXZCLEdBQWtDLFlBQVk7QUFDMUMsU0FBTyxLQUFLRixjQUFMLEtBQXdCLEtBQUtyQixXQUFMLENBQWlCdFksS0FBekMsR0FBaUQsSUFBeEQ7QUFDSCxDQUZEOztBQUlBK1gsWUFBWSxDQUFDdkosU0FBYixDQUF1QnNMLFFBQXZCLEdBQWtDLFVBQVVDLEtBQVYsRUFBaUI7QUFDL0MsT0FBS3pCLFdBQUwsQ0FBaUJ0WSxLQUFqQixHQUF5QitaLEtBQXpCO0FBQ0EsT0FBSzNCLGlCQUFMO0FBQ0gsQ0FIRDs7QUFNQUwsWUFBWSxDQUFDdkosU0FBYixDQUF1QjlJLE9BQXZCLEdBQWlDLFlBQVk7QUFDekMsT0FBSzRTLFdBQUwsQ0FBaUIxUyxtQkFBakIsQ0FBcUMsT0FBckMsRUFBOEMsS0FBS3VTLGVBQW5EO0FBQ0gsQ0FGRDs7QUFJZUosMkVBQWYsRTs7Ozs7Ozs7Ozs7O0FDakdBO0FBQUE7QUFBYTtBQUViOzs7Ozs7Ozs7O0FBU2UsU0FBU2lDLG1CQUFULENBQTZCdEcsTUFBN0IsRUFBcUNELE1BQXJDLEVBQTZDO0FBQzFELE1BQU1RLFFBQVEsR0FBR1IsTUFBTSxHQUFHQyxNQUFULEdBQ2IsZ0RBRGEsR0FFYkQsTUFBTSxHQUFHQyxNQUFULEdBQ0UsaURBREYsR0FFRSx3QkFKTjtBQUtBLFNBQU9PLFFBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUNsQkQ7QUFBQTtBQUFhO0FBRWI7Ozs7Ozs7Ozs7Ozs7OztBQWNlLFNBQVM3TyxNQUFULENBQWdCNlUsT0FBaEIsRUFBeUI5VSxPQUF6QixFQUFxRDtBQUFBLE1BQW5CZixZQUFtQix1RUFBSixFQUFJO0FBQ2xFLE1BQU04VixRQUFRLEdBQUdyVCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsVUFBdkIsQ0FBakI7QUFDQSxNQUFNcVQsbUJBQW1CLEdBQUc7QUFDMUJDLGlCQUFhLEVBQUU7QUFDYkMsZUFBUyxFQUFFO0FBQ1RDLHVCQUFlLEVBQUU7QUFDZkMsNkJBQW1CLEVBQUU7QUFETixTQURSO0FBSVRDLFlBQUksRUFBRTtBQUNKQyxpQkFBTyxFQUFFO0FBREw7QUFKRztBQURFLEtBRFc7QUFXMUJ0VixXQUFPLEVBQVBBLE9BWDBCO0FBWTFCK1UsWUFBUSxFQUFSQSxRQVowQjtBQWExQlEsUUFBSSxFQUFFLEtBYm9CO0FBYzFCQyxTQUFLLEVBQUUsS0FkbUI7QUFlMUJ0VyxTQUFLLEVBQUUsT0FmbUI7QUFnQjFCdVcsV0FBTyxFQUFFLE9BaEJpQjtBQWlCMUJDLFlBQVEsRUFBRSxJQWpCZ0I7QUFrQjFCQyxhQUFTLEVBQUUsSUFsQmU7QUFtQjFCeFcsYUFBUyxFQUFFLGNBbkJlO0FBb0IxQnlXLGNBQVUsRUFBRSxJQXBCYztBQXFCMUJ4VyxlQUFXLEVBQUUsUUFyQmE7QUFzQjFCeVcsZUFBVyxFQUFFLElBdEJhO0FBdUIxQnhXLHFCQUFpQixFQUFFLENBdkJPO0FBd0IxQkMsdUJBQW1CLEVBQUU7QUF4QkssR0FBNUI7QUEwQkFFLE9BQUssQ0FBQ3NWLE9BQUQsRUFBVTVNLE1BQU0sQ0FBQzROLE1BQVAsQ0FBY2QsbUJBQWQsRUFBbUMvVixZQUFuQyxDQUFWLENBQUw7QUFDQSxTQUFPNlYsT0FBUDtBQUNELEM7Ozs7Ozs7Ozs7OztBQzlDRDtBQUFBO0FBQUE7QUFBQTtBQUFhOztBQUViO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBYWUsU0FBU2xiLGdCQUFULENBQTBCeVUsUUFBMUIsRUFBb0NELFFBQXBDLEVBQThDO0FBQzNELE1BQUk7QUFDRixXQUFRdkwscUZBQUcsQ0FBQ3dMLFFBQUQsRUFBVyxPQUFYLENBQUgsS0FBMkJ4TCxxRkFBRyxDQUFDdUwsUUFBRCxFQUFXLE9BQVgsQ0FBL0IsSUFDRHZMLHFGQUFHLENBQUN3TCxRQUFELEVBQVcsV0FBWCxDQUFILEtBQStCeEwscUZBQUcsQ0FBQ3VMLFFBQUQsRUFBVyxXQUFYLENBRHhDO0FBRUQsR0FIRCxDQUlBLE9BQU1tRyxLQUFOLEVBQWE7QUFDWDtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7O0FDekJEO0FBQUE7QUFBYTtBQUViOzs7Ozs7Ozs7Ozs7QUFXZSxTQUFTL1osV0FBVCxDQUFxQnViLEVBQXJCLEVBQXlCQyxFQUF6QixFQUE2QjtBQUMxQyxTQUFPLENBQUVELEVBQUUsSUFBSUEsRUFBRSxDQUFDbGIsS0FBVixJQUFvQixDQUFDb2IsUUFBdEIsS0FBb0NELEVBQUUsSUFBSUEsRUFBRSxDQUFDbmIsS0FBVixJQUFvQixDQUFDb2IsUUFBeEQsQ0FBUDtBQUNELEM7Ozs7Ozs7Ozs7OztBQ2ZEO0FBQUE7QUFBQTtBQUFBO0FBQWE7O0FBRWI7QUFFQTs7Ozs7Ozs7O0FBUWUsU0FBU2xiLDJCQUFULENBQXFDTSxNQUFyQyxFQUE2QztBQUUxRCxNQUFNUixLQUFLLEdBQUdnSSxxRkFBRyxDQUFDeEgsTUFBRCxFQUFTLGFBQVQsQ0FBakI7QUFDQSxNQUFNMFksR0FBRyxHQUFHRyxNQUFNLENBQUNnQyxVQUFQLENBQWtCcmIsS0FBbEIsRUFBeUJzYixPQUF6QixDQUFpQyxDQUFqQyxDQUFaO0FBRUEsU0FBTzFDLEtBQUssQ0FBQ00sR0FBRCxDQUFMLEdBQWEsR0FBYixhQUFzQkEsR0FBdEIsTUFBUDtBQUVEO0FBQUEsQzs7Ozs7Ozs7Ozs7O0FDbkJEO0FBQUE7QUFBQTtBQUFhOztBQUViO0FBRUE7Ozs7Ozs7QUFNZSx5RUFBVS9XLElBQVYsRUFBZ0I7QUFFN0IsTUFBSSxDQUFDb1osNEVBQVEsQ0FBQ3BaLElBQUQsQ0FBYixFQUFxQixPQUFPLEtBQVA7QUFFckIsTUFBSThMLEdBQUo7QUFDQSxNQUFJMEQsR0FBSjtBQUNBLE1BQUk2SixFQUFFLEdBQUcsQ0FBVDtBQUNBLE1BQUlDLEVBQUUsR0FBRyxDQUFUO0FBQ0EsTUFBSUMsRUFBRSxHQUFHLENBQVQ7O0FBQ0Esa0NBQVlyTyxNQUFNLENBQUNtSixJQUFQLENBQVlyVSxJQUFaLENBQVosa0NBQStCO0FBQTFCOEwsT0FBMEI7QUFDN0IsUUFBSSxDQUFDOUwsSUFBSSxDQUFDOEwsR0FBRCxDQUFULEVBQWdCO0FBQ2hCMEQsT0FBRyxHQUFHeFAsSUFBSSxDQUFDOEwsR0FBRCxDQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNBLFFBQUkwRCxHQUFHLEdBQUcsQ0FBVixFQUFhNkosRUFBRSxHQUFmLEtBQ0ssSUFBSTdKLEdBQUcsR0FBRyxDQUFWLEVBQWE4SixFQUFFLEdBQWYsS0FDQUMsRUFBRTtBQUNSOztBQUVELE1BQU1wTCxLQUFLLEdBQUdrTCxFQUFFLEdBQUdDLEVBQUwsR0FBVUMsRUFBeEI7QUFDQSxNQUFNQyxXQUFXLEdBQUcsR0FBcEI7QUFDQSxNQUFJQyxLQUFLLEdBQUcxRyxJQUFJLENBQUNFLEtBQUwsQ0FBV29HLEVBQUUsSUFBSWxMLEtBQUssR0FBRyxHQUFaLENBQWIsQ0FBWjtBQUNBLE1BQUl1TCxLQUFLLEdBQUczRyxJQUFJLENBQUNFLEtBQUwsQ0FBV3FHLEVBQUUsSUFBSW5MLEtBQUssR0FBRyxHQUFaLENBQWIsQ0FBWjtBQUNBLE1BQUl3TCxLQUFLLEdBQUc1RyxJQUFJLENBQUNFLEtBQUwsQ0FBV3NHLEVBQUUsSUFBSXBMLEtBQUssR0FBRyxHQUFaLENBQWIsQ0FBWjtBQUNBc0wsT0FBSyxHQUFHaEQsS0FBSyxDQUFDZ0QsS0FBRCxDQUFMLEdBQWVELFdBQWYsR0FBNkJDLEtBQXJDO0FBQ0FDLE9BQUssR0FBR2pELEtBQUssQ0FBQ2dELEtBQUQsQ0FBTCxHQUFlRCxXQUFmLEdBQTZCRSxLQUFyQztBQUNBQyxPQUFLLEdBQUdsRCxLQUFLLENBQUNnRCxLQUFELENBQUwsR0FBZUQsV0FBZixHQUE2QkcsS0FBckM7QUFDQWpWLFVBQVEsQ0FBQ0MsYUFBVCxDQUF1Qiw4QkFBdkIsRUFBdURvRSxTQUF2RCxhQUFzRTBRLEtBQXRFO0FBQ0EvVSxVQUFRLENBQUNDLGFBQVQsQ0FBdUIsOEJBQXZCLEVBQXVEb0UsU0FBdkQsYUFBc0UyUSxLQUF0RTtBQUNBaFYsVUFBUSxDQUFDQyxhQUFULENBQXVCLDhCQUF2QixFQUF1RG9FLFNBQXZELGFBQXNFNFEsS0FBdEU7QUFDQWpWLFVBQVEsQ0FBQ0MsYUFBVCxDQUF1QixpQ0FBdkIsRUFBMERvRSxTQUExRCxhQUF5RW9GLEtBQXpFO0FBRUQsQzs7Ozs7Ozs7Ozs7QUN4Q0QsdUMiLCJmaWxlIjoiamF2YXNjcmlwdC9hcHAuM2I2YjFkOGQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbiBcdGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGRhdGEpIHtcbiBcdFx0dmFyIGNodW5rSWRzID0gZGF0YVswXTtcbiBcdFx0dmFyIG1vcmVNb2R1bGVzID0gZGF0YVsxXTtcbiBcdFx0dmFyIGV4ZWN1dGVNb2R1bGVzID0gZGF0YVsyXTtcblxuIFx0XHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcbiBcdFx0Ly8gdGhlbiBmbGFnIGFsbCBcImNodW5rSWRzXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXG4gXHRcdHZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDAsIHJlc29sdmVzID0gW107XG4gXHRcdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuIFx0XHRcdGlmKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuIFx0XHRcdFx0cmVzb2x2ZXMucHVzaChpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0pO1xuIFx0XHRcdH1cbiBcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuIFx0XHR9XG4gXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYocGFyZW50SnNvbnBGdW5jdGlvbikgcGFyZW50SnNvbnBGdW5jdGlvbihkYXRhKTtcblxuIFx0XHR3aGlsZShyZXNvbHZlcy5sZW5ndGgpIHtcbiBcdFx0XHRyZXNvbHZlcy5zaGlmdCgpKCk7XG4gXHRcdH1cblxuIFx0XHQvLyBhZGQgZW50cnkgbW9kdWxlcyBmcm9tIGxvYWRlZCBjaHVuayB0byBkZWZlcnJlZCBsaXN0XG4gXHRcdGRlZmVycmVkTW9kdWxlcy5wdXNoLmFwcGx5KGRlZmVycmVkTW9kdWxlcywgZXhlY3V0ZU1vZHVsZXMgfHwgW10pO1xuXG4gXHRcdC8vIHJ1biBkZWZlcnJlZCBtb2R1bGVzIHdoZW4gYWxsIGNodW5rcyByZWFkeVxuIFx0XHRyZXR1cm4gY2hlY2tEZWZlcnJlZE1vZHVsZXMoKTtcbiBcdH07XG4gXHRmdW5jdGlvbiBjaGVja0RlZmVycmVkTW9kdWxlcygpIHtcbiBcdFx0dmFyIHJlc3VsdDtcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlZmVycmVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBkZWZlcnJlZE1vZHVsZSA9IGRlZmVycmVkTW9kdWxlc1tpXTtcbiBcdFx0XHR2YXIgZnVsZmlsbGVkID0gdHJ1ZTtcbiBcdFx0XHRmb3IodmFyIGogPSAxOyBqIDwgZGVmZXJyZWRNb2R1bGUubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdHZhciBkZXBJZCA9IGRlZmVycmVkTW9kdWxlW2pdO1xuIFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtzW2RlcElkXSAhPT0gMCkgZnVsZmlsbGVkID0gZmFsc2U7XG4gXHRcdFx0fVxuIFx0XHRcdGlmKGZ1bGZpbGxlZCkge1xuIFx0XHRcdFx0ZGVmZXJyZWRNb2R1bGVzLnNwbGljZShpLS0sIDEpO1xuIFx0XHRcdFx0cmVzdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBkZWZlcnJlZE1vZHVsZVswXSk7XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdHJldHVybiByZXN1bHQ7XG4gXHR9XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4gXHQvLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbiBcdC8vIFByb21pc2UgPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG4gXHR2YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuIFx0XHRcImFwcFwiOiAwXG4gXHR9O1xuXG4gXHR2YXIgZGVmZXJyZWRNb2R1bGVzID0gW107XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wXCJdID0gd2luZG93W1wid2VicGFja0pzb25wXCJdIHx8IFtdO1xuIFx0dmFyIG9sZEpzb25wRnVuY3Rpb24gPSBqc29ucEFycmF5LnB1c2guYmluZChqc29ucEFycmF5KTtcbiBcdGpzb25wQXJyYXkucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrO1xuIFx0anNvbnBBcnJheSA9IGpzb25wQXJyYXkuc2xpY2UoKTtcbiBcdGZvcih2YXIgaSA9IDA7IGkgPCBqc29ucEFycmF5Lmxlbmd0aDsgaSsrKSB3ZWJwYWNrSnNvbnBDYWxsYmFjayhqc29ucEFycmF5W2ldKTtcbiBcdHZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gb2xkSnNvbnBGdW5jdGlvbjtcblxuXG4gXHQvLyBhZGQgZW50cnkgbW9kdWxlIHRvIGRlZmVycmVkIGxpc3RcbiBcdGRlZmVycmVkTW9kdWxlcy5wdXNoKFtcIi4vcHVibGljL2phdmFzY3JpcHQvaW5kZXguanNcIiwwXSk7XG4gXHQvLyBydW4gZGVmZXJyZWQgbW9kdWxlcyB3aGVuIHJlYWR5XG4gXHRyZXR1cm4gY2hlY2tEZWZlcnJlZE1vZHVsZXMoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gQ3J5cHRvaHViIHV0aWwgZnVuY3Rpb25zXG5pbXBvcnQgY2VsbFRvb2x0aXAgICAgICAgICAgICAgICAgIGZyb20gJy4vdXRpbHMvY2VsbC10b29sdGlwLmpzJztcbmltcG9ydCBzaG91bGRDZWxsVXBkYXRlICAgICAgICAgICAgZnJvbSAnLi91dGlscy9zaG91bGQtY2VsbC11cGRhdGUuanMnO1xuXG4vLyBhZy1ncmlkIHZhbHVlRm9ybWF0dGVyc1xuaW1wb3J0IHZhbHVlRm9ybWF0dGVyUGVyY2VudENoYW5nZSBmcm9tICcuL3V0aWxzL3ZhbHVlLWZvcm1hdHRlci1wZXJjZW50LWNoYW5nZS5qcyc7XG5cbi8vIGFnLWdyaWQgY2VsbCBSZW5kZXJlciBDbGFzc2VzXG5pbXBvcnQgQ29tcG91bmRDZWxsUmVuZGVyZXIgICAgICAgIGZyb20gJy4vdXRpbHMvY2xhc3MtY29tcG91bmQtY2VsbC1yZW5kZXJlci5qcyc7XG5cbi8vIGFnLWdyaWQgY3VzdG9tIGZpbHRlcnNcbmltcG9ydCBmaWx0ZXJOdW1iZXIgICAgICAgICAgICAgICAgZnJvbSAnLi91dGlscy9maWx0ZXItbnVtYmVyLmpzJztcbmltcG9ydCBmaWx0ZXJGbG9hdGluZ051bWJlciAgICAgICAgZnJvbSAnLi91dGlscy9maWx0ZXItZmxvYXRpbmctbnVtYmVyLmpzJztcblxuLy8gYWctZ3JpZCBmaWx0ZXIgY29tcGFyYXRvcnNcbmltcG9ydCBzb3J0TnVtYmVycyAgICAgICAgICAgICAgICAgZnJvbSAnLi91dGlscy9zb3J0LW51bWJlcnMuanMnO1xuXG4vL1xuLy8gQUctR1JJRCBCQVNFIE9QVElPTlNcbi8vXG4vLyBEZWZhdWx0IGFnLWdyaWQgb3B0aW9ucyBiZWZvcmUgYW55IGNvbmZpZ3VyYXRpb24gaXMgYXBwbGllZFxuLy9cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvL1xuICAvLyBBRy1HUklEIENvbXBvbmVudHNcbiAgLy9cbiAgLy8gWW91IGNhbiBjcmVhdGUgeW91ciBvd24gY3VzdG9tIGNvbXBvbmVudHMgdG8gY3VzdG9taXNlIHRoZSBiZWhhdmlvdXIgb2YgdGhlIGdyaWQuXG4gIC8vIEZvciBleGFtcGxlIHlvdSBjYW4gY3VzdG9taXNlIGhvdyBjZWxscyBhcmUgcmVuZGVyZWQsIGhvdyB2YWx1ZXMgYXJlIGVkaXRlZCBhbmQgYWxzbyBjcmVhdGUgeW91ciBvd24gZmlsdGVycy5cbiAgLy9cbiAgLy8gVGhlIGZ1bGwgbGlzdCBvZiBjb21wb25lbnQgdHlwZXMgeW91IGNhbiBwcm92aWRlIGluIGFnLUdyaWQgYXJlIGFzIGZvbGxvd3M6XG4gIC8vXG4gIC8vIENlbGwgUmVuZGVyZXI6ICAgICAgICBUbyBjdXN0b21pc2VzIHRoZSBjb250ZW50cyBvZiBhIGNlbGwuXG4gIC8vIENlbGwgRWRpdG9yOiAgICAgICAgICBUbyBjdXN0b21pc2VzIGVkaXRpbmcgb2YgYSBjZWxsLlxuICAvLyBGaWx0ZXIgQ29tcG9uZW50OiAgICAgRm9yIGN1c3RvbSBjb2x1bW4gZmlsdGVyIHRoYXQgYXBwZWFycyBpbnNpZGUgdGhlIGNvbHVtbiBtZW51LlxuICAvLyBGbG9hdGluZyBGaWx0ZXI6ICAgICAgRm9yIGN1c3RvbSBjb2x1bW4gZmlsdGVyIHRoYXQgYXBwZWFycyBpbnNpZGUgdGhlIGNvbHVtbiBtZW51LlxuICAvLyBEYXRlIENvbXBvbmVudDogICAgICAgVG8gY3VzdG9taXNlIHRoZSBkYXRlIHNlbGVjdGlvbiBjb21wb25lbnQgaW4gdGhlIGRhdGUgZmlsdGVyLlxuICAvLyBIZWFkZXIgQ29tcG9uZW50OiAgICAgVG8gY3VzdG9taXNlIHRoZSBoZWFkZXIgb2YgYSBjb2x1bW4gYW5kIGNvbHVtbiBncm91cHMuXG4gIC8vIE92ZXJsYXkgQ29tcG9uZW50OiAgICBUbyBjdXN0b21pc2UgbG9hZGluZyBhbmQgbm8gcm93cyBvdmVybGF5IGNvbXBvbmVudHMuXG4gIC8vIFN0YXR1cyBCYXIgQ29tcG9uZW50OiBGb3IgY3VzdG9tIHN0YXR1cyBiYXIgY29tcG9uZW50cy5cbiAgLy9cbiAgY29tcG9uZW50czoge30sXG5cbiAgLy9cbiAgLy8gQUctR1JJRCBjb2x1bW5UeXBlc1xuICAvL1xuICAvLyBzcGVjaWZpYyBjb2x1bW4gdHlwZXMgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRoYXQgY29sdW1uIGRlZmluaXRpb25zIGNhbiBpbmhlcml0LlxuICAvL1xuICBjb2x1bW5UeXBlczoge1xuXG4gICAgY3J5cHRvaHViRGVmYXVsdHM6IHtcbiAgICAgIC8vIE5PVEU6IHRoZSBlcXVhbHMgcHJvcGVydHkgaXMgbm90IHNob3duIGluIHRoZSBzdGFuZGFyZCBsaXN0IG9mIGFnLWdyaWQgb3B0aW9uc1xuICAgICAgLy8gaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vamF2YXNjcmlwdC1ncmlkLWNoYW5nZS1kZXRlY3Rpb24vXG4gICAgICBlcXVhbHM6IHNob3VsZENlbGxVcGRhdGUsXG4gICAgICB0b29sdGlwOiBjZWxsVG9vbHRpcCxcbiAgICB9LFxuXG4gICAgY3J5cHRvaHViTnVtZXJpYzoge1xuXG4gICAgICAvLyBGaWx0ZXJcbiAgICAgIGZpbHRlcjogZmlsdGVyTnVtYmVyLFxuICAgICAgc3VwcHJlc3NNZW51OiB0cnVlLFxuXG4gICAgICAvLyBGbG9hdGluZyBmaWx0ZXJcbiAgICAgIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50OiBmaWx0ZXJGbG9hdGluZ051bWJlcixcbiAgICAgIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50UGFyYW1zOiB7XG4gICAgICAgIHN1cHByZXNzTWVudTogdHJ1ZSxcbiAgICAgICAgc3VwcHJlc3NGaWx0ZXJCdXR0b246IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8vIFNvcnRcbiAgICAgIGNvbXBhcmF0b3I6IHNvcnROdW1iZXJzLFxuXG4gICAgICAvLyBTdHlsZVxuICAgICAgY2VsbENsYXNzOiAnY3J5cHRvaHViLWFsaWduLXJpZ2h0JyxcblxuICAgIH0sXG5cbiAgICBjcnlwdG9odWJQZXJjZW50OiB7XG4gICAgICBjZWxsQ2xhc3NSdWxlczoge1xuICAgICAgICAnY3J5cHRvaHViLXRleHQtYmFkJzogeCA9PiB4LnZhbHVlICYmIHgudmFsdWUudmFsdWUgPCAwLFxuICAgICAgICAnY3J5cHRvaHViLXRleHQtZ29vZCc6IHggPT4geC52YWx1ZSAmJiB4LnZhbHVlLnZhbHVlID4gMCxcbiAgICAgIH0sXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdmFsdWVGb3JtYXR0ZXJQZXJjZW50Q2hhbmdlLFxuICAgICAgLy8gVE9ETyB0aGUgY29tcG91bmQgcmVuZGVyZXIgaXMgbm90IHdoYXQgSSBwbGFubmVkIGl0IHRvIGJlLCByZXZpc2l0XG4gICAgICBjZWxsUmVuZGVyZXI6IENvbXBvdW5kQ2VsbFJlbmRlcmVyLFxuICAgIH0sXG5cbiAgICBjcnlwdG9odWJUZXh0OiB7XG4gICAgICBmaWx0ZXI6ICdhZ1RleHRDb2x1bW5GaWx0ZXInLFxuICAgIH0sXG5cbiAgfSxcblxuICBjb2x1bW5EZWZzOiBbXSxcblxuICBvbkNlbGxNb3VzZU92ZXIocGFyYW1zKSB7XG4gICAgY29uc3QgZmllbGQgPSBwYXJhbXMuY29sRGVmLmZpZWxkO1xuICAgIGxldCBhY3Rpb24gPSBudWxsO1xuICAgIGlmIChmaWVsZCA9PT0gJ2NjLXRvdGFsLXZvbC1mdWxsLVBSSUNFJykge1xuICAgICAgYWN0aW9uID0gJ3RyYWRpbmd2aWV3J1xuICAgIH1cbiAgICB3aW5kb3cuYm8uaW5zdC5jZWxsSW50ZXJhY3Rpb25zLm1vdXNlT3ZlcihwYXJhbXMsIGFjdGlvbik7XG4gIH0sXG5cbiAgb25DZWxsTW91c2VPdXQocGFyYW1zKSB7XG4gICAgd2luZG93LmJvLmluc3QuY2VsbEludGVyYWN0aW9ucy5tb3VzZU91dChwYXJhbXMpO1xuICB9LFxuXG4gIG9uVmlydHVhbENvbHVtbnNDaGFuZ2VkKHBhcmFtcykge1xuICAgIGNvbnNvbGUubG9nKHBhcmFtcyk7XG4gIH0sXG5cbiAgb25WaXJ0dWFsUm93UmVtb3ZlZChwYXJhbXMpIHtcbiAgICBjb25zb2xlLmxvZyhwYXJhbXMpO1xuICB9LFxuXG4gIHJvd0hlaWdodDogMzUsXG5cbiAgLy8gTk9URTogRE8gTk9UIENIQU5HRSBVTkxFU1MgWU9VIFdBTlQgVE8gVVBEQVRFIEhPVyBEQVRBIFdPUktTXG4gIHJvd0RhdGE6IHdpbmRvdy5yZWZzLnJvd0RhdGEsXG5cbiAgLy8gU2V0IHRvIHRydWUgdG8gaGF2ZSBjZWxscyBmbGFzaCBhZnRlciBkYXRhIGNoYW5nZXMuIFNlZSBGbGFzaGluZyBEYXRhIENoYW5nZXMuXG4gIGVuYWJsZUNlbGxDaGFuZ2VGbGFzaDogdHJ1ZSxcblxuICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIHVzaW5nIENsaWVudC1zaWRlIFJvdyBNb2RlbCB0byBlbmFibGUgUm93IEZpbHRlcmluZ1xuICBlbmFibGVGaWx0ZXI6IHRydWUsXG5cbiAgLy8gU2V0IHRvIHRydWUgd2hlbiB1c2luZyBDbGllbnQtc2lkZSBSb3cgTW9kZWwgdG8gZW5hYmxlIFJvdyBTb3J0aW5nLlxuICAvLyBDbGlja2luZyBhIGNvbHVtbiBoZWFkZXIgd2lsbCBjYXVzZSB0aGUgZ3JpZCB0byBzb3J0IHRoZSBkYXRhLlxuICBlbmFibGVTb3J0aW5nOiB0cnVlLFxuXG4gIC8vIEZsb2F0aW5nIEZpbHRlciBjb21wb25lbnRzIGFsbG93IHlvdSB0byBhZGQgeW91ciBvd24gZmxvYXRpbmcgZmlsdGVyIHR5cGVzIHRvIGFnLUdyaWRcbiAgZmxvYXRpbmdGaWx0ZXI6IHRydWUsXG5cbiAgLy8gU2V0IHRvIHRydWUgdG8gYWxsb3cgY29sdW1uIHJlc2l6aW5nIGJ5IGRyYWdnaW5nIHRoZSBtb3VzZSBhdCBhIGNvbHVtbnMgaGVhZGVycyBlZGdlLlxuICBlbmFibGVDb2xSZXNpemU6IHRydWUsXG5cbiAgLy8gSWYgeW91IHR1cm4gb24gZGVsdGFSb3dEYXRhTW9kZSwgdGhlbiB3aGVuIHlvdSBjYWxsIGFwaS5zZXRSb3dEYXRhKHJvd0RhdGEpXG4gIC8vIHRoZSBncmlkIHdpbGwgd29yayBvdXQgd2hpY2ggaXRlbXMgYXJlIHRvIGJlIGFkZGVkLCByZW1vdmVkIGFuZCB1cGRhdGVkLlxuICAvLyBGb3IgdGhpcyB0byB3b3JrIHlvdSBtdXN0IGltcGxlbWVudCBgZ2V0Um93Tm9kZUlkYC5cbiAgZGVsdGFSb3dEYXRhTW9kZTogdHJ1ZSxcblxuICAvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgUm93IEFuaW1hdGlvbi5cbiAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuXG4gIC8vIFR5cGUgb2YgUm93IFNlbGVjdGlvbiwgc2V0IHRvIGVpdGhlciAnc2luZ2xlJyBvciAnbXVsdGlwbGUnLlxuICByb3dTZWxlY3Rpb246ICdtdWx0aXBsZScsXG5cbiAgZ2V0Um93Tm9kZUlkOiBkYXRhID0+IHtcbiAgICByZXR1cm4gZGF0YVsnY2MtdG90YWwtdm9sLWZ1bGwtSWQnXS52YWx1ZTtcbiAgfSxcblxuICAvLyBkZWZhdWx0Q29sRGVmOiBjb250YWlucyBjb2x1bW4gcHJvcGVydGllcyBhbGwgY29sdW1ucyB3aWxsIGluaGVyaXQuXG4gIGRlZmF1bHRDb2xEZWY6IHtcbiAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgcmVzaXphYmxlOiB0cnVlLFxuICAgIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50UGFyYW1zOiB7XG4gICAgICBzdXBwcmVzc01lbnU6IHRydWUsXG4gICAgICBzdXBwcmVzc0ZpbHRlckJ1dHRvbjogdHJ1ZVxuICAgIH0sXG4gIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gQ3J5cHRvaHViIHV0aWwgZnVuY3Rpb25zXG5pbXBvcnQgY29udmVydFdvcmtpbmdEYXRhVG9Sb3dEYXRhICAgIGZyb20gJy4vdXRpbHMvY29udmVydC13b3JraW5nLWRhdGEtdG8tcm93LWRhdGEuanMnO1xuaW1wb3J0IHVwZGF0ZU92ZXJ2aWV3ICAgICAgICAgICAgICAgICBmcm9tICcuL3V0aWxzL3ZpZXctdXBkYXRlLW92ZXJ2aWV3LmpzJztcblxuLy8gYWctZ3JpZCBjb25maWdcbmltcG9ydCBjb2x1bW5MaWJyYXJ5ICAgICBmcm9tICcuL2NvbHVtbi1saWJyYXJ5LmpzJztcbmltcG9ydCBkZWZhdWx0Q29uZmlnICAgICBmcm9tICcuL2RlZmF1bHQtY29uZmlnLmpzJztcbmltcG9ydCBhZ0dyaWRPcHRpb25zQmFzZSBmcm9tICcuL2FnLWdyaWQtb3B0aW9ucy1iYXNlLmpzJztcblxuLyoqXG4gKlxuICogQUctR1JJRCBjb2x1bW5EZWZzXG4gKlxuICogRWFjaCBjb2x1bW4gaW4gdGhlIGdyaWQgaXMgZGVmaW5lZCB1c2luZyBhIGNvbHVtbiBkZWZpbml0aW9uLlxuICogQ29sdW1ucyBhcmUgcG9zaXRpb25lZCBpbiB0aGUgZ3JpZCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIHRoZSBDb2xEZWYncyBhcmUgc3BlY2lmaWVkIGluIHRoZSBncmlkIG9wdGlvbnNcbiAqXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sdW1uRGVmcyhjb2x1bW5zKSB7XG5cbiAgbGV0IGlkO1xuICBsZXQgY29sdW1uO1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgZm9yIChjb2x1bW4gb2YgY29sdW1ucykge1xuICAgIGlkID0gY29sdW1uLmlkO1xuICAgIGlmIChpZCBpbiBjb2x1bW5MaWJyYXJ5KSB7XG4gICAgICBvdXRwdXQucHVzaChjb2x1bW5MaWJyYXJ5W2lkXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG5cbn1cblxuLyoqXG4gKlxuICogT24gR3JpZCBSZWFkeVxuICpcbiAqL1xuZnVuY3Rpb24gb25HcmlkUmVhZHkocGFyYW1zKSB7XG5cbiAgLy8gZGVmYXVsdCBzb3J0IG9yZGVyXG4gIHBhcmFtcy5hcGkuc2V0U29ydE1vZGVsKFtcbiAgICB7XG4gICAgICBjb2xJZDogY29sdW1uTGlicmFyeVtkZWZhdWx0Q29uZmlnLnNvcnQuY29sdW1uXS5maWVsZCxcbiAgICAgIHNvcnQ6IGRlZmF1bHRDb25maWcuc29ydC5kaXJlY3Rpb25cbiAgICB9XG4gIF0pO1xuXG4gIHdpbmRvdy5iby5mdW5jLnVwZGF0ZWQoJ25vdycpO1xuICB3aW5kb3cucmVmcy53b3JraW5nRGF0YSA9IHdpbmRvdy5pbml0RGF0YTtcbiAgd2luZG93LnJlZnMucm93RGF0YSA9IGNvbnZlcnRXb3JraW5nRGF0YVRvUm93RGF0YSh3aW5kb3cuaW5pdERhdGEgfHwge30pO1xuICBwYXJhbXMuYXBpLnNldFJvd0RhdGEod2luZG93LnJlZnMucm93RGF0YSk7XG5cbiAgdXBkYXRlT3ZlcnZpZXcod2luZG93LnJlZnMud29ya2luZ0RhdGEpO1xuXG59O1xuXG4vKipcbiAqXG4gKiBHZW5lcmF0ZSBBZ09wdGlvbnNcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdlbmVyYXRlQWdPcHRpb25zKCkge1xuXG4gIGlmICghd2luZG93LmJvKSB0aHJvdyBuZXcgRXJyb3IoJ3dpbmRvdy5ibyBkb2VzIG5vdCBleGlzdCcpO1xuICBpZiAoIXdpbmRvdy5yZWZzKSB0aHJvdyBuZXcgRXJyb3IoJ3dpbmRvdy5yZWZzIGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgLy9cbiAgLy8gVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB1cmwgY29uZmlnXG4gIC8vIGlmIHRoZXJlIGlzIHVzZSB0aGF0IGFuZCBiYWNrZmlsbCB3aXRoIHRoZSBkZWZhdWx0IGNvbmZpZ1xuICAvLyBkb250IGZvcmdldCB0byBtYWtlIGl0IHZlcnkgc2VjdXJlISEhXG4gIC8vXG4gIGNvbnN0IGNvbHVtbkRlZnMgPSBnZW5lcmF0ZUNvbHVtbkRlZnMoZGVmYXVsdENvbmZpZy5jb2x1bW5zKTtcblxuICBjb25zdCBvcHRpb25zID0gd2luZG93LmJvLmFnT3B0aW9ucyA9IHtcbiAgICAuLi5hZ0dyaWRPcHRpb25zQmFzZSxcbiAgICAuLi57IGNvbHVtbkRlZnMgfSxcbiAgICAuLi57IG9uR3JpZFJlYWR5IH0sXG4gIH07XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBCaW5hcnkgT3ZlcmRvc2UgUHJvamVjdHNcbmltcG9ydCB7IGdldFJhbmRvbUludCB9ICAgICAgICAgICAgICAgZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuaW1wb3J0IHsgcGFydGlhbEFwcGxpY2F0aW9uIH0gICAgICAgICBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5pbXBvcnQgeyBodG1sVG9nZ2xlQ2xhc3MgfSAgICAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcblxuLy8gQ3J5cHRvaHViIHV0aWwgZnVuY3Rpb25zXG5pbXBvcnQgcG9wRGl2ICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL3V0aWxzL3BvcGRpdi5qcyc7XG5pbXBvcnQgaW5pdFB1ZyAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2dlbmVyYXRlZC9pbml0LXB1Zy5nZW5lcmF0ZWQuanMnO1xuXG5pbXBvcnQgY2VsbE9uQ2xpY2tUcmFkaW5ndmlldyAgICAgICAgIGZyb20gJy4uL3V0aWxzL2NlbGwtb24tY2xpY2stdHJhZGluZ3ZpZXcuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDZWxsSW50ZXJhY3Rpb25zIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhvdmVyaW5nJGNlbGwgPSBudWxsO1xuICAgIHRoaXMub3Blbkl0ZW1zID0gW107XG4gICAgdGhpcy50aXBweU9wdGlvbnMgPSB7XG4gICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICAgIGhpZGVPbkNsaWNrOiAnZmFsc2UnLFxuICAgICAgaW50ZXJhY3RpdmVCb3JkZXI6IDUsXG4gICAgICBpbnRlcmFjdGl2ZURlYm91bmNlOiAxLFxuICAgICAgb25IaWRlKHRpcHB5KSB7XG4gICAgICAgIGNvbnN0IG9wZW5lZCA9IHRpcHB5LnJlZmVyZW5jZS5kYXRhc2V0LmNoT3BlbiA9PT0gJ3RydWUnO1xuICAgICAgICBjb25zdCBob3ZlcmluZyA9IHRpcHB5LnJlZmVyZW5jZS5kYXRhc2V0LmNoSG92ZXIgPT09ICd0cnVlJztcbiAgICAgICAgaWYgKG9wZW5lZCB8fCBob3ZlcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBPcGVuIGEgcG9wZGl2XG4gICAqXG4gICAqL1xuICBzdGF0aWMgb3BlbihwYXJhbXMsIGFjdGlvbikge1xuXG4gICAgY29uc3QgJGNlbGwgPSBwYXJhbXMuZXZlbnQuc3JjRWxlbWVudC5jbG9zZXN0KCcuYWctY2VsbCcpO1xuICAgIC8vIGh0bWxUb2dnbGVDbGFzcygkY2VsbCwgJ2NoLWNlbGwtYWN0aXZlJyk7XG5cbiAgICAvLyB0aGlzLnNldE1vdXNlT3ZlclN0YXRlKCRjZWxsKTtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSAndHJhZGluZ3ZpZXcnOlxuICAgICAgICAkY2VsbC5kYXRhc2V0LmNoT3BlbiA9IHRydWU7XG4gICAgICAgICRjZWxsLl90aXBweS5zZXQoe1xuICAgICAgICAgIGhpZGVPbkNsaWNrOiAnZmFsc2UnLFxuICAgICAgICB9KTtcbiAgICAgICAgY2VsbE9uQ2xpY2tUcmFkaW5ndmlldygnVVNEJywgcGFyYW1zKTtcbiAgICAgICAgJGNlbGwuJHBvcERpdlRpcHB5ID0gJGNlbGwuX3RpcHB5O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBDbG9zZSBhIHBvcGRpdlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGNsb3NlKHBhcmFtcykge1xuICAgIGNvbnN0ICRjZWxsID0gcGFyYW1zLmV2ZW50LnNyY0VsZW1lbnQuY2xvc2VzdCgnLmFnLWNlbGwnKTtcbiAgICBpZiAoJGNlbGwuJHBvcERpdlRpcHB5KSB7XG4gICAgICAkY2VsbC4kcG9wRGl2VGlwcHkuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBTZXQgdGhlIG1vdXNlIG92ZXIgc3RhdGUgb2YgYSBjZWxsXG4gICAqXG4gICAqL1xuICBzZXRNb3VzZU92ZXJTdGF0ZSgkY2VsbCwgY29udGVudCkge1xuICAgIHBvcERpdigkY2VsbCwgY29udGVudCwgdGhpcy50aXBweU9wdGlvbnMpO1xuICAgICRjZWxsLiR0cmlnZ2VyVGlwcHkgPSAkY2VsbC5fdGlwcHk7XG4gICAgJGNlbGwuY2xhc3NMaXN0LmFkZCgnY2gtY2VsbC1ob3ZlcicpO1xuICAgICRjZWxsLmRhdGFzZXQuY2hIb3ZlciA9ICd0cnVlJztcbiAgICB0aGlzLmhvdmVyaW5nJGNlbGwgPSAkY2VsbDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBTZXQgdGhlIG1vdXNlIG91dCBzdGF0ZSBvZiBhIGNlbGxcbiAgICpcbiAgICovXG4gIHNldE1vdXNlT3V0U3RhdGUoJGNlbGwpIHtcbiAgICAkY2VsbC5kYXRhc2V0LmNoSG92ZXIgPSBmYWxzZTtcbiAgICAkY2VsbC5kYXRhc2V0LmNoT3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXJpbmckY2VsbCA9IG51bGw7XG4gICAgaWYgKCRjZWxsLiR0cmlnZ2VyVGlwcHkpIHtcbiAgICAgICRjZWxsLiR0cmlnZ2VyVGlwcHkucmVmZXJlbmNlLmNsYXNzTGlzdC5yZW1vdmUoJ2NoLWNlbGwtaG92ZXInKTtcbiAgICAgICRjZWxsLiR0cmlnZ2VyVGlwcHkuZGVzdHJveSgpO1xuICAgICAgaWYgKCRjZWxsLiR0cmlnZ2VyVGlwcHkpIHtcbiAgICAgICAgJGNlbGwuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRyaWdnZXJDbGlja0hhbmRsZXIpO1xuICAgICAgICAkY2VsbC4kdHJpZ2dlclRpcHB5LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogVXNlciBjbGlja2VkIG9uIGEgdHJpZ2dlclxuICAgKlxuICAgKi9cbiAgdHJpZ2dlckNsaWNrSGFuZGxlcihjb250ZXh0LCBwYXJhbXMsIGFjdGlvbikge1xuICAgIGNvbnN0ICRjZWxsID0gcGFyYW1zLmV2ZW50LnNyY0VsZW1lbnQuY2xvc2VzdCgnLmFnLWNlbGwnKTtcbiAgICBpZiAoJGNlbGwuZGF0YXNldC5jaE9wZW4gPT09ICd0cnVlJykge1xuICAgICAgY29udGV4dC5zZXRNb3VzZU91dFN0YXRlKCRjZWxsKTtcbiAgICAgIENlbGxJbnRlcmFjdGlvbnMuY2xvc2UocGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBDZWxsSW50ZXJhY3Rpb25zLm9wZW4ocGFyYW1zLCBhY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgKlxuICAgKi9cbiAgbW91c2VPdXQocGFyYW1zKSB7XG5cbiAgICBjb25zdCAkY2VsbCA9IHBhcmFtcy5ldmVudC5zcmNFbGVtZW50LmNsb3Nlc3QoJy5hZy1jZWxsJyk7XG4gICAgaWYgKCEkY2VsbC4kdHJpZ2dlcikge1xuICAgICAgdGhpcy5zZXRNb3VzZU91dFN0YXRlKCRjZWxsKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdCAkY2VsbCA9IHBhcmFtcy5ldmVudC5zcmNFbGVtZW50LmNsb3Nlc3QoJy5hZy1jZWxsJyk7XG4gICAgLy8gaWYgKHRoaXMuaG92ZXJpbmckY2VsbCAmJiAhaG92ZXJpbmckY2VsbE9wZW4pIHtcbiAgICAvLyAgIHRoaXMuc2V0TW91c2VPdXRTdGF0ZSh0aGlzLmhvdmVyaW5nJGNlbGwpO1xuICAgIC8vIH1cblxuICAvLyAgIGNvbnN0IGhvdmVyaW5nID0gJGNlbGwuZGF0YXNldC5jaEhvdmVyID09PSAndHJ1ZSc7XG4gIC8vICAgaWYgKGhvdmVyaW5nKSB7XG4gIC8vICAgICAkY2VsbC5kYXRhc2V0LmNoSG92ZXIgPSBmYWxzZTtcbiAgLy8gICAgIC8vICRjZWxsLmRhdGFzZXQuY2hPcGVuID0gZmFsc2U7XG4gIC8vICAgICBpZiAoJGNlbGwuX3RpcHB5KSB7XG4gIC8vICAgICAgICRjZWxsLl90aXBweS5yZWZlcmVuY2UuY2xhc3NMaXN0LnJlbW92ZSgnY2gtY2VsbC1ob3ZlcicpO1xuICAvLyAgICAgICAkY2VsbC5fdGlwcHkuZGVzdHJveSgpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBNb3VzZSBvdmVyIGhhbmRsZXJcbiAgICpcbiAgICovXG4gIG1vdXNlT3ZlcihwYXJhbXMsIGFjdGlvbikge1xuXG4gICAgY29uc3QgaWQgPSBnZXRSYW5kb21JbnQoKTtcbiAgICBjb25zdCAkY2VsbCA9IHBhcmFtcy5ldmVudC5zcmNFbGVtZW50LmNsb3Nlc3QoJy5hZy1jZWxsJyk7XG4gICAgY29uc3Qgd2lkdGggPSAkY2VsbC5zY3JvbGxXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSAkY2VsbC5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgY29udGVudCA9IGluaXRQdWdbJ2NoLXRpcHB5LWNlbGwtaG92ZXInXSh7aWR9KTtcbiAgICBjb25zdCBob3ZlcmluZyRjZWxsT3BlbiA9IHRoaXMuaG92ZXJpbmckY2VsbCAmJiB0aGlzLmhvdmVyaW5nJGNlbGwuZGF0YXNldC5jaE9wZW4gPT09ICd0cnVlJztcblxuICAgIC8vIElmIHdlIGFyZSBob3ZlcmluZyBvdmVyIG9uZSB0aGF0IGlzIGFscmVhZHkgb3BlblxuICAgIGlmICgkY2VsbC5kYXRhc2V0LmNoT3BlbiA9PT0gJ3RydWUnKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBzYW1lIGNlbGxcbiAgICBpZiAoJGNlbGwgPT09IHRoaXMuaG92ZXJpbmckY2VsbCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5ob3ZlcmluZyRjZWxsICYmICFob3ZlcmluZyRjZWxsT3Blbikge1xuICAgICAgdGhpcy5zZXRNb3VzZU91dFN0YXRlKHRoaXMuaG92ZXJpbmckY2VsbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGFjdGlvbnNcbiAgICBpZiAoIWFjdGlvbikgcmV0dXJuO1xuXG4gICAgaWYgKCRjZWxsLmRhdGFzZXQuY2hIb3ZlciAhPT0gJ3RydWUnKSB7XG4gICAgICB0aGlzLnNldE1vdXNlT3ZlclN0YXRlKCRjZWxsLCBjb250ZW50KTtcbiAgICB9XG5cbiAgICAvLyB0aGlzLmFjdGl2ZSRjZWxsID0gJGNlbGw7XG5cbiAgICBjb25zdCAkdHJpZ2dlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC5jaC10aXBweS1jZWxsLWhvdmVyLSR7aWR9YCk7XG4gICAgaWYgKCEkdHJpZ2dlcikgcmV0dXJuO1xuXG4gICAgJGNlbGwuJHRyaWdnZXIgPSAkdHJpZ2dlcjtcbiAgICAkY2VsbC4kdHJpZ2dlclRpcHB5ID0gJGNlbGwuX3RpcHB5O1xuXG4gICAgJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdjbGljaycsXG4gICAgICBwYXJ0aWFsQXBwbGljYXRpb24odGhpcy50cmlnZ2VyQ2xpY2tIYW5kbGVyLCB0aGlzLCBwYXJhbXMsIGFjdGlvbiksXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEJpbmFyeSBPdmVyZG9zZSBQcm9qZWN0c1xuaW1wb3J0IHsgb2JqZWN0R2V0TmVzdGVkUHJvcGVydHkgYXMgZ25wIH0gZnJvbSAnLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5pbXBvcnQgeyBwYXJ0aWFsQXBwbGljYXRpb24gfSAgICAgICAgICAgICBmcm9tICcuL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcblxuLy8gYWctZ3JpZCBjZWxsIFJlbmRlcmVyIENsYXNzZXNcbmltcG9ydCBDZWxsUmVuZGVyZXJTcGFya2xpbmUgICAgICAgICAgICAgIGZyb20gJy4vdXRpbHMvY2xhc3MtY2VsbC1yZW5kZXJlci1zcGFya2xpbmUuanMnO1xuXG4vLyBhZy1ncmlkIGNlbGwgUmVuZGVyZXJzXG5pbXBvcnQgY2VsbFJlbmRlcmVyTmFtZSAgICAgICAgICAgICAgICAgICBmcm9tICcuL3V0aWxzL2NlbGwtcmVuZGVyZXItbmFtZS5qcyc7XG5pbXBvcnQgY2VsbFJlbmRlcmVyTnVtYmVyICAgICAgICAgICAgICAgICBmcm9tICcuL3V0aWxzL2NlbGwtcmVuZGVyZXItbnVtYmVyLmpzJztcbmltcG9ydCBjZWxsUmVuZGVyZXJDdXJyZW5jeSAgICAgICAgICAgICAgIGZyb20gJy4vdXRpbHMvY2VsbC1yZW5kZXJlci1jdXJyZW5jeS5qcyc7XG5pbXBvcnQgY2VsbFJlbmRlcmVyRXhjaGFuZ2VzICAgICAgICAgICAgICBmcm9tICcuL3V0aWxzL2NlbGwtcmVuZGVyZXItZXhjaGFuZ2VzLmpzJztcbmltcG9ydCBjZWxsUmVuZGVyZXJUcmFkaW5ndmlldyAgICAgICAgICAgIGZyb20gJy4vdXRpbHMvY2VsbC1yZW5kZXJlci10cmFkaW5ndmlldy5qcyc7XG5cbi8vIGFnLWdyaWQgY2VsbCBvbiBjbGljayBoYW5kbGVyc1xuaW1wb3J0IGNlbGxPbkNsaWNrRXhjaGFuZ2VzICAgICAgICAgICAgICAgZnJvbSAnLi91dGlscy9jZWxsLW9uLWNsaWNrLWV4Y2hhbmdlcy5qcyc7XG5pbXBvcnQgY2VsbE9uQ2xpY2tUcmFkaW5ndmlldyAgICAgICAgICAgICBmcm9tICcuL3V0aWxzL2NlbGwtb24tY2xpY2stdHJhZGluZ3ZpZXcuanMnO1xuXG4vLyBhZy1ncmlkIGZpbHRlciBjb21wYXJhdG9yc1xuaW1wb3J0IHNvcnROdW1iZXJzICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi91dGlscy9zb3J0LW51bWJlcnMuanMnO1xuXG5jb25zdCBjb2x1bW5EZWZzID0ge1xuXG4gIC8vXG4gIC8vIFRPRE86IGhhc2ggdGhlIGNvbHVtbiBuYW1lIChpLmUuIHJvd0luZGV4KVxuICAvL1xuXG4gIC8vXG4gIC8vIFRoZSBudW1lcmljIGluZGV4IGZvciBlYWNoIHJvd1xuICAvLyBzdGF5cyB0aGUgc2FtZSBkdXJpbmcgc29ydCBhbmQgZmlsdGVyaW5nXG4gIC8vIGFsd2F5cyBjb3VudHMgZnJvbSAxIHRvIHJvd3MubGVuZ3RoXG4gIC8vXG4gIHJvd0luZGV4OiB7XG4gICAgdmFsdWVHZXR0ZXI6ICdub2RlLnJvd0luZGV4JyxcbiAgICBoZWFkZXJOYW1lOiAnIycsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdSb3cgTnVtYmVyJyxcbiAgICB3aWR0aDogNDAsXG4gICAgcGlubmVkOiAnbGVmdCcsXG4gICAgbG9ja1Bvc2l0aW9uOiB0cnVlLFxuICAgIHN1cHByZXNzTWVudTogdHJ1ZSxcbiAgICBzdXBwcmVzc0ZpbHRlcjogdHJ1ZSxcbiAgICBjZWxsQ2xhc3M6ICdjcnlwdG9odWItYWxpZ24tcmlnaHQnLFxuICAgIGNlbGxSZW5kZXJlcihwYXJhbXMpIHtcbiAgICAgIHJldHVybiBwYXJhbXMudmFsdWUgKyAxO1xuICAgIH0sXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1Yk51bWVyaWMnLFxuICAgIF0sXG4gIH0sXG5cbiAgLy9cbiAgLy8gTmFtZVxuICAvLyBBc3NldCBpY29uLCBuYW1lICYgc3ltYm9sXG4gIC8vXG4gIG5hbWU6IHtcbiAgICBmaWVsZDogJ2NjLXRvdGFsLXZvbC1mdWxsLUZ1bGxOYW1lLnZhbHVlJyxcbiAgICBoZWFkZXJOYW1lOiAnTmFtZScsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdOYW1lJyxcbiAgICB3aWR0aDogMTgwLFxuICAgIHBpbm5lZDogJ2xlZnQnLFxuICAgIGNlbGxSZW5kZXJlcjogY2VsbFJlbmRlcmVyTmFtZSxcbiAgfSxcblxuICAvL1xuICAvLyBTZWN0b3JcbiAgLy8gQSBsaXN0IG9mIHRoZSBhc3NldHMgc2VjdG9yc1xuICAvL1xuICBzZWN0b3JzOiB7XG4gICAgZmllbGQ6ICdtLW1ldHJpY3Mtc2VjdG9ycycsXG4gICAgaGVhZGVyTmFtZTogJ1NlY3RvcnMnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnU2VjdG9ycycsXG4gICAgd2lkdGg6IDE4MCxcbiAgICB0eXBlOiBbJ2NyeXB0b2h1YlRleHQnXSxcbiAgICB2YWx1ZUZvcm1hdHRlcihwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ25wKHBhcmFtcywgJ3ZhbHVlLnZhbHVlJyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICF2YWx1ZS5sZW5ndGgpIHJldHVybiBjaC5lbXB0eUNlbGxWYWx1ZTtcbiAgICAgIGVsc2UgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvL1xuICAvLyBVU0QgUHJpY2VcbiAgLy9cbiAgcHJpY2VVU0Q6IHtcbiAgICBmaWVsZDogJ2NjLXRvdGFsLXZvbC1mdWxsLVBSSUNFJyxcbiAgICBoZWFkZXJOYW1lOiAnUHJpY2UgKFVTRCknLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnUHJpY2UgaW4gVVNEXFxuXFxuRGF0YSBTb3VyY2U6IENyeXB0b2NvbXBhcmUnLFxuICAgIHdpZHRoOiAxMjAsXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1YkRlZmF1bHRzJyxcbiAgICAgICdjcnlwdG9odWJOdW1lcmljJyxcbiAgICBdLFxuICAgIGNlbGxSZW5kZXJlcjogcGFydGlhbEFwcGxpY2F0aW9uKGNlbGxSZW5kZXJlckN1cnJlbmN5LCB3aW5kb3cucmVmcyksXG4gICAgY2VsbFJlbmRlcmVyUGFyYW1zOiB7XG4gICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgfSxcbiAgICAvLyBvbkNlbGxDbGlja2VkOiBwYXJ0aWFsQXBwbGljYXRpb24oY2VsbE9uQ2xpY2tUcmFkaW5ndmlldywgJ1VTRCcpLFxuXG4gIH0sXG5cbiAgLy9cbiAgLy8gQlRDIFByaWNlXG4gIC8vXG4gIHByaWNlQlRDOiB7XG4gICAgZmllbGQ6ICdjcnlwdG9odWItcHJpY2UtYnRjJyxcbiAgICBoZWFkZXJOYW1lOiAnUHJpY2UgKEJUQyknLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnUHJpY2UgaW4gQlRDXFxuXFxuRGF0YSBTb3VyY2U6IEJpbmFyeU92ZXJkb3NlLCBjYWxjdWxhdGVkIGZyb20gQ3J5cHRvY29tcGFyZSBkYXRhJyxcbiAgICB3aWR0aDogMTIwLFxuICAgIHR5cGU6IFtcbiAgICAgICdjcnlwdG9odWJEZWZhdWx0cycsXG4gICAgICAnY3J5cHRvaHViTnVtZXJpYycsXG4gICAgXSxcbiAgICBjZWxsUmVuZGVyZXI6IHBhcnRpYWxBcHBsaWNhdGlvbihjZWxsUmVuZGVyZXJDdXJyZW5jeSwgd2luZG93LnJlZnMpLFxuICAgIGNlbGxSZW5kZXJlclBhcmFtczoge1xuICAgICAgY3VycmVuY3k6ICdTQVQnLFxuICAgIH0sXG4gICAgb25DZWxsQ2xpY2tlZDogcGFydGlhbEFwcGxpY2F0aW9uKGNlbGxPbkNsaWNrVHJhZGluZ3ZpZXcsICdCVEMnKSxcbiAgfSxcblxuICAvL1xuICAvLyBBbGwgVGltZSBIaWdoIChVU0QpXG4gIC8vXG4gIGF0aFVTRDoge1xuICAgIGZpZWxkOiAnbS1tZXRyaWNzLWF0aC1wcmljZScsXG4gICAgaGVhZGVyTmFtZTogJ0FUSCcsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdBbGwgVGltZSBIaWdoIChVU0QpXFxuXFxuRGF0YSBTb3VyY2U6IE9uQ2hhaW5GWCcsXG4gICAgd2lkdGg6IDEyMCxcbiAgICB0eXBlOiBbXG4gICAgICAnY3J5cHRvaHViRGVmYXVsdHMnLFxuICAgICAgJ2NyeXB0b2h1Yk51bWVyaWMnLFxuICAgIF0sXG4gICAgY2VsbFJlbmRlcmVyOiBwYXJ0aWFsQXBwbGljYXRpb24oY2VsbFJlbmRlcmVyQ3VycmVuY3ksIHdpbmRvdy5yZWZzKSxcbiAgICBjZWxsUmVuZGVyZXJQYXJhbXM6IHtcbiAgICAgIGN1cnJlbmN5OiAnVVNEJyxcbiAgICB9LFxuICB9LFxuXG4gIC8vXG4gIC8vIEN5Y2xlIGxvdyAoVVNEKVxuICAvL1xuICAvLyBUaGlzIGlzIHRoZSBsb3dlc3QgdHJhZGluZyBwcmljZSAoaW4gVVNEKSBvZiB0aGUgYXNzZXQgc2luY2UgaXRzIEFsbC1UaW1lLUhpZ2guXG4gIC8vIE5vdGVzIGFib3V0IGhvdyBPbkNoYWluRlggZGV0ZXJtaW5lcyBDeWNsZSBMb3c6XG4gIC8vXG4gIC8vIFRoZSBDeWNsZSBMb3cgcXVvdGUgaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBhYnNvbHV0ZSBsb3dlc3Qgc2luZ2xlIHRyYWRlIHByaWNlLlxuICAvLyBEdWUgdG8gdGhlIG5hdHVyZSBvZiB0aGUgaGlzdG9yaWNhbCBkYXRhIHdlIGFuYWx5emUsIHdlIGFyZSBub3QgYWx3YXlzIGFibGUgdG8gbG9vayBhdCBldmVyeSB0cmFkZSBmb3IgYW4gYXNzZXQuXG4gIC8vIEZvciBzb21lIGFzc2V0cywgdGhlIEN5Y2xlIExvdyBxdW90ZWQgbWF5IHJlZmVyIHRvIHRoZSBsb3dlc3QgZGFpbHkgYXZlcmFnZSBzaW5jZSB0aGUgQVRILFxuICAvLyBvciBhIHByaWNlLXNhbXBsZSBvbiB0aGUgZGF5IHRoZSBDeWNsZSBMb3cgb2NjdXJlZC5cbiAgLy9cbiAgY3ljbGVMb3dVU0Q6IHtcbiAgICBmaWVsZDogJ20tbWV0cmljcy1jeWNsZS1sb3ctcHJpY2UnLFxuICAgIGhlYWRlck5hbWU6ICdDeWNsZSBMb3cnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnVGhlIGxvd2VzdCB0cmFkaW5nIHByaWNlIChpbiBVU0QpIG9mIHRoZSBhc3NldCBzaW5jZSBpdHMgQWxsLVRpbWUtSGlnaFxcblxcbkRhdGEgU291cmNlOiBPbkNoYWluRlgnLFxuICAgIHdpZHRoOiAxMjAsXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1YkRlZmF1bHRzJyxcbiAgICAgICdjcnlwdG9odWJOdW1lcmljJyxcbiAgICBdLFxuICAgIGNlbGxSZW5kZXJlcjogcGFydGlhbEFwcGxpY2F0aW9uKGNlbGxSZW5kZXJlckN1cnJlbmN5LCB3aW5kb3cucmVmcyksXG4gICAgY2VsbFJlbmRlcmVyUGFyYW1zOiB7XG4gICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgfSxcbiAgfSxcblxuICAvL1xuICAvLyAyNCBIb3VyIFBlcmNlbnQgQ2hhbmdlIChVU0QpXG4gIC8vIE5PVEU6IFdlIHdhbnQgcGVyY2VudCBjaGFuZ2UgYWdhaW5zdCBCVEMgdG9vIVxuICAvL1xuICBwZXJjZW50Q2hhbmdlMjRoVVNEOiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1DSEFOR0VQQ1REQVknLFxuICAgIGhlYWRlck5hbWU6ICfOlCAyNGgnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnUGVyY2VudCBjaGFuZ2Ugb3ZlciAyNCBob3VycyBhZ2FpbnN0IFVTRFxcblxcbkRhdGEgU291cmNlOiBDcnlwdG9jb21wYXJlJyxcbiAgICB3aWR0aDogODAsXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1YkRlZmF1bHRzJyxcbiAgICAgICdjcnlwdG9odWJOdW1lcmljJyxcbiAgICAgICdjcnlwdG9odWJQZXJjZW50J1xuICAgIF0sXG4gIH0sXG5cbiAgLy9cbiAgLy8gNyBEYXkgUGVyY2VudCBjaGFuZ2UgKFVTRClcbiAgLy9cbiAgcGVyY2VudENoYW5nZTdkVVNEOiB7XG4gICAgZmllbGQ6ICdtLW1ldHJpY3MtcGVyY2VudC1jaGFuZ2UtYnRjLWxhc3QtMS13ZWVrJyxcbiAgICBoZWFkZXJOYW1lOiAnzpQgN0QnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnUGVyY2VudCBjaGFuZ2Ugb3ZlciA3IGRheXMgYWdhaW5zdCBCVENcXG5cXG5EYXRhIFNvdXJjZTogTWVzc2FyaScsXG4gICAgd2lkdGg6IDgwLFxuICAgIHR5cGU6IFtcbiAgICAgICdjcnlwdG9odWJEZWZhdWx0cycsXG4gICAgICAnY3J5cHRvaHViTnVtZXJpYycsXG4gICAgICAnY3J5cHRvaHViUGVyY2VudCdcbiAgICBdLFxuICB9LFxuXG4gIC8vXG4gIC8vIFNwYXJrbGluZSAoVVNEKVxuICAvL1xuICAvLyA3IERheSBVU0QgcHJpY2UgJiB2b2x1bWUgdHJlbmRcbiAgLy8gVG9wICYgYm90dG9tIG51bWJlcnMgYXJlICUgc3dpbmcgaW4gcHJpY2UgKHRvcCkgJiB2b2x1bWUgKGJvdHRvbSlcbiAgLy9cbiAgc3BhcmtsaW5lVVNEOiB7XG4gICAgZmllbGQ6ICdjcnlwdG9odWItcHJpY2UtaGlzdG9yeScsXG4gICAgaGVhZGVyTmFtZTogJzdEIFRyZW5kJyxcbiAgICBoZWFkZXJDbGFzczogJ0NILWNvbCcsXG4gICAgaGVhZGVyVG9vbHRpcDogJzcgRGF5IFVTRCBwcmljZSBhbmQgdm9sdW1lIHRyZW5kXFxuXFxuVG9wICYgYm90dG9tIG51bWJlcnMgYXJlICUgc3dpbmcgaW4gcHJpY2UgKHRvcCkgJiB2b2x1bWUgKGJvdHRvbSlcXG5cXG5EYXRhIFNvdXJjZTogQmluYXJ5T3ZlcmRvc2UgLyBDcnlwdG9jb21wYXJlJyxcbiAgICB3aWR0aDogMTI0LFxuICAgIGNlbGxSZW5kZXJlcjogQ2VsbFJlbmRlcmVyU3BhcmtsaW5lLFxuICAgIGNlbGxSZW5kZXJlclBhcmFtczoge1xuICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICBwcmljZTogdHJ1ZSxcbiAgICAgIHZvbHVtZTogdHJ1ZSxcbiAgICAgIHZvbHVtZURheXM6IDcsXG4gICAgfSxcbiAgICAvLyBOT1RFOiBkb2VzbnQgd29yayB5ZXQgdGhpcyBpcyB3aGF0IHRoZSBkb2NzIHNheSB0byBkb1xuICAgIHJlc2l6YWJsZTogZmFsc2UsXG4gIH0sXG5cbiAgLy9cbiAgLy8gVm9sdW1lXG4gIC8vXG4gIC8vIFRoZSBhbW91bnQgdGhlIGNvaW4gaGFzIGJlZW4gdHJhZGVkIGluIDI0IGhvdXJzIGFnYWluc3QgQUxMIGl0cyB0cmFkaW5nIHBhaXJzIGRpc3BsYXllZCBpbiBVU0RcbiAgLy9cbiAgdm9sdW1lMjRoVVNEOiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1UT1RBTFZPTFVNRTI0SFRPJyxcbiAgICBoZWFkZXJOYW1lOiAnVm9sdW1lIDI0aCcsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdUaGUgYW1vdW50IHRoZSBjb2luIGhhcyBiZWVuIHRyYWRlZCBpbiAyNCBob3VycyBhZ2FpbnN0IEFMTCBpdHMgdHJhZGluZyBwYWlycyBkaXNwbGF5ZWQgaW4gVVNEXFxuXFxuRGF0YSBTb3VyY2U6IENyeXB0b2NvbXBhcmUnLFxuICAgIHdpZHRoOiAxNTAsXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1YkRlZmF1bHRzJyxcbiAgICAgICdjcnlwdG9odWJOdW1lcmljJyxcbiAgICBdLFxuICAgIGNlbGxSZW5kZXJlcjogcGFydGlhbEFwcGxpY2F0aW9uKGNlbGxSZW5kZXJlckN1cnJlbmN5LCB3aW5kb3cucmVmcyksXG4gICAgY2VsbFJlbmRlcmVyUGFyYW1zOiB7XG4gICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgfSxcbiAgfSxcblxuICAvL1xuICAvLyBNYXJrZXRjYXBcbiAgLy9cbiAgbWFya2V0Y2FwVVNEOiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1NS1RDQVAnLFxuICAgIGhlYWRlck5hbWU6ICdNYXJrZXQgQ2FwJyxcbiAgICBoZWFkZXJDbGFzczogJ0NILWNvbCcsXG4gICAgaGVhZGVyVG9vbHRpcDogJ1RoZSBwcmljZSBpbiBVU0QgbXVsdGlwbGllZCBieSB0aGUgbnVtYmVyIG9mIGNvaW5zIG9yIHRva2Vuc1xcblxcbkRhdGEgU291cmNlOiBDcnlwdG9jb21wYXJlJyxcbiAgICB3aWR0aDogMTUwLFxuICAgIHR5cGU6IFtcbiAgICAgICdjcnlwdG9odWJEZWZhdWx0cycsXG4gICAgICAnY3J5cHRvaHViTnVtZXJpYycsXG4gICAgXSxcbiAgICBjZWxsUmVuZGVyZXI6IHBhcnRpYWxBcHBsaWNhdGlvbihjZWxsUmVuZGVyZXJDdXJyZW5jeSwgd2luZG93LnJlZnMpLFxuICAgIGNlbGxSZW5kZXJlclBhcmFtczoge1xuICAgICAgY3VycmVuY3k6ICdVU0QnLFxuICAgIH0sXG4gIH0sXG5cbiAgLy9cbiAgLy8gQ2lyY3VsYXRpbmcgU3VwcGx5XG4gIC8vXG4gIGNpcmN1bGF0aW5nU3VwcGx5OiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1TVVBQTFknLFxuICAgIGhlYWRlck5hbWU6ICdDaXJjdWxhdGluZyBTdXBwbHknLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnQ2lyY3VsYXRpbmcgc3VwcGx5XFxuXFxuRGF0YSBTb3VyY2U6IENyeXB0b2NvbXBhcmUnLFxuICAgIHdpZHRoOiAxNTAsXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1YkRlZmF1bHRzJyxcbiAgICAgICdjcnlwdG9odWJOdW1lcmljJyxcbiAgICBdLFxuICAgIGNlbGxSZW5kZXJlcjogY2VsbFJlbmRlcmVyTnVtYmVyLFxuICB9LFxuXG4gIC8vXG4gIC8vIFByb29mIHR5cGVcbiAgLy9cbiAgcHJvb2ZUeXBlOiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1Qcm9vZlR5cGUudmFsdWUnLFxuICAgIGhlYWRlck5hbWU6ICdQcm9vZicsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdQcm9vZiBUeXBlXFxuXFxuRGF0YSBTb3VyY2U6IENyeXB0b2NvbXBhcmUnLFxuICAgIHdpZHRoOiAxMjAsXG4gICAgdHlwZTogWydjcnlwdG9odWJUZXh0J10sXG4gIH0sXG5cbiAgLy9cbiAgLy8gQWxnb1xuICAvL1xuICBhbGdvOiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1BbGdvcml0aG0udmFsdWUnLFxuICAgIGhlYWRlck5hbWU6ICdBbGdvcml0aG0nLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnQWxnb3JpdGhtXFxuXFxuRGF0YSBTb3VyY2U6IENyeXB0b2NvbXBhcmUnLFxuICAgIHdpZHRoOiAxMjAsXG4gICAgdHlwZTogWydjcnlwdG9odWJUZXh0J10sXG4gIH0sXG5cbiAgLy9cbiAgLy8gSGFzaGVzIHBlciBzZWNvbmRcbiAgLy9cbiAgaGFzaGVzUGVyU2Vjb25kOiB7XG4gICAgZmllbGQ6ICdjYy10b3RhbC12b2wtZnVsbC1OZXRIYXNoZXNQZXJTZWNvbmQnLFxuICAgIGhlYWRlck5hbWU6ICdIYXNoZXMgcGVyL3MnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnTmV0IEhhc2hlcyBwZXIvc1xcblxcbkRhdGEgU291cmNlOiBDcnlwdG9jb21wYXJlJyxcbiAgICB3aWR0aDogMTgwLFxuICAgIGNvbHVtbkdyb3VwU2hvdzogJ2JvdGgnLFxuICAgIGNvbXBhcmF0b3I6IHNvcnROdW1iZXJzLFxuICAgIHR5cGU6IFtcbiAgICAgICdjcnlwdG9odWJEZWZhdWx0cycsXG4gICAgICAnY3J5cHRvaHViTnVtZXJpYycsXG4gICAgXSxcbiAgICBjZWxsUmVuZGVyZXI6IGNlbGxSZW5kZXJlck51bWJlcixcbiAgfSxcblxuICAvL1xuICAvLyBOdW1iZXIgb2YgRXhjaGFuZ2VzXG4gIC8vXG4gIG51bWJlck9mRXhjaGFuZ2VzOiB7XG4gICAgZmllbGQ6ICdjcnlwdG9odWItbnVtYmVyT2ZFeGNoYW5nZXMnLFxuICAgIGhlYWRlck5hbWU6ICdFeGNoYW5nZXMnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnTnVtYmVyIG9mIEV4Y2hhbmdlcyB0aGUgdG9rZW4gaXMgbGlzdGVkIG9uXFxuXFxuRGF0YSBTb3VyY2U6IEJpbmFyeU92ZXJkb3NlIC8gQ3J5cHRvY29tcGFyZScsXG4gICAgd2lkdGg6IDEwMCxcbiAgICBjb2x1bW5Hcm91cFNob3c6ICdjbG9zZWQnLFxuICAgIHR5cGU6IFtcbiAgICAgICdjcnlwdG9odWJEZWZhdWx0cycsXG4gICAgICAnY3J5cHRvaHViTnVtZXJpYycsXG4gICAgXSxcbiAgICBjZWxsU3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IDBcbiAgICB9LFxuICAgIGNlbGxSZW5kZXJlcjogY2VsbFJlbmRlcmVyRXhjaGFuZ2VzLFxuICAgIG9uQ2VsbENsaWNrZWQ6IGNlbGxPbkNsaWNrRXhjaGFuZ2VzLFxuICB9LFxuXG4gIC8vXG4gIC8vIE51bWJlciBvZiBwYWlyc1xuICAvL1xuICBudW1iZXJPZlBhaXJzOiB7XG4gICAgZmllbGQ6ICdjcnlwdG9odWItbnVtYmVyT2ZQYWlycycsXG4gICAgaGVhZGVyTmFtZTogJ1BhaXJzJyxcbiAgICBoZWFkZXJUb29sdGlwOiAnTnVtYmVyIG9mIHBhaXJzXFxuXFxuRGF0YSBTb3VyY2U6IEJpbmFyeU92ZXJkb3NlIC8gQ3J5cHRvY29tcGFyZScsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIHdpZHRoOiAxMDAsXG4gICAgY29sdW1uR3JvdXBTaG93OiAnY2xvc2VkJyxcbiAgICB0eXBlOiBbXG4gICAgICAnY3J5cHRvaHViRGVmYXVsdHMnLFxuICAgICAgJ2NyeXB0b2h1Yk51bWVyaWMnLFxuICAgIF0sXG4gICAgY2VsbFJlbmRlcmVyOiBjZWxsUmVuZGVyZXJOdW1iZXIsXG4gIH0sXG5cbiAgLy9cbiAgLy8gTnVtYmVyIG9mIEZpYXQgcGFpcnNcbiAgLy9cbiAgbnVtYmVyT2ZGaWF0UGFpcnM6IHtcbiAgICBmaWVsZDogJ2NyeXB0b2h1Yi1udW1iZXJPZkZpYXRQYWlycycsXG4gICAgaGVhZGVyTmFtZTogJ0ZpYXQgcGFpcnMnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdOdW1iZXIgb2YgZmlhdCBwYWlyc1xcblxcbkRhdGEgU291cmNlOiBCaW5hcnlPdmVyZG9zZSAvIENyeXB0b2NvbXBhcmUnLFxuICAgIGhlYWRlckNsYXNzOiAnQ0gtY29sJyxcbiAgICB3aWR0aDogMTAwLFxuICAgIGNvbHVtbkdyb3VwU2hvdzogJ2Nsb3NlZCcsXG4gICAgdHlwZTogW1xuICAgICAgJ2NyeXB0b2h1YkRlZmF1bHRzJyxcbiAgICAgICdjcnlwdG9odWJOdW1lcmljJyxcbiAgICBdLFxuICAgIGNlbGxSZW5kZXJlcjogY2VsbFJlbmRlcmVyTnVtYmVyLFxuICB9LFxuXG4gIC8vXG4gIC8vIE51bWJlciBvZiBGaWF0IGN1cnJlbmNpZXNcbiAgLy9cbiAgbnVtYmVyT2ZGaWF0Q3VycmVuY2llczoge1xuICAgIGZpZWxkOiAnY3J5cHRvaHViLW51bWJlck9mRmlhdEN1cnJlbmNpZXMnLFxuICAgIGhlYWRlck5hbWU6ICdGaWF0IEN1cnJlbmNpZXMnLFxuICAgIGhlYWRlclRvb2x0aXA6ICdOdW1iZXIgb2YgZmlhdCBDdXJyZW5jaWVzXFxuXFxuRGF0YSBTb3VyY2U6IEJpbmFyeU92ZXJkb3NlIC8gQ3J5cHRvY29tcGFyZScsXG4gICAgaGVhZGVyQ2xhc3M6ICdDSC1jb2wnLFxuICAgIHdpZHRoOiAxMDAsXG4gICAgY29sdW1uR3JvdXBTaG93OiAnY2xvc2VkJyxcbiAgICB0eXBlOiBbXG4gICAgICAnY3J5cHRvaHViRGVmYXVsdHMnLFxuICAgICAgJ2NyeXB0b2h1Yk51bWVyaWMnLFxuICAgIF0sXG4gICAgY2VsbFJlbmRlcmVyOiBjZWxsUmVuZGVyZXJOdW1iZXIsXG4gIH0sXG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbHVtbkRlZnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBERUZBVUxUIENPTkZJR1xuLy9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29sdW1uczogW1xuICAgIHtpZDogJ3Jvd0luZGV4J30sXG4gICAge2lkOiAnbmFtZSd9LFxuICAgIHtpZDogJ3NlY3RvcnMnfSxcbiAgICB7aWQ6ICdwcmljZVVTRCd9LFxuICAgIHtpZDogJ3ByaWNlQlRDJ30sXG4gICAge2lkOiAnYXRoVVNEJ30sXG4gICAge2lkOiAnY3ljbGVMb3dVU0QnfSxcbiAgICB7aWQ6ICdwZXJjZW50Q2hhbmdlMjRoVVNEJ30sXG4gICAge2lkOiAncGVyY2VudENoYW5nZTdEVVNEJ30sXG4gICAge2lkOiAnc3BhcmtsaW5lVVNEJ30sXG4gICAge2lkOiAndm9sdW1lMjRoVVNEJ30sXG4gICAge2lkOiAnbWFya2V0Y2FwVVNEJ30sXG4gICAge2lkOiAnY2lyY3VsYXRpbmdTdXBwbHknfSxcbiAgICB7aWQ6ICdwcm9vZlR5cGUnfSxcbiAgICB7aWQ6ICdhbGdvJ30sXG4gICAge2lkOiAnaGFzaGVzUGVyU2Vjb25kJ30sXG4gICAge2lkOiAnbnVtYmVyT2ZFeGNoYW5nZXMnfSxcbiAgICB7aWQ6ICdudW1iZXJPZlBhaXJzJ30sXG4gICAge2lkOiAnbnVtYmVyT2ZGaWF0UGFpcnMnfSxcbiAgICB7aWQ6ICdudW1iZXJPZkZpYXRDdXJyZW5jaWVzJ30sXG4gIF0sXG4gIHBvcnRmb2xpbzogW1xuICAgIHtcbiAgICAgIGlkOiAxMTgyLC8vIHVzZSBjcnlwdG9odWIgc3ltYm9sIElkXG4gICAgICBpbjogMTIxNDUsIC8vIHByaWNlIGluIHNhdG9jaGllc1xuICAgICAgdHlwZTogJ2xvbmcnLC8vIGRlZmF1bHQgdG8gbG9uZ1xuICAgICAgZXhjaGFuZ2U6ICdiaW5hbmNlJyAvLyBhdCBzb21lIHN0YWdlIHdlIHdpbGwgc3VwcG9ydCBwcmljZXMgZnJvbSBleGNoYW5nZWRcbiAgICB9XG4gIF0sXG4gIGZhdm91cml0ZXM6IFtcbiAgICAvLy4uLlxuICBdLFxuICBzb3J0OiB7XG4gICAgY29sdW1uOiAndm9sdW1lMjRoVVNEJyxcbiAgICBkaXJlY3Rpb246ICdkZXNjJ1xuICB9XG59XG4iLCIvL1xuLy8gVE9ETzogcmVmcz8gcmVhbGx5XG4vLyBDbGVhciB1cCB0aGlzIGR1bXBpbmcgZ3JvdW5kXG4vL1xuLy8gU3RhcnQgYWdhaW4uLi5cbi8vXG4vLyB3aW5kb3cuYm8gPSB7XG4vLyAgIGRhdGE6IHtcbi8vICAgICByb3c6IFtdLFxuLy8gICAgIGVtaXQ6ID8sXG4vLyAgICAgc3RvcmU6ID9cbi8vICAgfSxcbi8vICAgZnVuYzoge1xuLy8gICAgIHVwZGF0ZWRcbi8vICAgfSxcbi8vICAgY29tbW9uOiB7XG4vLyAgICAgZW1wdHlDZWxsVmFsdWU6ICctJyxcbi8vICAgfVxuLy8gfVxuLy9cblxuaW1wb3J0IHsgdGltZUFnbyB9ICAgICAgICAgICAgICAgICAgICBmcm9tICcuL2xpYnMvYm8tdXRpbHMtY2xpZW50Jztcblxud2luZG93LmluaXREYXRhID0gd2luZG93LmluaXREYXRhIHx8IHt9O1xud2luZG93LmluaXRTdG9yZSA9IHdpbmRvdy5pbml0U3RvcmUgfHwge307XG5cbndpbmRvdy5ibyA9IHtcbiAgZnVuYzoge30sXG4gIGluc3Q6IHt9XG59O1xuXG53aW5kb3cucmVmcyA9IHtcbiAgc3RvcmU6IFtdLCAvLyB0aGUgbGFzdCB2ZXJzaW9uIG9mIHRoZSBwYWNrZWQgZGF0YVxuICByb3dEYXRhOiBudWxsLFxuICBlbWl0RGF0YTogW10sXG59O1xuXG53aW5kb3cuY2ggPSB7XG4gIGVtcHR5Q2VsbFZhbHVlOiAnLScsXG4gIC4uLmluaXRTdG9yZVxufTtcblxud2luZG93LnRpbWVzdGFtcCA9IG51bGw7XG5cbi8qKlxuICpcbiAqIFVwZGF0ZWRcbiAqIEBwYXJhbSB7RGF0ZX0gd2hlblxuICogQHJldHVybiB2b2lkXG4gKlxuICovXG53aW5kb3cuYm8uZnVuYy51cGRhdGVkID0gZnVuY3Rpb24gKHdoZW4pIHtcblxuICBpZiAod2hlbiA9PT0gJ25vdycpIHdpbmRvdy50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB0aW1lID0gdGltZUFnbyh3aW5kb3cudGltZXN0YW1wKTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3VwZGF0ZWQnKS5pbm5lckhUTUwgPSBgVXBkYXRlZCAke3RpbWV9IGFnb2A7XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsb2JhbHMgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuL2dsb2JhbHMuanMnO1xuXG4vLyBCaW5hcnkgT3ZlcmRvc2UgUHJvamVjdHNcbmltcG9ydCB7IERhdGFUYWJsZSB9ICAgICAgICAgICAgICAgICAgZnJvbSAnLi9saWJzL2JvLWRhdGF0YWJsZS1jbGllbnQnO1xuXG4vLyBDcnlwdG9odWIgY2xhc3Nlc1xuaW1wb3J0IENlbGxJbnRlcmFjdGlvbnMgICAgICAgICAgICAgICBmcm9tICcuL2NsYXNzZXMvY2xhc3MtY2VsbC1pbnRlcmFjdGlvbnMuanMnO1xuXG4vLyBDcnlwdG9odWIgdXRpbCBmdW5jdGlvbnNcbmltcG9ydCBjb252ZXJ0V29ya2luZ0RhdGFUb1Jvd0RhdGEgICAgZnJvbSAnLi91dGlscy9jb252ZXJ0LXdvcmtpbmctZGF0YS10by1yb3ctZGF0YS5qcyc7XG5pbXBvcnQgdXBkYXRlT3ZlcnZpZXcgICAgICAgICAgICAgICAgIGZyb20gJy4vdXRpbHMvdmlldy11cGRhdGUtb3ZlcnZpZXcuanMnO1xuXG4vLyBhZy1ncmlkIGNvbmZpZ1xuaW1wb3J0IGdlbmVyYXRlQWdPcHRpb25zICAgICAgICAgICAgICBmcm9tICcuL2FnLWdyaWQtb3B0aW9ucy1nZW5lcmF0ZS5qcyc7XG5cbi8vIENTU1xuaW1wb3J0IHN0eWxlICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9zdHlsZXNoZWV0L2luZGV4LmNzcyc7XG5cbi8qKlxuICpcbiAqIEhhbmRsZSBkYXRhIGV2ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHZvaWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGRhdGFFbWl0SGFuZGxlcihkYXRhKSB7XG5cbiAgd2luZG93LmJvLmZ1bmMudXBkYXRlZCgnbm93Jyk7XG5cbiAgbGV0IG5ld1NvY2tldERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICBjb25zdCB0eXBlID0gbmV3U29ja2V0RGF0YS50eXBlO1xuICBuZXdTb2NrZXREYXRhID0gbmV3U29ja2V0RGF0YS5kYXRhO1xuXG4gIGlmICh0eXBlID09PSAnY2hhbmdlc2V0Jykge1xuICAgIHdpbmRvdy5EYXRhVGFibGUuY2hhbmdlc2V0cy5hcHBseUNoYW5nZXMod2luZG93LnJlZnMud29ya2luZ0RhdGEsIG5ld1NvY2tldERhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIHdpbmRvdy5yZWZzLndvcmtpbmdEYXRhID0gbmV3U29ja2V0RGF0YTtcbiAgfVxuXG4gIHdpbmRvdy5yZWZzLnJvd0RhdGEgPSBjb252ZXJ0V29ya2luZ0RhdGFUb1Jvd0RhdGEod2luZG93LnJlZnMud29ya2luZ0RhdGEpO1xuICB3aW5kb3cuYm8uYWdPcHRpb25zLmFwaS5zZXRSb3dEYXRhKHdpbmRvdy5yZWZzLnJvd0RhdGEpO1xuXG4gIHVwZGF0ZU92ZXJ2aWV3KHdpbmRvdy5yZWZzLndvcmtpbmdEYXRhKTtcblxufVxuXG4vKipcbiAqXG4gKiBIYW5kbGUgc3RvcmUgZXZlbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4gdm9pZFxuICpcbiAqL1xuZnVuY3Rpb24gc3RvcmVFbWl0SGFuZGxlcihkYXRhKSB7XG5cbiAgd2luZG93LmJvLmZ1bmMudXBkYXRlZCgnbm93Jyk7XG5cbiAgbGV0IG5ld1NvY2tldERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICBjb25zdCB0eXBlID0gbmV3U29ja2V0RGF0YS50eXBlO1xuICBuZXdTb2NrZXREYXRhID0gbmV3U29ja2V0RGF0YS5kYXRhO1xuXG4gIGlmICh0eXBlID09PSAnY2hhbmdlc2V0Jykge1xuICAgIHdpbmRvdy5EYXRhVGFibGUuY2hhbmdlc2V0cy5hcHBseUNoYW5nZXMod2luZG93LmNoLCBuZXdTb2NrZXREYXRhKTtcbiAgfVxuICBlbHNlIHtcbiAgICB3aW5kb3cuY2ggPSB7XG4gICAgICAuLi53aW5kb3cuY2gsXG4gICAgICAuLi5uZXdTb2NrZXREYXRhXG4gICAgfTtcbiAgfVxuXG59XG5cbndpbmRvdy5iby5pbnN0LmNlbGxJbnRlcmFjdGlvbnMgPSBuZXcgQ2VsbEludGVyYWN0aW9ucygpO1xuXG5jb25zdCBzb2NrZXQgPSBpbygpO1xuY29uc3QgYWdPcHRpb25zID0gZ2VuZXJhdGVBZ09wdGlvbnMoKTtcbmNvbnN0IGdyaWRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NoLWdyaWQnKTtcbmNvbnN0IGdyaWQgPSBuZXcgYWdHcmlkLkdyaWQoZ3JpZEVsZW1lbnQsIGFnT3B0aW9ucyk7XG5cbmlmICghZ3JpZCkgdGhyb3cgbmV3IEVycm9yKCdDYW50IGZpbmQgZ3JpZCcpO1xuXG53aW5kb3cuYm8uZnVuYy51cGRhdGVkKCdub3cnKTtcbnNldEludGVydmFsKHdpbmRvdy5iby5mdW5jLnVwZGF0ZWQsIDEwMDAgKiAxKTtcblxuc29ja2V0Lm9uKCdkYXRhJywgZGF0YUVtaXRIYW5kbGVyKTtcbnNvY2tldC5vbignc3RvcmUnLCBzdG9yZUVtaXRIYW5kbGVyKTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRhdGFUYWJsZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEYXRhVGFibGVcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5jbGllbnQuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi4vLi4vLi4vLi4vLi4vaG9tZS9hbGFuLy5udm0vdmVyc2lvbnMvbm9kZS92OS4xMS4xL2xpYi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwidmFyIGc7XFxuXFxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcXG5nID0gKGZ1bmN0aW9uKCkge1xcblxcdHJldHVybiB0aGlzO1xcbn0pKCk7XFxuXFxudHJ5IHtcXG5cXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcXG5cXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKTtcXG59IGNhdGNoIChlKSB7XFxuXFx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcXG5cXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXFxcIm9iamVjdFxcXCIpIGcgPSB3aW5kb3c7XFxufVxcblxcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGc7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGF0YVRhYmxlLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uLy4uLy4uLy4uLy4uL2hvbWUvYWxhbi8ubnZtL3ZlcnNpb25zL25vZGUvdjkuMTEuMS9saWIvbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XFxuXFx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XFxuXFx0XFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XFxuXFx0XFx0bW9kdWxlLnBhdGhzID0gW107XFxuXFx0XFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XFxuXFx0XFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFxcXCJsb2FkZWRcXFwiLCB7XFxuXFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBtb2R1bGUubDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXFxcImlkXFxcIiwge1xcblxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbW9kdWxlLmk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdFxcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xcblxcdH1cXG5cXHRyZXR1cm4gbW9kdWxlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGF0YVRhYmxlLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2RpZmYtanNvbi9kaXN0L2NoYW5nZXNldHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9kaWZmLWpzb24vZGlzdC9jaGFuZ2VzZXRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XFxuKGZ1bmN0aW9uKCkge1xcbiAgKGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgXywgYWRkS2V5VmFsdWUsIGFwcGx5QXJyYXlDaGFuZ2UsIGFwcGx5QnJhbmNoQ2hhbmdlLCBhcHBseUxlYWZDaGFuZ2UsIGNoYW5nZXNldCwgY29tcGFyZSwgY29tcGFyZUFycmF5LCBjb21wYXJlT2JqZWN0LCBjb21wYXJlUHJpbWl0aXZlcywgY29udmVydEFycmF5VG9PYmosIGV4cG9ydHMsIGdldEtleSwgZ2V0VHlwZU9mT2JqLCBpbmRleE9mSXRlbUluQXJyYXksIGlzRW1iZWRkZWRLZXksIG1vZGlmeUtleVZhbHVlLCBwYXJzZUVtYmVkZGVkS2V5VmFsdWUsIHJlbW92ZUtleSwgcmV2ZXJ0QXJyYXlDaGFuZ2UsIHJldmVydEJyYW5jaENoYW5nZSwgcmV2ZXJ0TGVhZkNoYW5nZTtcXG4gICAgY2hhbmdlc2V0ID0ge1xcbiAgICAgIFZFUlNJT046ICcwLjEuNCdcXG4gICAgfTtcXG4gICAgaWYgKCB0cnVlICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuICAgICAgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qc1xcXCIpO1xcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGNoYW5nZXNldDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLmNoYW5nZXNldCA9IGNoYW5nZXNldDtcXG4gICAgfVxcbiAgICBnZXRUeXBlT2ZPYmogPSBmdW5jdGlvbihvYmopIHtcXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcXG4gICAgICB9XFxuICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXlxcXFxbb2JqZWN0XFxcXHMoLiopXFxcXF0kLylbMV07XFxuICAgIH07XFxuICAgIGdldEtleSA9IGZ1bmN0aW9uKHBhdGgpIHtcXG4gICAgICB2YXIgcmVmO1xcbiAgICAgIHJldHVybiAocmVmID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdKSAhPSBudWxsID8gcmVmIDogJyRyb290JztcXG4gICAgfTtcXG4gICAgY29tcGFyZSA9IGZ1bmN0aW9uKG9sZE9iaiwgbmV3T2JqLCBwYXRoLCBlbWJlZGVkT2JqS2V5cywga2V5UGF0aCkge1xcbiAgICAgIHZhciBjaGFuZ2VzLCBkaWZmcywgdHlwZU9mTmV3T2JqLCB0eXBlT2ZPbGRPYmo7XFxuICAgICAgY2hhbmdlcyA9IFtdO1xcbiAgICAgIHR5cGVPZk9sZE9iaiA9IGdldFR5cGVPZk9iaihvbGRPYmopO1xcbiAgICAgIHR5cGVPZk5ld09iaiA9IGdldFR5cGVPZk9iaihuZXdPYmopO1xcbiAgICAgIGlmICh0eXBlT2ZPbGRPYmogIT09IHR5cGVPZk5ld09iaikge1xcbiAgICAgICAgY2hhbmdlcy5wdXNoKHtcXG4gICAgICAgICAgdHlwZTogY2hhbmdlc2V0Lm9wLlJFTU9WRSxcXG4gICAgICAgICAga2V5OiBnZXRLZXkocGF0aCksXFxuICAgICAgICAgIHZhbHVlOiBvbGRPYmpcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY2hhbmdlcy5wdXNoKHtcXG4gICAgICAgICAgdHlwZTogY2hhbmdlc2V0Lm9wLkFERCxcXG4gICAgICAgICAga2V5OiBnZXRLZXkocGF0aCksXFxuICAgICAgICAgIHZhbHVlOiBuZXdPYmpcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XFxuICAgICAgfVxcbiAgICAgIHN3aXRjaCAodHlwZU9mT2xkT2JqKSB7XFxuICAgICAgICBjYXNlICdEYXRlJzpcXG4gICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29uY2F0KGNvbXBhcmVQcmltaXRpdmVzKG9sZE9iai5nZXRUaW1lKCksIG5ld09iai5nZXRUaW1lKCksIHBhdGgpKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdPYmplY3QnOlxcbiAgICAgICAgICBkaWZmcyA9IGNvbXBhcmVPYmplY3Qob2xkT2JqLCBuZXdPYmosIHBhdGgsIGVtYmVkZWRPYmpLZXlzLCBrZXlQYXRoKTtcXG4gICAgICAgICAgaWYgKGRpZmZzLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdHlwZTogY2hhbmdlc2V0Lm9wLlVQREFURSxcXG4gICAgICAgICAgICAgICAga2V5OiBnZXRLZXkocGF0aCksXFxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGRpZmZzXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29uY2F0KGRpZmZzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdBcnJheSc6XFxuICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbmNhdChjb21wYXJlQXJyYXkob2xkT2JqLCBuZXdPYmosIHBhdGgsIGVtYmVkZWRPYmpLZXlzLCBrZXlQYXRoKSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAnRnVuY3Rpb24nOlxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbmNhdChjb21wYXJlUHJpbWl0aXZlcyhvbGRPYmosIG5ld09iaiwgcGF0aCkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY2hhbmdlcztcXG4gICAgfTtcXG4gICAgY29tcGFyZU9iamVjdCA9IGZ1bmN0aW9uKG9sZE9iaiwgbmV3T2JqLCBwYXRoLCBlbWJlZGVkT2JqS2V5cywga2V5UGF0aCwgc2tpcFBhdGgpIHtcXG4gICAgICB2YXIgYWRkZWRLZXlzLCBjaGFuZ2VzLCBkZWxldGVkS2V5cywgZGlmZnMsIGksIGludGVyc2VjdGlvbktleXMsIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgbmV3S2V5UGF0aCwgbmV3T2JqS2V5cywgbmV3UGF0aCwgb2xkT2JqS2V5cztcXG4gICAgICBpZiAoc2tpcFBhdGggPT0gbnVsbCkge1xcbiAgICAgICAgc2tpcFBhdGggPSBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgY2hhbmdlcyA9IFtdO1xcbiAgICAgIG9sZE9iaktleXMgPSBPYmplY3Qua2V5cyhvbGRPYmopO1xcbiAgICAgIG5ld09iaktleXMgPSBPYmplY3Qua2V5cyhuZXdPYmopO1xcbiAgICAgIGludGVyc2VjdGlvbktleXMgPSBfLmludGVyc2VjdGlvbihvbGRPYmpLZXlzLCBuZXdPYmpLZXlzKTtcXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpbnRlcnNlY3Rpb25LZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBrID0gaW50ZXJzZWN0aW9uS2V5c1tpXTtcXG4gICAgICAgIG5ld1BhdGggPSBwYXRoLmNvbmNhdChba10pO1xcbiAgICAgICAgbmV3S2V5UGF0aCA9IHNraXBQYXRoID8ga2V5UGF0aCA6IGtleVBhdGguY29uY2F0KFtrXSk7XFxuICAgICAgICBkaWZmcyA9IGNvbXBhcmUob2xkT2JqW2tdLCBuZXdPYmpba10sIG5ld1BhdGgsIGVtYmVkZWRPYmpLZXlzLCBuZXdLZXlQYXRoKTtcXG4gICAgICAgIGlmIChkaWZmcy5sZW5ndGgpIHtcXG4gICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29uY2F0KGRpZmZzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgYWRkZWRLZXlzID0gXy5kaWZmZXJlbmNlKG5ld09iaktleXMsIG9sZE9iaktleXMpO1xcbiAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBhZGRlZEtleXMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XFxuICAgICAgICBrID0gYWRkZWRLZXlzW2pdO1xcbiAgICAgICAgbmV3UGF0aCA9IHBhdGguY29uY2F0KFtrXSk7XFxuICAgICAgICBuZXdLZXlQYXRoID0gc2tpcFBhdGggPyBrZXlQYXRoIDoga2V5UGF0aC5jb25jYXQoW2tdKTtcXG4gICAgICAgIGNoYW5nZXMucHVzaCh7XFxuICAgICAgICAgIHR5cGU6IGNoYW5nZXNldC5vcC5BREQsXFxuICAgICAgICAgIGtleTogZ2V0S2V5KG5ld1BhdGgpLFxcbiAgICAgICAgICB2YWx1ZTogbmV3T2JqW2tdXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgZGVsZXRlZEtleXMgPSBfLmRpZmZlcmVuY2Uob2xkT2JqS2V5cywgbmV3T2JqS2V5cyk7XFxuICAgICAgZm9yIChsID0gMCwgbGVuMiA9IGRlbGV0ZWRLZXlzLmxlbmd0aDsgbCA8IGxlbjI7IGwrKykge1xcbiAgICAgICAgayA9IGRlbGV0ZWRLZXlzW2xdO1xcbiAgICAgICAgbmV3UGF0aCA9IHBhdGguY29uY2F0KFtrXSk7XFxuICAgICAgICBuZXdLZXlQYXRoID0gc2tpcFBhdGggPyBrZXlQYXRoIDoga2V5UGF0aC5jb25jYXQoW2tdKTtcXG4gICAgICAgIGNoYW5nZXMucHVzaCh7XFxuICAgICAgICAgIHR5cGU6IGNoYW5nZXNldC5vcC5SRU1PVkUsXFxuICAgICAgICAgIGtleTogZ2V0S2V5KG5ld1BhdGgpLFxcbiAgICAgICAgICB2YWx1ZTogb2xkT2JqW2tdXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNoYW5nZXM7XFxuICAgIH07XFxuICAgIGNvbXBhcmVBcnJheSA9IGZ1bmN0aW9uKG9sZE9iaiwgbmV3T2JqLCBwYXRoLCBlbWJlZGVkT2JqS2V5cywga2V5UGF0aCkge1xcbiAgICAgIHZhciBkaWZmcywgaW5kZXhlZE5ld09iaiwgaW5kZXhlZE9sZE9iaiwgcmVmLCB1bmlxS2V5O1xcbiAgICAgIHVuaXFLZXkgPSAocmVmID0gZW1iZWRlZE9iaktleXMgIT0gbnVsbCA/IGVtYmVkZWRPYmpLZXlzW2tleVBhdGguam9pbignLicpXSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICckaW5kZXgnO1xcbiAgICAgIGluZGV4ZWRPbGRPYmogPSBjb252ZXJ0QXJyYXlUb09iaihvbGRPYmosIHVuaXFLZXkpO1xcbiAgICAgIGluZGV4ZWROZXdPYmogPSBjb252ZXJ0QXJyYXlUb09iaihuZXdPYmosIHVuaXFLZXkpO1xcbiAgICAgIGRpZmZzID0gY29tcGFyZU9iamVjdChpbmRleGVkT2xkT2JqLCBpbmRleGVkTmV3T2JqLCBwYXRoLCBlbWJlZGVkT2JqS2V5cywga2V5UGF0aCwgdHJ1ZSk7XFxuICAgICAgaWYgKGRpZmZzLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIFtcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIHR5cGU6IGNoYW5nZXNldC5vcC5VUERBVEUsXFxuICAgICAgICAgICAga2V5OiBnZXRLZXkocGF0aCksXFxuICAgICAgICAgICAgZW1iZWRlZEtleTogdW5pcUtleSxcXG4gICAgICAgICAgICBjaGFuZ2VzOiBkaWZmc1xcbiAgICAgICAgICB9XFxuICAgICAgICBdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBjb252ZXJ0QXJyYXlUb09iaiA9IGZ1bmN0aW9uKGFyciwgdW5pcUtleSkge1xcbiAgICAgIHZhciBpbmRleCwgb2JqLCB2YWx1ZTtcXG4gICAgICBvYmogPSB7fTtcXG4gICAgICBpZiAodW5pcUtleSAhPT0gJyRpbmRleCcpIHtcXG4gICAgICAgIG9iaiA9IF8ua2V5QnkoYXJyLCB1bmlxS2V5KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm9yIChpbmRleCBpbiBhcnIpIHtcXG4gICAgICAgICAgdmFsdWUgPSBhcnJbaW5kZXhdO1xcbiAgICAgICAgICBvYmpbaW5kZXhdID0gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBvYmo7XFxuICAgIH07XFxuICAgIGNvbXBhcmVQcmltaXRpdmVzID0gZnVuY3Rpb24ob2xkT2JqLCBuZXdPYmosIHBhdGgpIHtcXG4gICAgICB2YXIgY2hhbmdlcztcXG4gICAgICBjaGFuZ2VzID0gW107XFxuICAgICAgaWYgKG9sZE9iaiAhPT0gbmV3T2JqKSB7XFxuICAgICAgICBjaGFuZ2VzLnB1c2goe1xcbiAgICAgICAgICB0eXBlOiBjaGFuZ2VzZXQub3AuVVBEQVRFLFxcbiAgICAgICAgICBrZXk6IGdldEtleShwYXRoKSxcXG4gICAgICAgICAgdmFsdWU6IG5ld09iaixcXG4gICAgICAgICAgb2xkVmFsdWU6IG9sZE9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjaGFuZ2VzO1xcbiAgICB9O1xcbiAgICBpc0VtYmVkZGVkS2V5ID0gZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgcmV0dXJuIC9cXFxcJC4qPS9naS50ZXN0KGtleSk7XFxuICAgIH07XFxuICAgIHJlbW92ZUtleSA9IGZ1bmN0aW9uKG9iaiwga2V5LCBlbWJlZGVkS2V5KSB7XFxuICAgICAgdmFyIGluZGV4O1xcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIGlmIChlbWJlZGVkS2V5ICE9PSAnJGluZGV4JyB8fCAhb2JqW2tleV0pIHtcXG4gICAgICAgICAgaW5kZXggPSBpbmRleE9mSXRlbUluQXJyYXkob2JqLCBlbWJlZGVkS2V5LCBrZXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG9iai5zcGxpY2UoaW5kZXggIT0gbnVsbCA/IGluZGV4IDoga2V5LCAxKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBvYmpba2V5XTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGluZGV4T2ZJdGVtSW5BcnJheSA9IGZ1bmN0aW9uKGFyciwga2V5LCB2YWx1ZSkge1xcbiAgICAgIHZhciBpbmRleCwgaXRlbTtcXG4gICAgICBmb3IgKGluZGV4IGluIGFycikge1xcbiAgICAgICAgaXRlbSA9IGFycltpbmRleF07XFxuICAgICAgICBpZiAoa2V5ID09PSAnJGluZGV4Jykge1xcbiAgICAgICAgICBpZiAoaXRlbSA9PT0gdmFsdWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbVtrZXldID09PSB2YWx1ZSkge1xcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAtMTtcXG4gICAgfTtcXG4gICAgbW9kaWZ5S2V5VmFsdWUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcXG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcXG4gICAgfTtcXG4gICAgYWRkS2V5VmFsdWUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XFxuICAgICAgICByZXR1cm4gb2JqLnB1c2godmFsdWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIHBhcnNlRW1iZWRkZWRLZXlWYWx1ZSA9IGZ1bmN0aW9uKGtleSkge1xcbiAgICAgIHZhciB1bmlxS2V5LCB2YWx1ZTtcXG4gICAgICB1bmlxS2V5ID0ga2V5LnN1YnN0cmluZygxLCBrZXkuaW5kZXhPZignPScpKTtcXG4gICAgICB2YWx1ZSA9IGtleS5zdWJzdHJpbmcoa2V5LmluZGV4T2YoJz0nKSArIDEpO1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICB1bmlxS2V5OiB1bmlxS2V5LFxcbiAgICAgICAgdmFsdWU6IHZhbHVlXFxuICAgICAgfTtcXG4gICAgfTtcXG4gICAgYXBwbHlMZWFmQ2hhbmdlID0gZnVuY3Rpb24ob2JqLCBjaGFuZ2UsIGVtYmVkZWRLZXkpIHtcXG4gICAgICB2YXIga2V5LCB0eXBlLCB2YWx1ZTtcXG4gICAgICB0eXBlID0gY2hhbmdlLnR5cGUsIGtleSA9IGNoYW5nZS5rZXksIHZhbHVlID0gY2hhbmdlLnZhbHVlO1xcbiAgICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgICAgY2FzZSBjaGFuZ2VzZXQub3AuQUREOlxcbiAgICAgICAgICByZXR1cm4gYWRkS2V5VmFsdWUob2JqLCBrZXksIHZhbHVlKTtcXG4gICAgICAgIGNhc2UgY2hhbmdlc2V0Lm9wLlVQREFURTpcXG4gICAgICAgICAgcmV0dXJuIG1vZGlmeUtleVZhbHVlKG9iaiwga2V5LCB2YWx1ZSk7XFxuICAgICAgICBjYXNlIGNoYW5nZXNldC5vcC5SRU1PVkU6XFxuICAgICAgICAgIHJldHVybiByZW1vdmVLZXkob2JqLCBrZXksIGVtYmVkZWRLZXkpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgYXBwbHlBcnJheUNoYW5nZSA9IGZ1bmN0aW9uKGFyciwgY2hhbmdlKSB7XFxuICAgICAgdmFyIGVsZW1lbnQsIGksIGxlbiwgcmVmLCByZXN1bHRzLCBzdWJjaGFuZ2U7XFxuICAgICAgcmVmID0gY2hhbmdlLmNoYW5nZXM7XFxuICAgICAgcmVzdWx0cyA9IFtdO1xcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgc3ViY2hhbmdlID0gcmVmW2ldO1xcbiAgICAgICAgaWYgKChzdWJjaGFuZ2UudmFsdWUgIT0gbnVsbCkgfHwgc3ViY2hhbmdlLnR5cGUgPT09IGNoYW5nZXNldC5vcC5SRU1PVkUpIHtcXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGFwcGx5TGVhZkNoYW5nZShhcnIsIHN1YmNoYW5nZSwgY2hhbmdlLmVtYmVkZWRLZXkpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChjaGFuZ2UuZW1iZWRlZEtleSA9PT0gJyRpbmRleCcpIHtcXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyWytzdWJjaGFuZ2Uua2V5XTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBlbGVtZW50ID0gXy5maW5kKGFyciwgZnVuY3Rpb24oZWwpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBlbFtjaGFuZ2UuZW1iZWRlZEtleV0gPT09IHN1YmNoYW5nZS5rZXk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGNoYW5nZXNldC5hcHBseUNoYW5nZXMoZWxlbWVudCwgc3ViY2hhbmdlLmNoYW5nZXMpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgIH07XFxuICAgIGFwcGx5QnJhbmNoQ2hhbmdlID0gZnVuY3Rpb24ob2JqLCBjaGFuZ2UpIHtcXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XFxuICAgICAgICByZXR1cm4gYXBwbHlBcnJheUNoYW5nZShvYmosIGNoYW5nZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjaGFuZ2VzZXQuYXBwbHlDaGFuZ2VzKG9iaiwgY2hhbmdlLmNoYW5nZXMpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgcmV2ZXJ0TGVhZkNoYW5nZSA9IGZ1bmN0aW9uKG9iaiwgY2hhbmdlLCBlbWJlZGVkS2V5KSB7XFxuICAgICAgdmFyIGtleSwgb2xkVmFsdWUsIHR5cGUsIHZhbHVlO1xcbiAgICAgIHR5cGUgPSBjaGFuZ2UudHlwZSwga2V5ID0gY2hhbmdlLmtleSwgdmFsdWUgPSBjaGFuZ2UudmFsdWUsIG9sZFZhbHVlID0gY2hhbmdlLm9sZFZhbHVlO1xcbiAgICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgICAgY2FzZSBjaGFuZ2VzZXQub3AuQUREOlxcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlS2V5KG9iaiwga2V5LCBlbWJlZGVkS2V5KTtcXG4gICAgICAgIGNhc2UgY2hhbmdlc2V0Lm9wLlVQREFURTpcXG4gICAgICAgICAgcmV0dXJuIG1vZGlmeUtleVZhbHVlKG9iaiwga2V5LCBvbGRWYWx1ZSk7XFxuICAgICAgICBjYXNlIGNoYW5nZXNldC5vcC5SRU1PVkU6XFxuICAgICAgICAgIHJldHVybiBhZGRLZXlWYWx1ZShvYmosIGtleSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgcmV2ZXJ0QXJyYXlDaGFuZ2UgPSBmdW5jdGlvbihhcnIsIGNoYW5nZSkge1xcbiAgICAgIHZhciBlbGVtZW50LCBpLCBsZW4sIHJlZiwgcmVzdWx0cywgc3ViY2hhbmdlO1xcbiAgICAgIHJlZiA9IGNoYW5nZS5jaGFuZ2VzO1xcbiAgICAgIHJlc3VsdHMgPSBbXTtcXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIHN1YmNoYW5nZSA9IHJlZltpXTtcXG4gICAgICAgIGlmICgoc3ViY2hhbmdlLnZhbHVlICE9IG51bGwpIHx8IHN1YmNoYW5nZS50eXBlID09PSBjaGFuZ2VzZXQub3AuUkVNT1ZFKSB7XFxuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXZlcnRMZWFmQ2hhbmdlKGFyciwgc3ViY2hhbmdlLCBjaGFuZ2UuZW1iZWRlZEtleSkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKGNoYW5nZS5lbWJlZGVkS2V5ID09PSAnJGluZGV4Jykge1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBhcnJbK3N1YmNoYW5nZS5rZXldO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBfLmZpbmQoYXJyLCBmdW5jdGlvbihlbCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGVsW2NoYW5nZS5lbWJlZGVkS2V5XSA9PT0gc3ViY2hhbmdlLmtleTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXN1bHRzLnB1c2goY2hhbmdlc2V0LnJldmVydENoYW5nZXMoZWxlbWVudCwgc3ViY2hhbmdlLmNoYW5nZXMpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgIH07XFxuICAgIHJldmVydEJyYW5jaENoYW5nZSA9IGZ1bmN0aW9uKG9iaiwgY2hhbmdlKSB7XFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIHJldmVydEFycmF5Q2hhbmdlKG9iaiwgY2hhbmdlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGNoYW5nZXNldC5yZXZlcnRDaGFuZ2VzKG9iaiwgY2hhbmdlLmNoYW5nZXMpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgY2hhbmdlc2V0LmRpZmYgPSBmdW5jdGlvbihvbGRPYmosIG5ld09iaiwgZW1iZWRlZE9iaktleXMpIHtcXG4gICAgICByZXR1cm4gY29tcGFyZShvbGRPYmosIG5ld09iaiwgW10sIGVtYmVkZWRPYmpLZXlzLCBbXSk7XFxuICAgIH07XFxuICAgIGNoYW5nZXNldC5hcHBseUNoYW5nZXMgPSBmdW5jdGlvbihvYmosIGNoYW5nZXNldHMpIHtcXG4gICAgICB2YXIgY2hhbmdlLCBpLCBsZW4sIHJlc3VsdHM7XFxuICAgICAgcmVzdWx0cyA9IFtdO1xcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoYW5nZXNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZXNldHNbaV07XFxuICAgICAgICBpZiAoKGNoYW5nZS52YWx1ZSAhPSBudWxsKSB8fCBjaGFuZ2UudHlwZSA9PT0gY2hhbmdlc2V0Lm9wLlJFTU9WRSkge1xcbiAgICAgICAgICByZXN1bHRzLnB1c2goYXBwbHlMZWFmQ2hhbmdlKG9iaiwgY2hhbmdlLCBjaGFuZ2UuZW1iZWRlZEtleSkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGFwcGx5QnJhbmNoQ2hhbmdlKG9ialtjaGFuZ2Uua2V5XSwgY2hhbmdlKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHRzO1xcbiAgICB9O1xcbiAgICBjaGFuZ2VzZXQucmV2ZXJ0Q2hhbmdlcyA9IGZ1bmN0aW9uKG9iaiwgY2hhbmdlc2V0KSB7XFxuICAgICAgdmFyIGNoYW5nZSwgaSwgbGVuLCByZWYsIHJlc3VsdHM7XFxuICAgICAgcmVmID0gY2hhbmdlc2V0LnJldmVyc2UoKTtcXG4gICAgICByZXN1bHRzID0gW107XFxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBjaGFuZ2UgPSByZWZbaV07XFxuICAgICAgICBpZiAoIWNoYW5nZS5jaGFuZ2VzKSB7XFxuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXZlcnRMZWFmQ2hhbmdlKG9iaiwgY2hhbmdlKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmV2ZXJ0QnJhbmNoQ2hhbmdlKG9ialtjaGFuZ2Uua2V5XSwgY2hhbmdlKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHRzO1xcbiAgICB9O1xcbiAgICBjaGFuZ2VzZXQub3AgPSB7XFxuICAgICAgUkVNT1ZFOiAncmVtb3ZlJyxcXG4gICAgICBBREQ6ICdhZGQnLFxcbiAgICAgIFVQREFURTogJ3VwZGF0ZSdcXG4gICAgfTtcXG4gIH0pKCk7XFxuXFxufSkuY2FsbCh0aGlzKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EYXRhVGFibGUvLi9ub2RlX21vZHVsZXMvZGlmZi1qc29uL2Rpc3QvY2hhbmdlc2V0cy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSkge3ZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKipcXG4gKiBAbGljZW5zZVxcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxcbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xcbiAqL1xcbjsoZnVuY3Rpb24oKSB7XFxuXFxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cXG4gIHZhciB1bmRlZmluZWQ7XFxuXFxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXFxuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjExJztcXG5cXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xcbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XFxuXFxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXFxuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xcblxcbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xcbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xcblxcbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xcbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XFxuXFxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXFxuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XFxuXFxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xcbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xcblxcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXFxuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xcblxcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXFxuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcXG5cXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xcbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xcblxcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xcbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcXG4gICAgICBIT1RfU1BBTiA9IDE2O1xcblxcbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXFxuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcXG5cXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xcbiAgdmFyIElORklOSVRZID0gMSAvIDAsXFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcXG4gICAgICBOQU4gPSAwIC8gMDtcXG5cXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXFxuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcXG5cXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXFxuICB2YXIgd3JhcEZsYWdzID0gW1xcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXFxuICBdO1xcblxcbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xcbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xcblxcbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XFxuXFxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xcbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcXFxiX19wIFxcXFwrPSAnJzsvZyxcXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcXFxiKF9fcCBcXFxcKz0pICcnIFxcXFwrL2csXFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXFxcKC4qP1xcXFwpfFxcXFxiX190XFxcXCkpIFxcXFwrXFxcXG4nJzsvZztcXG5cXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XFxcIiddL2csXFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xcblxcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcXFxzXFxcXFNdKz8pJT4vZyxcXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXFxcc1xcXFxTXSs/KSU+L2csXFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcXFxzXFxcXFNdKz8pJT4vZztcXG5cXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFxcXC58XFxcXFsoPzpbXltcXFxcXV0qfChbXFxcIiddKSg/Oig/IVxcXFwxKVteXFxcXFxcXFxdfFxcXFxcXFxcLikqP1xcXFwxKVxcXFxdLyxcXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXFxcdyokLyxcXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXFxcXV0rfFxcXFxbKD86KC0/XFxcXGQrKD86XFxcXC5cXFxcZCspPyl8KFtcXFwiJ10pKCg/Oig/IVxcXFwyKVteXFxcXFxcXFxdfFxcXFxcXFxcLikqPylcXFxcMilcXFxcXXwoPz0oPzpcXFxcLnxcXFxcW1xcXFxdKSg/OlxcXFwufFxcXFxbXFxcXF18JCkpL2c7XFxuXFxuICAvKipcXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxcbiAgICovXFxuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXFxcXF4kLiorPygpW1xcXFxde318XS9nLFxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcXG5cXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXFxuICB2YXIgcmVUcmltID0gL15cXFxccyt8XFxcXHMrJC9nLFxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXFxccysvLFxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXFxccyskLztcXG5cXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xcbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFxcXHsoPzpcXFxcblxcXFwvXFxcXCogXFxcXFt3cmFwcGVkIHdpdGggLitcXFxcXSBcXFxcKlxcXFwvKT9cXFxcbj8vLFxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFxcXHtcXFxcblxcXFwvXFxcXCogXFxcXFt3cmFwcGVkIHdpdGggKC4rKVxcXFxdIFxcXFwqLyxcXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XFxuXFxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHg3Zl0rL2c7XFxuXFxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXFxcXFwoXFxcXFxcXFwpPy9nO1xcblxcbiAgLyoqXFxuICAgKiBVc2VkIHRvIG1hdGNoXFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxcbiAgICovXFxuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcXFwkXFxcXHsoW15cXFxcXFxcXH1dKig/OlxcXFxcXFxcLlteXFxcXFxcXFx9XSopKilcXFxcfS9nO1xcblxcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXFxuICB2YXIgcmVGbGFncyA9IC9cXFxcdyokLztcXG5cXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXFxuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xcblxcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xcbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XFxuXFxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXFxuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXFxdJC87XFxuXFxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xcblxcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xcbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxcXGQqKSQvO1xcblxcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXFxuICB2YXIgcmVMYXRpbiA9IC9bXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGY2XFxcXHhmOC1cXFxceGZmXFxcXHUwMTAwLVxcXFx1MDE3Zl0vZztcXG5cXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XFxuXFxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXFxuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXFxcXFxdL2c7XFxuXFxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXFxuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcXFxcXHVkODAwLVxcXFxcXFxcdWRmZmYnLFxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFxcXFxcdTAzMDAtXFxcXFxcXFx1MDM2ZicsXFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFxcXFxcdWZlMjAtXFxcXFxcXFx1ZmUyZicsXFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcXFxcXHUyMGQwLVxcXFxcXFxcdTIwZmYnLFxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcXFxcXHUyNzAwLVxcXFxcXFxcdTI3YmYnLFxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxcXFxcXHhkZi1cXFxcXFxcXHhmNlxcXFxcXFxceGY4LVxcXFxcXFxceGZmJyxcXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFxcXFxceGFjXFxcXFxcXFx4YjFcXFxcXFxcXHhkN1xcXFxcXFxceGY3JyxcXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxcXFxcXHgwMC1cXFxcXFxcXHgyZlxcXFxcXFxceDNhLVxcXFxcXFxceDQwXFxcXFxcXFx4NWItXFxcXFxcXFx4NjBcXFxcXFxcXHg3Yi1cXFxcXFxcXHhiZicsXFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFxcXFxcdTIwMDAtXFxcXFxcXFx1MjA2ZicsXFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcXFxcXHRcXFxcXFxcXHgwYlxcXFxcXFxcZlxcXFxcXFxceGEwXFxcXFxcXFx1ZmVmZlxcXFxcXFxcblxcXFxcXFxcclxcXFxcXFxcdTIwMjhcXFxcXFxcXHUyMDI5XFxcXFxcXFx1MTY4MFxcXFxcXFxcdTE4MGVcXFxcXFxcXHUyMDAwXFxcXFxcXFx1MjAwMVxcXFxcXFxcdTIwMDJcXFxcXFxcXHUyMDAzXFxcXFxcXFx1MjAwNFxcXFxcXFxcdTIwMDVcXFxcXFxcXHUyMDA2XFxcXFxcXFx1MjAwN1xcXFxcXFxcdTIwMDhcXFxcXFxcXHUyMDA5XFxcXFxcXFx1MjAwYVxcXFxcXFxcdTIwMmZcXFxcXFxcXHUyMDVmXFxcXFxcXFx1MzAwMCcsXFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFxcXFxceGMwLVxcXFxcXFxceGQ2XFxcXFxcXFx4ZDgtXFxcXFxcXFx4ZGUnLFxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXFxcXFx1ZmUwZVxcXFxcXFxcdWZlMGYnLFxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcXG5cXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cXG4gIHZhciByc0Fwb3MgPSBcXFwiWydcXFxcdTIwMTldXFxcIixcXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxcXFxcZCsnLFxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxcbiAgICAgIHJzRml0eiA9ICdcXFxcXFxcXHVkODNjW1xcXFxcXFxcdWRmZmItXFxcXFxcXFx1ZGZmZl0nLFxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFxcXFxcdWQ4M2NbXFxcXFxcXFx1ZGRlNi1cXFxcXFxcXHVkZGZmXSl7Mn0nLFxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFxcXFxcdWQ4MDAtXFxcXFxcXFx1ZGJmZl1bXFxcXFxcXFx1ZGMwMC1cXFxcXFxcXHVkZmZmXScsXFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcXG4gICAgICByc1pXSiA9ICdcXFxcXFxcXHUyMDBkJztcXG5cXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xcbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXFxcXFxkdGgpKD89XFxcXFxcXFxifFtBLVpfXSknLFxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXFxcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxcXFxcZFRIKSg/PVxcXFxcXFxcYnxbYS16X10pJyxcXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XFxuXFxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xcblxcbiAgLyoqXFxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxcbiAgICovXFxuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcXG5cXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXFxuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XFxuXFxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xcbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcXG4gICAgcnNPcmRVcHBlcixcXG4gICAgcnNPcmRMb3dlcixcXG4gICAgcnNEaWdpdHMsXFxuICAgIHJzRW1vamlcXG4gIF0uam9pbignfCcpLCAnZycpO1xcblxcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXFxuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcXG5cXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XFxuXFxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXFxuICB2YXIgY29udGV4dFByb3BzID0gW1xcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXFxuICBdO1xcblxcbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcXG5cXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxcbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxcbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XFxuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XFxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xcblxcbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XFxuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxcbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XFxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XFxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XFxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxcbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxcbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cXG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XFxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxcbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxcbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcXG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XFxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XFxuXFxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXFxuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXFxuICAgICdcXFxceGMwJzogJ0EnLCAgJ1xcXFx4YzEnOiAnQScsICdcXFxceGMyJzogJ0EnLCAnXFxcXHhjMyc6ICdBJywgJ1xcXFx4YzQnOiAnQScsICdcXFxceGM1JzogJ0EnLFxcbiAgICAnXFxcXHhlMCc6ICdhJywgICdcXFxceGUxJzogJ2EnLCAnXFxcXHhlMic6ICdhJywgJ1xcXFx4ZTMnOiAnYScsICdcXFxceGU0JzogJ2EnLCAnXFxcXHhlNSc6ICdhJyxcXG4gICAgJ1xcXFx4YzcnOiAnQycsICAnXFxcXHhlNyc6ICdjJyxcXG4gICAgJ1xcXFx4ZDAnOiAnRCcsICAnXFxcXHhmMCc6ICdkJyxcXG4gICAgJ1xcXFx4YzgnOiAnRScsICAnXFxcXHhjOSc6ICdFJywgJ1xcXFx4Y2EnOiAnRScsICdcXFxceGNiJzogJ0UnLFxcbiAgICAnXFxcXHhlOCc6ICdlJywgICdcXFxceGU5JzogJ2UnLCAnXFxcXHhlYSc6ICdlJywgJ1xcXFx4ZWInOiAnZScsXFxuICAgICdcXFxceGNjJzogJ0knLCAgJ1xcXFx4Y2QnOiAnSScsICdcXFxceGNlJzogJ0knLCAnXFxcXHhjZic6ICdJJyxcXG4gICAgJ1xcXFx4ZWMnOiAnaScsICAnXFxcXHhlZCc6ICdpJywgJ1xcXFx4ZWUnOiAnaScsICdcXFxceGVmJzogJ2knLFxcbiAgICAnXFxcXHhkMSc6ICdOJywgICdcXFxceGYxJzogJ24nLFxcbiAgICAnXFxcXHhkMic6ICdPJywgICdcXFxceGQzJzogJ08nLCAnXFxcXHhkNCc6ICdPJywgJ1xcXFx4ZDUnOiAnTycsICdcXFxceGQ2JzogJ08nLCAnXFxcXHhkOCc6ICdPJyxcXG4gICAgJ1xcXFx4ZjInOiAnbycsICAnXFxcXHhmMyc6ICdvJywgJ1xcXFx4ZjQnOiAnbycsICdcXFxceGY1JzogJ28nLCAnXFxcXHhmNic6ICdvJywgJ1xcXFx4ZjgnOiAnbycsXFxuICAgICdcXFxceGQ5JzogJ1UnLCAgJ1xcXFx4ZGEnOiAnVScsICdcXFxceGRiJzogJ1UnLCAnXFxcXHhkYyc6ICdVJyxcXG4gICAgJ1xcXFx4ZjknOiAndScsICAnXFxcXHhmYSc6ICd1JywgJ1xcXFx4ZmInOiAndScsICdcXFxceGZjJzogJ3UnLFxcbiAgICAnXFxcXHhkZCc6ICdZJywgICdcXFxceGZkJzogJ3knLCAnXFxcXHhmZic6ICd5JyxcXG4gICAgJ1xcXFx4YzYnOiAnQWUnLCAnXFxcXHhlNic6ICdhZScsXFxuICAgICdcXFxceGRlJzogJ1RoJywgJ1xcXFx4ZmUnOiAndGgnLFxcbiAgICAnXFxcXHhkZic6ICdzcycsXFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXFxuICAgICdcXFxcdTAxMDAnOiAnQScsICAnXFxcXHUwMTAyJzogJ0EnLCAnXFxcXHUwMTA0JzogJ0EnLFxcbiAgICAnXFxcXHUwMTAxJzogJ2EnLCAgJ1xcXFx1MDEwMyc6ICdhJywgJ1xcXFx1MDEwNSc6ICdhJyxcXG4gICAgJ1xcXFx1MDEwNic6ICdDJywgICdcXFxcdTAxMDgnOiAnQycsICdcXFxcdTAxMGEnOiAnQycsICdcXFxcdTAxMGMnOiAnQycsXFxuICAgICdcXFxcdTAxMDcnOiAnYycsICAnXFxcXHUwMTA5JzogJ2MnLCAnXFxcXHUwMTBiJzogJ2MnLCAnXFxcXHUwMTBkJzogJ2MnLFxcbiAgICAnXFxcXHUwMTBlJzogJ0QnLCAgJ1xcXFx1MDExMCc6ICdEJywgJ1xcXFx1MDEwZic6ICdkJywgJ1xcXFx1MDExMSc6ICdkJyxcXG4gICAgJ1xcXFx1MDExMic6ICdFJywgICdcXFxcdTAxMTQnOiAnRScsICdcXFxcdTAxMTYnOiAnRScsICdcXFxcdTAxMTgnOiAnRScsICdcXFxcdTAxMWEnOiAnRScsXFxuICAgICdcXFxcdTAxMTMnOiAnZScsICAnXFxcXHUwMTE1JzogJ2UnLCAnXFxcXHUwMTE3JzogJ2UnLCAnXFxcXHUwMTE5JzogJ2UnLCAnXFxcXHUwMTFiJzogJ2UnLFxcbiAgICAnXFxcXHUwMTFjJzogJ0cnLCAgJ1xcXFx1MDExZSc6ICdHJywgJ1xcXFx1MDEyMCc6ICdHJywgJ1xcXFx1MDEyMic6ICdHJyxcXG4gICAgJ1xcXFx1MDExZCc6ICdnJywgICdcXFxcdTAxMWYnOiAnZycsICdcXFxcdTAxMjEnOiAnZycsICdcXFxcdTAxMjMnOiAnZycsXFxuICAgICdcXFxcdTAxMjQnOiAnSCcsICAnXFxcXHUwMTI2JzogJ0gnLCAnXFxcXHUwMTI1JzogJ2gnLCAnXFxcXHUwMTI3JzogJ2gnLFxcbiAgICAnXFxcXHUwMTI4JzogJ0knLCAgJ1xcXFx1MDEyYSc6ICdJJywgJ1xcXFx1MDEyYyc6ICdJJywgJ1xcXFx1MDEyZSc6ICdJJywgJ1xcXFx1MDEzMCc6ICdJJyxcXG4gICAgJ1xcXFx1MDEyOSc6ICdpJywgICdcXFxcdTAxMmInOiAnaScsICdcXFxcdTAxMmQnOiAnaScsICdcXFxcdTAxMmYnOiAnaScsICdcXFxcdTAxMzEnOiAnaScsXFxuICAgICdcXFxcdTAxMzQnOiAnSicsICAnXFxcXHUwMTM1JzogJ2onLFxcbiAgICAnXFxcXHUwMTM2JzogJ0snLCAgJ1xcXFx1MDEzNyc6ICdrJywgJ1xcXFx1MDEzOCc6ICdrJyxcXG4gICAgJ1xcXFx1MDEzOSc6ICdMJywgICdcXFxcdTAxM2InOiAnTCcsICdcXFxcdTAxM2QnOiAnTCcsICdcXFxcdTAxM2YnOiAnTCcsICdcXFxcdTAxNDEnOiAnTCcsXFxuICAgICdcXFxcdTAxM2EnOiAnbCcsICAnXFxcXHUwMTNjJzogJ2wnLCAnXFxcXHUwMTNlJzogJ2wnLCAnXFxcXHUwMTQwJzogJ2wnLCAnXFxcXHUwMTQyJzogJ2wnLFxcbiAgICAnXFxcXHUwMTQzJzogJ04nLCAgJ1xcXFx1MDE0NSc6ICdOJywgJ1xcXFx1MDE0Nyc6ICdOJywgJ1xcXFx1MDE0YSc6ICdOJyxcXG4gICAgJ1xcXFx1MDE0NCc6ICduJywgICdcXFxcdTAxNDYnOiAnbicsICdcXFxcdTAxNDgnOiAnbicsICdcXFxcdTAxNGInOiAnbicsXFxuICAgICdcXFxcdTAxNGMnOiAnTycsICAnXFxcXHUwMTRlJzogJ08nLCAnXFxcXHUwMTUwJzogJ08nLFxcbiAgICAnXFxcXHUwMTRkJzogJ28nLCAgJ1xcXFx1MDE0Zic6ICdvJywgJ1xcXFx1MDE1MSc6ICdvJyxcXG4gICAgJ1xcXFx1MDE1NCc6ICdSJywgICdcXFxcdTAxNTYnOiAnUicsICdcXFxcdTAxNTgnOiAnUicsXFxuICAgICdcXFxcdTAxNTUnOiAncicsICAnXFxcXHUwMTU3JzogJ3InLCAnXFxcXHUwMTU5JzogJ3InLFxcbiAgICAnXFxcXHUwMTVhJzogJ1MnLCAgJ1xcXFx1MDE1Yyc6ICdTJywgJ1xcXFx1MDE1ZSc6ICdTJywgJ1xcXFx1MDE2MCc6ICdTJyxcXG4gICAgJ1xcXFx1MDE1Yic6ICdzJywgICdcXFxcdTAxNWQnOiAncycsICdcXFxcdTAxNWYnOiAncycsICdcXFxcdTAxNjEnOiAncycsXFxuICAgICdcXFxcdTAxNjInOiAnVCcsICAnXFxcXHUwMTY0JzogJ1QnLCAnXFxcXHUwMTY2JzogJ1QnLFxcbiAgICAnXFxcXHUwMTYzJzogJ3QnLCAgJ1xcXFx1MDE2NSc6ICd0JywgJ1xcXFx1MDE2Nyc6ICd0JyxcXG4gICAgJ1xcXFx1MDE2OCc6ICdVJywgICdcXFxcdTAxNmEnOiAnVScsICdcXFxcdTAxNmMnOiAnVScsICdcXFxcdTAxNmUnOiAnVScsICdcXFxcdTAxNzAnOiAnVScsICdcXFxcdTAxNzInOiAnVScsXFxuICAgICdcXFxcdTAxNjknOiAndScsICAnXFxcXHUwMTZiJzogJ3UnLCAnXFxcXHUwMTZkJzogJ3UnLCAnXFxcXHUwMTZmJzogJ3UnLCAnXFxcXHUwMTcxJzogJ3UnLCAnXFxcXHUwMTczJzogJ3UnLFxcbiAgICAnXFxcXHUwMTc0JzogJ1cnLCAgJ1xcXFx1MDE3NSc6ICd3JyxcXG4gICAgJ1xcXFx1MDE3Nic6ICdZJywgICdcXFxcdTAxNzcnOiAneScsICdcXFxcdTAxNzgnOiAnWScsXFxuICAgICdcXFxcdTAxNzknOiAnWicsICAnXFxcXHUwMTdiJzogJ1onLCAnXFxcXHUwMTdkJzogJ1onLFxcbiAgICAnXFxcXHUwMTdhJzogJ3onLCAgJ1xcXFx1MDE3Yyc6ICd6JywgJ1xcXFx1MDE3ZSc6ICd6JyxcXG4gICAgJ1xcXFx1MDEzMic6ICdJSicsICdcXFxcdTAxMzMnOiAnaWonLFxcbiAgICAnXFxcXHUwMTUyJzogJ09lJywgJ1xcXFx1MDE1Myc6ICdvZScsXFxuICAgICdcXFxcdTAxNDknOiBcXFwiJ25cXFwiLCAnXFxcXHUwMTdmJzogJ3MnXFxuICB9O1xcblxcbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcXG4gICAgJyYnOiAnJmFtcDsnLFxcbiAgICAnPCc6ICcmbHQ7JyxcXG4gICAgJz4nOiAnJmd0OycsXFxuICAgICdcXFwiJzogJyZxdW90OycsXFxuICAgIFxcXCInXFxcIjogJyYjMzk7J1xcbiAgfTtcXG5cXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXFxuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcXG4gICAgJyZhbXA7JzogJyYnLFxcbiAgICAnJmx0Oyc6ICc8JyxcXG4gICAgJyZndDsnOiAnPicsXFxuICAgICcmcXVvdDsnOiAnXFxcIicsXFxuICAgICcmIzM5Oyc6IFxcXCInXFxcIlxcbiAgfTtcXG5cXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xcbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XFxuICAgICdcXFxcXFxcXCc6ICdcXFxcXFxcXCcsXFxuICAgIFxcXCInXFxcIjogXFxcIidcXFwiLFxcbiAgICAnXFxcXG4nOiAnbicsXFxuICAgICdcXFxccic6ICdyJyxcXG4gICAgJ1xcXFx1MjAyOCc6ICd1MjAyOCcsXFxuICAgICdcXFxcdTIwMjknOiAndTIwMjknXFxuICB9O1xcblxcbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XFxuXFxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xcblxcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xcblxcbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXFxuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5cXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXFxuICB2YXIgZnJlZUV4cG9ydHMgPSAgdHJ1ZSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XFxuXFxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXFxuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xcblxcbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xcblxcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXFxuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcXG5cXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xcbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xcbiAgICB0cnkge1xcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxcbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xcblxcbiAgICAgIGlmICh0eXBlcykge1xcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxcbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcXG4gICAgfSBjYXRjaCAoZSkge31cXG4gIH0oKSk7XFxuXFxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xcbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XFxuXFxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gIC8qKlxcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxcbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcXG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcXG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XFxuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcXG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcXG4gICAgfVxcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XFxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXFxuICAgKiAgZWxzZSBgZmFsc2VgLlxcbiAgICovXFxuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxcbiAgICAgICAgcmVzdWx0ID0gW107XFxuXFxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcXG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XFxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcXG4gICAqIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcXG5cXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXFxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxcbiAgICovXFxuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcXG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xcbiAgICB9XFxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xcbiAgICB9XFxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXFxuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXFxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XFxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcXG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcXG4gICAgfVxcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcXG4gICAgfVxcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcXG4gICAqIHNob3J0aGFuZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxcbiAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cXG4gICAqL1xcbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XFxuXFxuICAvKipcXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxcbiAgICovXFxuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XFxuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxcbiAgICovXFxuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcXG4gICAgdmFyIHJlc3VsdDtcXG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcXG4gICAgICAgIHJlc3VsdCA9IGtleTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcXG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XFxuXFxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XFxuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcXG4gICAgICAgIHJldHVybiBpbmRleDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIC0xO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XFxuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XFxuXFxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiBpbmRleDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIC0xO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxcbiAgICovXFxuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcXG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxcbiAgICovXFxuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcXG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxcbiAgICovXFxuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxcbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXFxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXFxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XFxuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXFxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXFxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXFxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXFxuICAgKiB2YWx1ZXMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XFxuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XFxuXFxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXFxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcXG4gICAgdmFyIHJlc3VsdCxcXG4gICAgICAgIGluZGV4ID0gLTEsXFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XFxuXFxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxcbiAgICovXFxuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcXG5cXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XFxuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XFxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxcbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXFxuICAgKiBvZiBgcHJvcHNgLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxcbiAgICovXFxuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XFxuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXFxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxcbiAgICovXFxuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cXG4gICAgcmV0dXJuIGluZGV4O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XFxuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cXG4gICAgcmV0dXJuIGluZGV4O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxcbiAgICAgICAgcmVzdWx0ID0gMDtcXG5cXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XFxuICAgICAgICArK3Jlc3VsdDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXFxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cXG4gICAqL1xcbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XFxuXFxuICAvKipcXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxcbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXFxuICAgKi9cXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcXG5cXG4gIC8qKlxcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxcbiAgICovXFxuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xcbiAgICByZXR1cm4gJ1xcXFxcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXFxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XFxuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxcbiAgICovXFxuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxcbiAgICovXFxuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcXG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XFxuICAgIHZhciBkYXRhLFxcbiAgICAgICAgcmVzdWx0ID0gW107XFxuXFxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcXG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxcbiAgICovXFxuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcXG5cXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcXG4gICAgfSk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAqL1xcbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXFxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxcbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xcbiAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgIHJlc0luZGV4ID0gMCxcXG4gICAgICAgIHJlc3VsdCA9IFtdO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcXG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XFxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cXG4gICAqL1xcbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XFxuXFxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cXG4gICAqL1xcbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcXG4gICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XFxuXFxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XFxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW5kZXg7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiAtMTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcXG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxcbiAgICovXFxuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW5kZXg7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBpbmRleDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XFxuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcXG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXFxuICAgKi9cXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XFxuXFxuICAvKipcXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxcbiAgICpcXG4gICAqIEBwcml2YXRlXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxcbiAgICovXFxuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcXG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xcbiAgICAgICsrcmVzdWx0O1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XFxuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcXG4gIH1cXG5cXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgLyoqXFxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXFxuICAgKlxcbiAgICogQHN0YXRpY1xcbiAgICogQG1lbWJlck9mIF9cXG4gICAqIEBzaW5jZSAxLjEuMFxcbiAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXFxuICAgKiBAZXhhbXBsZVxcbiAgICpcXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XFxuICAgKlxcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XFxuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcXG4gICAqXFxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xcbiAgICogLy8gPT4gdHJ1ZVxcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcXG4gICAqIC8vID0+IGZhbHNlXFxuICAgKlxcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XFxuICAgKiAvLyA9PiBmYWxzZVxcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XFxuICAgKiAvLyA9PiB0cnVlXFxuICAgKlxcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxcbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcXG4gICAqL1xcbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xcblxcbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XFxuXFxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XFxuXFxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcXG5cXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xcbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xcblxcbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XFxuXFxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXFxuICAgIHZhciBpZENvdW50ZXIgPSAwO1xcblxcbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xcbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcXG4gICAgfSgpKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXFxuICAgICAqIG9mIHZhbHVlcy5cXG4gICAgICovXFxuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xcblxcbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXFxuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcXG5cXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XFxuXFxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXFxuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXFxuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXFxcXFwkJicpXFxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFxcXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXFxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXFxuICAgICk7XFxuXFxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xcbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XFxuXFxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcXG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XFxuICAgICAgICByZXR1cm4gZnVuYztcXG4gICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICB9KCkpO1xcblxcbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xcblxcbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXFxuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcXG5cXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xcbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcXG5cXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXFxuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcXG5cXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXFxuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcXG5cXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcXG5cXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXFxuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXFxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cXG4gICAgICpcXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXFxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxcbiAgICAgKlxcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXFxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcXG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcXG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxcbiAgICAgKlxcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXFxuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxcbiAgICAgKlxcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXFxuICAgICAqXFxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcXG4gICAgICpcXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcXG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcXG4gICAgICpcXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcXG4gICAgICpcXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcXG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcXG4gICAgICpcXG4gICAgICogQG5hbWUgX1xcbiAgICAgKiBAY29uc3RydWN0b3JcXG4gICAgICogQGNhdGVnb3J5IFNlcVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xcbiAgICAgKiAgIHJldHVybiBuICogbjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcXG4gICAgICpcXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXFxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcXG4gICAgICogLy8gPT4gNlxcbiAgICAgKlxcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xcbiAgICAgKlxcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcXG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcXG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gICAgICovXFxuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XFxuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xcbiAgICAgICAgICByZXR1cm4ge307XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XFxuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xcbiAgICAgICAgfVxcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XFxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9O1xcbiAgICB9KCkpO1xcblxcbiAgICAvKipcXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XFxuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcXG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XFxuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXFxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICAgKi9cXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXFxuICAgICAgICpcXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXFxuICAgICAgICogQHR5cGUge1JlZ0V4cH1cXG4gICAgICAgKi9cXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXFxuICAgICAgICpcXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXFxuICAgICAgICogQHR5cGUge1JlZ0V4cH1cXG4gICAgICAgKi9cXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxcbiAgICAgICAqXFxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XFxuICAgICAgICovXFxuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXFxuICAgICAgICpcXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXFxuICAgICAgICogQHR5cGUge3N0cmluZ31cXG4gICAgICAgKi9cXG4gICAgICAndmFyaWFibGUnOiAnJyxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXFxuICAgICAgICpcXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXFxuICAgICAgICogQHR5cGUge09iamVjdH1cXG4gICAgICAgKi9cXG4gICAgICAnaW1wb3J0cyc6IHtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxcbiAgICAgICAgICpcXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxcbiAgICAgICAgICovXFxuICAgICAgICAnXyc6IGxvZGFzaFxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxcbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XFxuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XFxuXFxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XFxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAY29uc3RydWN0b3JcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XFxuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcXG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XFxuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XFxuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcXG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGNsb25lXFxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcXG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XFxuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XFxuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XFxuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XFxuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgcmV2ZXJzZVxcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XFxuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcXG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XFxuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIHZhbHVlXFxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XFxuXFxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xcbiAgICAgIH1cXG4gICAgICB2YXIgcmVzdWx0ID0gW107XFxuXFxuICAgICAgb3V0ZXI6XFxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XFxuICAgICAgICBpbmRleCArPSBkaXI7XFxuXFxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XFxuXFxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XFxuXFxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XFxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBjb25zdHJ1Y3RvclxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XFxuXFxuICAgICAgdGhpcy5jbGVhcigpO1xcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcXG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBjbGVhclxcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcXG4gICAgICB0aGlzLnNpemUgPSAwO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZGVsZXRlXFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcXG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGdldFxcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XFxuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcXG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGhhc1xcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XFxuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgc2V0XFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XFxuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcXG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXFxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAY29uc3RydWN0b3JcXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XFxuXFxuICAgICAgdGhpcy5jbGVhcigpO1xcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcXG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBjbGVhclxcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcXG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XFxuICAgICAgdGhpcy5zaXplID0gMDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGRlbGV0ZVxcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xcblxcbiAgICAgIGlmIChpbmRleCA8IDApIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcXG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XFxuICAgICAgICBkYXRhLnBvcCgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XFxuICAgICAgfVxcbiAgICAgIC0tdGhpcy5zaXplO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZ2V0XFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XFxuXFxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGhhc1xcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XFxuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgc2V0XFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xcblxcbiAgICAgIGlmIChpbmRleCA8IDApIHtcXG4gICAgICAgICsrdGhpcy5zaXplO1xcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuXFxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XFxuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XFxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBjb25zdHJ1Y3RvclxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xcblxcbiAgICAgIHRoaXMuY2xlYXIoKTtcXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XFxuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBjbGVhclxcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XFxuICAgICAgdGhpcy5zaXplID0gMDtcXG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZGVsZXRlXFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcXG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZ2V0XFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XFxuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGhhc1xcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBzZXRcXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcXG5cXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcXG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XFxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XFxuXFxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gICAgLyoqXFxuICAgICAqXFxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBjb25zdHJ1Y3RvclxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XFxuXFxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBhZGRcXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXFxuICAgICAqIEBhbGlhcyBwdXNoXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XFxuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBoYXNcXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQGNvbnN0cnVjdG9yXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XFxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgY2xlYXJcXG4gICAgICogQG1lbWJlck9mIFN0YWNrXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZGVsZXRlXFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xcblxcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGdldFxcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBoYXNcXG4gICAgICogQG1lbWJlck9mIFN0YWNrXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgc2V0XFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XFxuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcXG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XFxuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XFxuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcXG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xcbiAgICAgIH1cXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG5cXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcXG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XFxuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcXG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcXG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XFxuXFxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XFxuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcXG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcXG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXFxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXFxuICAgICAgICAgICAgKSkpIHtcXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcXG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXFxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XFxuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XFxuICAgICAgICAgIHJldHVybiBsZW5ndGg7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAtMTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XFxuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcXG4gICAgICogdmFsdWUgY2hlY2tzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcXG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XFxuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xcblxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bWJlcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cXG4gICAgICogIDEgLSBEZWVwIGNsb25lXFxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcXG4gICAgICB2YXIgcmVzdWx0LFxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xcblxcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XFxuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XFxuICAgICAgaWYgKGlzQXJyKSB7XFxuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XFxuICAgICAgICBpZiAoIWlzRGVlcCkge1xcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xcblxcbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcXG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcXG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXFxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XFxuICAgICAgaWYgKHN0YWNrZWQpIHtcXG4gICAgICAgIHJldHVybiBzdGFja2VkO1xcbiAgICAgIH1cXG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XFxuXFxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNNYXAodmFsdWUpKSB7XFxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcXG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XFxuXFxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XFxuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XFxuICAgICAgICBpZiAocHJvcHMpIHtcXG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XFxuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXFxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gIWxlbmd0aDtcXG4gICAgICB9XFxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XFxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xcblxcbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXFxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0gW10sXFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XFxuXFxuICAgICAgaWYgKCFsZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgIGlmIChpdGVyYXRlZSkge1xcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcXG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XFxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcXG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XFxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XFxuICAgICAgfVxcbiAgICAgIG91dGVyOlxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XFxuXFxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcXG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cXG4gICAgICovXFxuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXFxuICAgICAqL1xcbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcXG4gICAgICogIGVsc2UgYGZhbHNlYFxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXFxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcblxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcXG5cXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxcbiAgICAgICAgICAgICkpIHtcXG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcblxcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XFxuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xcbiAgICAgIH1cXG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xcbiAgICAgIGlmIChlbmQgPCAwKSB7XFxuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xcbiAgICAgIH1cXG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XFxuXFxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcXG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcXG5cXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XFxuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxcbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXFxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICovXFxuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKi9cXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XFxuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XFxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XFxuXFxuICAgICAgdmFyIGluZGV4ID0gMCxcXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XFxuXFxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcXG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcXG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcXG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcXG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xcblxcbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XFxuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XFxuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcXG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXFxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XFxuXFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XFxuXFxuICAgICAgb3V0ZXI6XFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcXG5cXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xcbiAgICAgICAgaWYgKCEoc2VlblxcbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcXG4gICAgICAgICAgICApKSB7XFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XFxuICAgICAgICAgICAgaWYgKCEoY2FjaGVcXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcXG4gICAgICAgICAgICAgICAgKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHNlZW4pIHtcXG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XFxuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcXG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcXG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcXG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcXG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXFxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXFxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcXG5cXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcXG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcXG5cXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XFxuXFxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XFxuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XFxuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcXG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXFxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XFxuICAgICAgfVxcbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcXG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XFxuXFxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXFxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XFxuXFxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XFxuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcXG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcXG5cXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xcbiAgICAgIH1cXG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXFxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXFxuICAgICAgICAgICAgKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XFxuXFxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcXG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxcbiAgICAgICAgICAgICAgKSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXFxuICAgICAqICBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcXG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XFxuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcXG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxcbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XFxuICAgICAgfVxcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcXG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcXG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XFxuICAgICAgfVxcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcXG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcXG4gICAgICB9XFxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcXG5cXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcXG4gICAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xcblxcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcXG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcXG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XFxuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcXG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XFxuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcXG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXFxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXFxuICAgICAqICBjb3VudGVycGFydHMuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xcbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xcblxcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIGtleXNJbik7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXFxuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXFxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXFxuICAgICAqICBjb3VudGVycGFydHMuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XFxuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xcblxcbiAgICAgIGlmIChzdGFja2VkKSB7XFxuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxcbiAgICAgICAgOiB1bmRlZmluZWQ7XFxuXFxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcXG5cXG4gICAgICBpZiAoaXNDb21tb24pIHtcXG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XFxuXFxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XFxuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGlzQ29tbW9uKSB7XFxuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcXG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcXG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMTtcXG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcXG5cXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XFxuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XFxuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XFxuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0ge307XFxuXFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xcblxcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcXG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcXG4gICAgICogc2hvcnRoYW5kcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxcbiAgICAgICAgICBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XFxuXFxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcXG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcXG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XFxuICAgICAgfVxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xcblxcbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XFxuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBhcnJheTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XFxuXFxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XFxuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcXG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XFxuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXFxuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xcblxcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XFxuICAgICAgICBzdGFydCArPSBzdGVwO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XFxuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cXG4gICAgICBkbyB7XFxuICAgICAgICBpZiAobiAlIDIpIHtcXG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcXG4gICAgICAgIH1cXG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XFxuICAgICAgICBpZiAobikge1xcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xcbiAgICAgICAgfVxcbiAgICAgIH0gd2hpbGUgKG4pO1xcblxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XFxuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XFxuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcXG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XFxuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcXG4gICAgICB9XFxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XFxuXFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XFxuXFxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcXG5cXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcXG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XFxuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XFxuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9iamVjdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxcbiAgICAgKi9cXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcXG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcXG4gICAgICByZXR1cm4gZnVuYztcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxcbiAgICAgKi9cXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XFxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcXG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XFxuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XFxuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xcbiAgICAgIH1cXG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XFxuICAgICAgaWYgKGVuZCA8IDApIHtcXG4gICAgICAgIGVuZCArPSBsZW5ndGg7XFxuICAgICAgfVxcbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcXG4gICAgICBzdGFydCA+Pj49IDA7XFxuXFxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXFxuICAgICAqICBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcXG4gICAgICB2YXIgcmVzdWx0O1xcblxcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XFxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gISFyZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxcbiAgICAgKiAgaW50byBgYXJyYXlgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xcbiAgICAgIHZhciBsb3cgPSAwLFxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcXG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcXG5cXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcXG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBoaWdoO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXFxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXFxuICAgICAqICBpbnRvIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XFxuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XFxuXFxuICAgICAgdmFyIGxvdyA9IDAsXFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xcblxcbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XFxuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xcblxcbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XFxuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcXG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcXG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzZXRMb3cpIHtcXG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGhpZ2ggPSBtaWQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xcblxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xcblxcbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XFxuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XFxuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiBOQU47XFxuICAgICAgfVxcbiAgICAgIHJldHVybiArdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XFxuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xcbiAgICAgIH1cXG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcXG4gICAgICAgICAgcmVzdWx0ID0gW10sXFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XFxuXFxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcXG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XFxuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xcbiAgICAgIH1cXG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XFxuICAgICAgICBpZiAoc2V0KSB7XFxuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XFxuICAgICAgICB9XFxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcXG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgIG91dGVyOlxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xcblxcbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XFxuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XFxuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcXG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XFxuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcXG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcXG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcXG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcXG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XFxuXFxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XFxuXFxuICAgICAgcmV0dXJuIGlzRHJvcFxcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcXG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcXG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xcbiAgICAgIH0sIHJlc3VsdCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXFxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XFxuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcXG5cXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xcblxcbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XFxuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0ge307XFxuXFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XFxuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XFxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXFxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcXG5cXG4gICAgLyoqXFxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcXG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cXG4gICAgICovXFxuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcXG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcXG4gICAgICBpZiAoaXNEZWVwKSB7XFxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XFxuICAgICAgfVxcbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XFxuXFxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcXG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XFxuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XFxuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcXG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xcblxcbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XFxuXFxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XFxuICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcXG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xcbiAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXFxuICAgICAqXFxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXFxcImRlc2NcXFwiIGZvciBkZXNjZW5kaW5nIG9yIFxcXCJhc2NcXFwiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcXG5cXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xcbiAgICAgICAgaWYgKHJlc3VsdCkge1xcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAgLy9cXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxcbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcXG5cXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XFxuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XFxuICAgICAgfVxcbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcXG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XFxuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXFxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXFxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XFxuXFxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcXG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XFxuICAgICAgfVxcbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcXG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XFxuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcXG5cXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcXG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xcblxcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XFxuXFxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXFxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXFxuICAgICAgICAgIDogdW5kZWZpbmVkO1xcblxcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc05ldykge1xcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBvYmplY3Q7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XFxuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XFxuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xcblxcbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xcblxcbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXFxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcXG5cXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcXG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xcbiAgICAgICAgICBsZW5ndGggPSAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XFxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XFxuICAgICAgICAgIGlmIChzb3VyY2UpIHtcXG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gb2JqZWN0O1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcXG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcXG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XFxuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcXG5cXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XFxuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBvYmplY3Q7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcXG5cXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcXG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHdyYXBwZXI7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XFxuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcblxcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XFxuXFxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xcblxcbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcXG5cXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XFxuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XFxuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcXG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XFxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xcblxcbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXFxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcXG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XFxuXFxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xcblxcbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcXG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcXG4gICAgICAgICAgPyBbXVxcbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcXG5cXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcXG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcXG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB3cmFwcGVyO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XFxuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XFxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XFxuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XFxuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XFxuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcXG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcXG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcXG5cXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcXG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcXG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XFxuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XFxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcXG5cXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcXG5cXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXFxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcXG4gICAgICAgICAgICAgICkge1xcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XFxuXFxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XFxuXFxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XFxuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xcblxcbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XFxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcXG5cXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XFxuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcXG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXJ0aWFscykge1xcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XFxuICAgICAgICB9XFxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XFxuXFxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcXG4gICAgICAgIGlmIChhcmdQb3MpIHtcXG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XFxuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gd3JhcHBlcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XFxuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcXG4gICAgICAgIHZhciByZXN1bHQ7XFxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcXG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcXG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XFxuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XFxuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XFxuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XFxuXFxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcXG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcXG4gICAgICB9XFxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcXG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XFxuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XFxuXFxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcXG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xcblxcbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xcbiAgICAgICAgfVxcbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHdyYXBwZXI7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XFxuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxcbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XFxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgZW5kID0gc3RhcnQ7XFxuICAgICAgICAgIHN0YXJ0ID0gMDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XFxuICAgICAgICB9XFxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcXG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XFxuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXFxuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XFxuXFxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XFxuXFxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcXG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XFxuICAgICAgfVxcbiAgICAgIHZhciBuZXdEYXRhID0gW1xcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxcbiAgICAgIF07XFxuXFxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XFxuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcXG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcXG4gICAgICB9XFxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XFxuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcXG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XFxuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcXG5cXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XFxuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxcbiAgICAgKi9cXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcXG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcXG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XFxuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXFxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXFxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXFxuICAgICAqICAyNTYgLSBgXy5hcnlgXFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcXG4gICAgICB9XFxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XFxuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xcblxcbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcXG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcXG5cXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xcblxcbiAgICAgIHZhciBuZXdEYXRhID0gW1xcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxcbiAgICAgIF07XFxuXFxuICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcXG4gICAgICB9XFxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XFxuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XFxuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XFxuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XFxuXFxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcXG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XFxuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcXG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXFxuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXFxuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXFxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gb2JqVmFsdWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXFxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XFxuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XFxuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gb2JqVmFsdWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXFxuICAgICAqIG9iamVjdHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXFxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xcblxcbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcXG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XFxuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcXG4gICAgICB9XFxuICAgICAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xcblxcbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xcblxcbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xcblxcbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcXG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXFxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cXG4gICAgICAgIGlmIChzZWVuKSB7XFxuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9KSkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKCEoXFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcXG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXFxuICAgICAgICAgICAgKSkge1xcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XFxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXFxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xcbiAgICAgIHN3aXRjaCAodGFnKSB7XFxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcXG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XFxuXFxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFxuICAgICAgICBjYXNlIGJvb2xUYWc6XFxuICAgICAgICBjYXNlIGRhdGVUYWc6XFxuICAgICAgICBjYXNlIG51bWJlclRhZzpcXG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XFxuXFxuICAgICAgICBjYXNlIGVycm9yVGFnOlxcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xcblxcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XFxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcXG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcXG5cXG4gICAgICAgIGNhc2UgbWFwVGFnOlxcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XFxuXFxuICAgICAgICBjYXNlIHNldFRhZzpcXG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcXG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xcblxcbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcXG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XFxuXFxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxcbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XFxuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcXG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuXFxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcXG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXFxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcXG5cXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcXG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XFxuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XFxuICAgICAgfVxcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcXG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XFxuXFxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XFxuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XFxuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XFxuXFxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXFxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxcbiAgICAgICAgICAgICkpIHtcXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xcbiAgICAgIH1cXG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xcblxcbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXFxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXFxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXFxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXFxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XFxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XFxuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XFxuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXFxuICAgICAqL1xcbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcXG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcXG5cXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XFxuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcXG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcXG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcXG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcXFwiaXRlcmF0ZWVcXFwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XFxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XFxuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XFxuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXFxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxcbiAgICAgICAgOiBkYXRhLm1hcDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XFxuXFxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcXG5cXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcXG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XFxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XFxuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcXG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XFxuICAgICAgfSBjYXRjaCAoZSkge31cXG5cXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XFxuICAgICAgaWYgKHVubWFza2VkKSB7XFxuICAgICAgICBpZiAoaXNPd24pIHtcXG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXFxuICAgICAqL1xcbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cXG4gICAgICovXFxuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICB3aGlsZSAob2JqZWN0KSB7XFxuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxcbiAgICAgKi9cXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XFxuXFxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XFxuXFxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcXG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcXG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcXG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XFxuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcXG5cXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xcblxcbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcXG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcXG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcXG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xcblxcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XFxuXFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XFxuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcXG4gICAgICB9XFxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcXG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XFxuXFxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XFxuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxcbiAgICAgICAgOiB7fTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XFxuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XFxuICAgICAgc3dpdGNoICh0YWcpIHtcXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XFxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XFxuXFxuICAgICAgICBjYXNlIGJvb2xUYWc6XFxuICAgICAgICBjYXNlIGRhdGVUYWc6XFxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcXG5cXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XFxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcXG5cXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcXG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XFxuXFxuICAgICAgICBjYXNlIG1hcFRhZzpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xcblxcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XFxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XFxuXFxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcXG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XFxuXFxuICAgICAgICBjYXNlIHNldFRhZzpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xcblxcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XFxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xcbiAgICAgIGlmICghbGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gc291cmNlO1xcbiAgICAgIH1cXG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcXG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XFxuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XFxuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXFxcbicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XFxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xcblxcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcXG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcXG4gICAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XFxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXFxuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcXG4gICAgICAgICAgKSB7XFxuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXFxuICAgICAqICBlbHNlIGBmYWxzZWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcXG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xcblxcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcXG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcXG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcXG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcXG5cXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXFxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxcbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGtleTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cXG4gICAgICpcXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XFxuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xcblxcbiAgICAgIHZhciBpc0NvbWJvID1cXG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xcblxcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxcbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XFxuICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICB9XFxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxcbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcXG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XFxuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxcbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xcbiAgICAgIH1cXG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxcbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcXG4gICAgICBpZiAodmFsdWUpIHtcXG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XFxuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcXG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcXG4gICAgICB9XFxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcXG4gICAgICBpZiAodmFsdWUpIHtcXG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcXG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XFxuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XFxuICAgICAgfVxcbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxcbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xcbiAgICAgIGlmICh2YWx1ZSkge1xcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcXG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcXG4gICAgICB9XFxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXFxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcXG4gICAgICB9XFxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxcbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XFxuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XFxuXFxuICAgICAgcmV0dXJuIGRhdGE7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXFxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcXG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xcblxcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGluZGV4ID0gLTE7XFxuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcXG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xcbiAgICAgICAgfVxcbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XFxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XFxuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcXG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XFxuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XFxuXFxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XFxuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFxcXCJfX3Byb3RvX19cXFwiLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XFxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcXG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXFxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cXG4gICAgICovXFxuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xcblxcbiAgICAvKipcXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cXG4gICAgICovXFxuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XFxuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cXG4gICAgICovXFxuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XFxuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XFxuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxcbiAgICAgKiBtaWxsaXNlY29uZHMuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XFxuICAgICAgdmFyIGNvdW50ID0gMCxcXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcXG5cXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcXG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XFxuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvdW50ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XFxuXFxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XFxuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcXG5cXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XFxuICAgICAgcmV0dXJuIGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXFxuICAgICAqL1xcbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XFxuICAgICAgICByZXN1bHQucHVzaCgnJyk7XFxuICAgICAgfVxcbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcXG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXFxuICAgICAqXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XFxuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcXG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XFxuICAgICAgfVxcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XFxuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XFxuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxcbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xcbiAgICAgKiBlbGVtZW50cy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XFxuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxcbiAgICAgKlxcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcXG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcXG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcXG4gICAgICAgIHNpemUgPSAxO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XFxuICAgICAgfVxcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaW5kZXggPSAwLFxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xcblxcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxcbiAgICAgKiBgMGAsIGBcXFwiXFxcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XFxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcXG5cXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xcbiAgICAgICAgaWYgKHZhbHVlKSB7XFxuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxcbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XFxuICAgICAqXFxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xcbiAgICAgKiAvLyA9PiBbMV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XFxuXFxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcXG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXFxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxcbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcXG4gICAgICogLy8gPT4gWzFdXFxuICAgICAqL1xcbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcXG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXFxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcXG4gICAgICAgIDogW107XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXFxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcXG4gICAgICogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xcbiAgICAgKiAvLyA9PiBbMS4yXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XFxuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxcbiAgICAgKi9cXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcXG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XFxuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXFxuICAgICAgICA6IFtdO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xcbiAgICAgKlxcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxcbiAgICAgKi9cXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcXG4gICAgICAgIDogW107XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuNS4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IFsyLCAzXVxcbiAgICAgKlxcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcXG4gICAgICogLy8gPT4gWzNdXFxuICAgICAqXFxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xcbiAgICAgKiAvLyA9PiBbXVxcbiAgICAgKlxcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKlxcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xcbiAgICAgKiAvLyA9PiBbMV1cXG4gICAgICpcXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcXG4gICAgICogLy8gPT4gW11cXG4gICAgICpcXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcbiAgICAgIGlmICghbGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XFxuICAgICAgbiA9IGxlbmd0aCAtIG47XFxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0gW1xcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXFxuICAgICAgICA6IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXFxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciB1c2VycyA9IFtcXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXFxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcXG4gICAgICAgIDogW107XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjIuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xcbiAgICAgKlxcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XFxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcXG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXFxuICAgICAqXFxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XFxuICAgICAqIC8vID0+IFsyLCAyLCAyXVxcbiAgICAgKlxcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcXG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcbiAgICAgIGlmICghbGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcXG4gICAgICAgIHN0YXJ0ID0gMDtcXG4gICAgICAgIGVuZCA9IGxlbmd0aDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAxLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcXG4gICAgICogLy8gPT4gMFxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xcbiAgICAgKiAvLyA9PiAxXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gMFxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gMlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XFxuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXFxuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDIuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xcbiAgICAgKiAvLyA9PiAyXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcXG4gICAgICogLy8gPT4gMFxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xcbiAgICAgKiAvLyA9PiAyXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gMFxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XFxuICAgICAgaWYgKCFsZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgICB9XFxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcXG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXFxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XFxuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XFxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjQuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcXG4gICAgICpcXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXFxuICAgICAqXFxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XFxuICAgICAgaWYgKCFsZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgICB9XFxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XFxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcXG4gICAgICAgICAgcmVzdWx0ID0ge307XFxuXFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAYWxpYXMgZmlyc3RcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IDFcXG4gICAgICpcXG4gICAgICogXy5oZWFkKFtdKTtcXG4gICAgICogLy8gPT4gdW5kZWZpbmVkXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXFxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xcbiAgICAgKiAvLyA9PiAxXFxuICAgICAqXFxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XFxuICAgICAgaWYgKCFsZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgICB9XFxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XFxuICAgICAgaWYgKGluZGV4IDwgMCkge1xcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcXG4gICAgICogLy8gPT4gWzJdXFxuICAgICAqL1xcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XFxuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XFxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcXG4gICAgICAgIDogW107XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXFxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XFxuICAgICAqICh2YWx1ZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcXG4gICAgICogLy8gPT4gWzIuMV1cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XFxuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxcbiAgICAgKi9cXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XFxuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xcblxcbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XFxuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXFxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXFxuICAgICAgICA6IFtdO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XFxuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xcbiAgICAgKlxcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxcbiAgICAgKi9cXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcXG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcXG5cXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XFxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcXG4gICAgICAgIG1hcHBlZC5wb3AoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxcbiAgICAgICAgOiBbXTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcXG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XFxuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XFxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xcbiAgICAgKiAvLyA9PiAzXFxuICAgICAqXFxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xcbiAgICAgKiAvLyA9PiAxXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XFxuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjExLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcXG4gICAgICpcXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xcbiAgICAgKiAvLyA9PiAnYidcXG4gICAgICpcXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcXG4gICAgICogLy8gPT4gJ2MnO1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAyLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcXG4gICAgICpcXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XFxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcXG4gICAgICogLy8gPT4gWydiJywgJ2InXVxcbiAgICAgKi9cXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XFxuICAgICAqXFxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XFxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcXG4gICAgICogLy8gPT4gWydiJywgJ2InXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXFxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXFxuICAgICAgICA6IGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxcbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcXG4gICAgICpcXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXFxuICAgICAgICA6IGFycmF5O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC42LjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XFxuICAgICAqXFxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XFxuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxcbiAgICAgICAgOiBhcnJheTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XFxuICAgICAqXFxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcXG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXFxuICAgICAqL1xcbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XFxuXFxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XFxuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMi4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xcbiAgICAgKiB9KTtcXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xcbiAgICAgKiAvLyA9PiBbMSwgM11cXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xcbiAgICAgKiAvLyA9PiBbMiwgNF1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBpbmRleGVzID0gW10sXFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XFxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XFxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcXG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxcbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XFxuICAgICAqXFxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XFxuICAgICAqIC8vID0+IFszLCAyLCAxXVxcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XFxuICAgICAqIC8vID0+IFszLCAyLCAxXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXFxuICAgICAqIHJldHVybmVkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XFxuICAgICAgICBzdGFydCA9IDA7XFxuICAgICAgICBlbmQgPSBsZW5ndGg7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XFxuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcXG4gICAgICogIGludG8gYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xcbiAgICAgKiAvLyA9PiAxXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcXG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXFxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXFxuICAgICAqICBpbnRvIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xcbiAgICAgKlxcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcXG4gICAgICogLy8gPT4gMFxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XFxuICAgICAqIC8vID0+IDBcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcXG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XFxuICAgICAqIC8vID0+IDFcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcbiAgICAgIGlmIChsZW5ndGgpIHtcXG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XFxuICAgICAgICAgIHJldHVybiBpbmRleDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIC0xO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xcbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXFxuICAgICAqICBpbnRvIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XFxuICAgICAqIC8vID0+IDRcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcXG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxcbiAgICAgKiAgaW50byBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcXG4gICAgICpcXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xcbiAgICAgKiAvLyA9PiAxXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XFxuICAgICAqIC8vID0+IDFcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcXG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAobGVuZ3RoKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XFxuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gLTE7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcXG4gICAgICogLy8gPT4gWzEsIDJdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXFxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxcbiAgICAgICAgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXFxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXFxuICAgICAgICA6IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcXG4gICAgICogLy8gPT4gWzIsIDNdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xcbiAgICAgKiAvLyA9PiBbMV1cXG4gICAgICpcXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKlxcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXFxuICAgICAqXFxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xcbiAgICAgKiAvLyA9PiBbXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcXG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XFxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xcbiAgICAgKiAvLyA9PiBbM11cXG4gICAgICpcXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcXG4gICAgICogLy8gPT4gWzIsIDNdXFxuICAgICAqXFxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XFxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxcbiAgICAgKlxcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xcbiAgICAgKiAvLyA9PiBbXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcXG4gICAgICBpZiAoIWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0gW1xcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XFxuICAgICAqIC8vID0+IFtdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXFxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXFxuICAgICAgICA6IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciB1c2VycyA9IFtcXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xcbiAgICAgKiAvLyA9PiBbXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxcbiAgICAgICAgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXFxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcXG4gICAgICogLy8gPT4gWzIsIDFdXFxuICAgICAqL1xcbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcXG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XFxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcXG4gICAgICogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XFxuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcXG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXFxuICAgICAqL1xcbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcXG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XFxuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XFxuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xcbiAgICAgKlxcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XFxuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxcbiAgICAgKi9cXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXFxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcXG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxcbiAgICAgKiBpbiB0aGUgYXJyYXkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xcbiAgICAgKiAvLyA9PiBbMiwgMV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XFxuICAgICAqICh2YWx1ZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcXG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xcbiAgICAgKlxcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XFxuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XFxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxcbiAgICAgKiBjb25maWd1cmF0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAxLjIuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXFxuICAgICAqXFxuICAgICAqIF8udW56aXAoemlwcGVkKTtcXG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XFxuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgbGVuZ3RoID0gMDtcXG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XFxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy44LjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XFxuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cXG4gICAgICpcXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XFxuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgICB9XFxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcXG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcXG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXFxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcXG4gICAgICogLy8gPT4gWzNdXFxuICAgICAqL1xcbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcXG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXFxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXFxuICAgICAgICA6IFtdO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDIuNC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XFxuICAgICAqIC8vID0+IFsxLCAzXVxcbiAgICAgKi9cXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXFxuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcXG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XFxuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XFxuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxcbiAgICAgKi9cXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XFxuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcXG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XFxuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xcbiAgICAgKlxcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXFxuICAgICAqL1xcbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEFycmF5XFxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXFxuICAgICAqL1xcbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuNC4wXFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcXG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XFxuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XFxuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjguMFxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XFxuICAgICAqIH0pO1xcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXFxuICAgICAqL1xcbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XFxuXFxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xcbiAgICB9KTtcXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAxLjMuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXFxuICAgICAqICAgLmNoYWluKHVzZXJzKVxcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXFxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XFxuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XFxuICAgICAqICAgfSlcXG4gICAgICogICAuaGVhZCgpXFxuICAgICAqICAgLnZhbHVlKCk7XFxuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cXG4gICAgICogXFxcInRhcCBpbnRvXFxcIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBTZXFcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfKFsxLCAyLCAzXSlcXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcXG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxcbiAgICAgKiAgICBhcnJheS5wb3AoKTtcXG4gICAgICogIH0pXFxuICAgICAqICAucmV2ZXJzZSgpXFxuICAgICAqICAudmFsdWUoKTtcXG4gICAgICogLy8gPT4gWzIsIDFdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XFxuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxcbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcXFwicGFzcyB0aHJ1XFxcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfKCcgIGFiYyAgJylcXG4gICAgICogIC5jaGFpbigpXFxuICAgICAqICAudHJpbSgpXFxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcXG4gICAgICogIH0pXFxuICAgICAqICAudmFsdWUoKTtcXG4gICAgICogLy8gPT4gWydhYmMnXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcXG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cXG4gICAgICpcXG4gICAgICogQG5hbWUgYXRcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDEuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTZXFcXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XFxuICAgICAqXFxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcXG4gICAgICogLy8gPT4gWzMsIDRdXFxuICAgICAqL1xcbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xcblxcbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcXG4gICAgICB9XFxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XFxuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XFxuICAgICAgICAnZnVuYyc6IHRocnUsXFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcXG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gYXJyYXk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXFxuICAgICAqXFxuICAgICAqIEBuYW1lIGNoYWluXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XFxuICAgICAqXFxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cXG4gICAgICogXyh1c2VycylcXG4gICAgICogICAuY2hhaW4oKVxcbiAgICAgKiAgIC5oZWFkKClcXG4gICAgICogICAucGljaygndXNlcicpXFxuICAgICAqICAgLnZhbHVlKCk7XFxuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XFxuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxcbiAgICAgKlxcbiAgICAgKiBAbmFtZSBjb21taXRcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMi4wXFxuICAgICAqIEBjYXRlZ29yeSBTZXFcXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKlxcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cXG4gICAgICpcXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxcbiAgICAgKlxcbiAgICAgKiBAbmFtZSBuZXh0XFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xcbiAgICAgKlxcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcXG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cXG4gICAgICpcXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XFxuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XFxuICAgICAqXFxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcXG5cXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXFxuICAgICAqXFxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFNlcVxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XFxuICAgICAqXFxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cXG4gICAgICpcXG4gICAgICogQG5hbWUgcGxhbnRcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMi4wXFxuICAgICAqIEBjYXRlZ29yeSBTZXFcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xcbiAgICAgKiAgIHJldHVybiBuICogbjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcXG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xcbiAgICAgKlxcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xcbiAgICAgKiAvLyA9PiBbOSwgMTZdXFxuICAgICAqXFxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcXG4gICAgICogLy8gPT4gWzEsIDRdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcXG4gICAgICB2YXIgcmVzdWx0LFxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xcblxcbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XFxuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcXG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XFxuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xcbiAgICAgICAgaWYgKHJlc3VsdCkge1xcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcXG4gICAgICB9XFxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cXG4gICAgICpcXG4gICAgICogQG5hbWUgcmV2ZXJzZVxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IFNlcVxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xcbiAgICAgKlxcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XFxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcXG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XFxuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcXG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcXG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XFxuICAgICAgICAgICdmdW5jJzogdGhydSxcXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXFxuICAgICAqXFxuICAgICAqIEBuYW1lIHZhbHVlXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXFxuICAgICAqIEBjYXRlZ29yeSBTZXFcXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XFxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xcbiAgICB9XFxuXFxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC41LjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcXG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcXG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XFxuICAgICAqL1xcbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XFxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XFxuICAgICAgICArK3Jlc3VsdFtrZXldO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxcbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXFxuICAgICAqIEBzZWUgXy5yZWplY3RcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0gW1xcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XFxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcXG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXFxuICAgICAqL1xcbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAyLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcXG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICovXFxuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcXG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC43LjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC43LjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcXG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XFxuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcXG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcXG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXFxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXFxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXFxcIkNvbGxlY3Rpb25zXFxcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcXFwibGVuZ3RoXFxcIlxcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAYWxpYXMgZWFjaFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxcbiAgICAgKlxcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XFxuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAyLjAuMFxcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxcbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xcbiAgICAgKiB9KTtcXG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XFxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXFxuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcXG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XFxuICAgICAqL1xcbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XFxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XFxuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXFxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXFxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXFxuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcXG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcXG5cXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XFxuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcXG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXFxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXFxuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXFxuICAgICAqXFxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcXG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxcbiAgICAgKi9cXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcXG5cXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXFxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXFxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGFycmF5ID0gW1xcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XFxuICAgICAqIH0pO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XFxuICAgICAqXFxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcXG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cXG4gICAgICovXFxuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XFxuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XFxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cXG4gICAgICpcXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXFxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcXG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XFxuICAgICAqICAgcmV0dXJuIG4gKiBuO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcXG4gICAgICogLy8gPT4gWzE2LCA2NF1cXG4gICAgICpcXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcXG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XFxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXFxuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXFxcImRlc2NcXFwiIGZvclxcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFxcXCJhc2NcXFwiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXFxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXFxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XFxuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xcbiAgICAgIH1cXG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcXG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0gW1xcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXFxuICAgICAqL1xcbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcXG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXFxuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxcbiAgICAgKlxcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cXG4gICAgICpcXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XFxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxcbiAgICAgKiBhbmQgYHNvcnRCeWBcXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXFxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xcbiAgICAgKiB9LCAwKTtcXG4gICAgICogLy8gPT4gM1xcbiAgICAgKlxcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XFxuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcXG4gICAgICogICByZXR1cm4gcmVzdWx0O1xcbiAgICAgKiB9LCB7fSk7XFxuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xcblxcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cXG4gICAgICogQHNlZSBfLnJlZHVjZVxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XFxuICAgICAqXFxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcXG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XFxuICAgICAqIH0sIFtdKTtcXG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxcbiAgICAgKiBAc2VlIF8uZmlsdGVyXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciB1c2VycyA9IFtcXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XFxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDIuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xcbiAgICAgKiAvLyA9PiAyXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcXG4gICAgICogLy8gPT4gWzMsIDFdXFxuICAgICAqXFxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcXG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xcbiAgICAgICAgbiA9IDE7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XFxuICAgICAgfVxcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICpcXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XFxuICAgICAqIC8vID0+IDJcXG4gICAgICpcXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XFxuICAgICAqIC8vID0+IDdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcXG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcXG4gICAgICB9XFxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcXG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XFxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXFxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIHZhciB1c2VycyA9IFtcXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XFxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XFxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XFxuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXFxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXFxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0gW1xcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXFxuICAgICAqXFxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cXG4gICAgICovXFxuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcXG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XFxuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XFxuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gICAgLyoqXFxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMi40LjBcXG4gICAgICogQGNhdGVnb3J5IERhdGVcXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XFxuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcXG4gICAgICogfSwgXy5ub3coKSk7XFxuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXFxuICAgICAqL1xcbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XFxuICAgIH07XFxuXFxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXFxuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcXG4gICAgICpcXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XFxuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xcbiAgICAgKiB9KTtcXG4gICAgICpcXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XFxuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xcbiAgICAgKiB9KTtcXG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XFxuICAgICAgfVxcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XFxuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XFxuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XFxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcXG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XFxuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XFxuICAgICAgdmFyIHJlc3VsdDtcXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xcbiAgICAgIH1cXG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgIGlmICgtLW4gPiAwKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChuIDw9IDEpIHtcXG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcXFwibGVuZ3RoXFxcIlxcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxcbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcXG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xcbiAgICAgKlxcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XFxuICAgICAqIGJvdW5kKCchJyk7XFxuICAgICAqIC8vID0+ICdoaSBmcmVkISdcXG4gICAgICpcXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXFxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xcbiAgICAgKiBib3VuZCgnaGknKTtcXG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xcbiAgICAgKi9cXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XFxuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcXG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXFxuICAgICAqXFxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXFxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXFxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXFxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXFxuICAgICAqXFxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMTAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XFxuICAgICAqICAgfVxcbiAgICAgKiB9O1xcbiAgICAgKlxcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcXG4gICAgICogYm91bmQoJyEnKTtcXG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xcbiAgICAgKlxcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcXG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xcbiAgICAgKiB9O1xcbiAgICAgKlxcbiAgICAgKiBib3VuZCgnIScpO1xcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcXG4gICAgICpcXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXFxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XFxuICAgICAqIGJvdW5kKCdoaScpO1xcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcXG4gICAgICovXFxuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XFxuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcXG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXFxuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXFxuICAgICAqXFxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFxcXCJsZW5ndGhcXFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAyLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XFxuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcXG4gICAgICogfTtcXG4gICAgICpcXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XFxuICAgICAqXFxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XFxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxcbiAgICAgKlxcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cXG4gICAgICpcXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXFxuICAgICAqXFxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXFxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XFxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XFxuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcXG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXFxuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFxcXCJsZW5ndGhcXFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XFxuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcXG4gICAgICogfTtcXG4gICAgICpcXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcXG4gICAgICpcXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXFxuICAgICAqXFxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XFxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxcbiAgICAgKlxcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cXG4gICAgICpcXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcXG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XFxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXFxuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXFxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcXG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcXG4gICAgICogaW52b2NhdGlvbi5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxcbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXFxuICAgICAqXFxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXFxuICAgICAqXFxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXFxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxcbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xcbiAgICAgKlxcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxcbiAgICAgKiB9KSk7XFxuICAgICAqXFxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXFxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XFxuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcXG4gICAgICpcXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XFxuICAgICAgdmFyIGxhc3RBcmdzLFxcbiAgICAgICAgICBsYXN0VGhpcyxcXG4gICAgICAgICAgbWF4V2FpdCxcXG4gICAgICAgICAgcmVzdWx0LFxcbiAgICAgICAgICB0aW1lcklkLFxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xcblxcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XFxuICAgICAgfVxcbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XFxuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XFxuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcXG5cXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XFxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XFxuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcXG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXFxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXFxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xcblxcbiAgICAgICAgcmV0dXJuIG1heGluZ1xcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXFxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XFxuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XFxuXFxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcXG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XFxuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XFxuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XFxuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xcblxcbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxcbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXFxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcXG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XFxuICAgICAgICB9XFxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XFxuICAgICAgICB9XFxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XFxuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XFxuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xcblxcbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XFxuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XFxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xcblxcbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcXG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcXG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XFxuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcXG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcXG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcXG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxcbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcXG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cXG4gICAgICovXFxuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcXG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXFxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XFxuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XFxuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cXG4gICAgICovXFxuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcXG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcXG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XFxuICAgICAqIH0pO1xcbiAgICAgKlxcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XFxuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXFxuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcXG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xcbiAgICAgKlxcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcXG4gICAgICogdmFsdWVzKG9iamVjdCk7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKlxcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xcbiAgICAgKiAvLyA9PiBbMywgNF1cXG4gICAgICpcXG4gICAgICogb2JqZWN0LmEgPSAyO1xcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcXG4gICAgICogLy8gPT4gWzEsIDJdXFxuICAgICAqXFxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxcbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XFxuICAgICAqIHZhbHVlcyhvYmplY3QpO1xcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXFxuICAgICAqXFxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXFxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XFxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XFxuICAgICAgfVxcbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcXG5cXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcXG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfTtcXG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XFxuICAgICAgcmV0dXJuIG1lbW9pemVkO1xcbiAgICB9XFxuXFxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxcbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcXG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcXG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XFxuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcXG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcXG4gICAgICogaW5pdGlhbGl6ZSgpO1xcbiAgICAgKiBpbml0aWFsaXplKCk7XFxuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcXG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxcbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcXG4gICAgICogICByZXR1cm4gbiAqIDI7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcXG4gICAgICogICByZXR1cm4gbiAqIG47XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcXG4gICAgICogICByZXR1cm4gW3gsIHldO1xcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XFxuICAgICAqXFxuICAgICAqIGZ1bmMoOSwgMyk7XFxuICAgICAqIC8vID0+IFs4MSwgNl1cXG4gICAgICpcXG4gICAgICogZnVuYygxMCwgNSk7XFxuICAgICAqIC8vID0+IFsxMDAsIDEwXVxcbiAgICAgKi9cXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXFxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xcblxcbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcXG5cXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXFxuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFxcXCJsZW5ndGhcXFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4yLjBcXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXFxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcXG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcXG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcXG4gICAgICpcXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXFxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XFxuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcXG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXFxuICAgICAqL1xcbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XFxuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXFxuICAgICAqXFxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcXFwibGVuZ3RoXFxcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcXG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDEuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxcbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XFxuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XFxuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcXG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXFxuICAgICAqXFxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcXG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcXG4gICAgICovXFxuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXFxuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XFxuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcXG4gICAgICogfSwgWzIsIDAsIDFdKTtcXG4gICAgICpcXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cXG4gICAgICovXFxuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcXG4gICAgICogYW4gYXJyYXkuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XFxuICAgICAqIH0pO1xcbiAgICAgKlxcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcXG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XFxuICAgICAgfVxcbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXFxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjIuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XFxuICAgICAqIH0pO1xcbiAgICAgKlxcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xcbiAgICAgKlxcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcXG4gICAgICogXSk7XFxuICAgICAqXFxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XFxuICAgICAqICAgcmV0dXJuIHggKyB5O1xcbiAgICAgKiB9KSk7XFxuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XFxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcXG4gICAgICB9XFxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcXG5cXG4gICAgICAgIGlmIChhcnJheSkge1xcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXFxuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxcbiAgICAgKlxcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxcbiAgICAgKlxcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxcbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XFxuICAgICAqXFxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxcbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XFxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xcbiAgICAgKlxcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcXG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcXG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XFxuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XFxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XFxuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcXG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xcbiAgICAgKiB9KTtcXG4gICAgICpcXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcXG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XFxuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvKipcXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuNC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XFxuICAgICAqIC8vID0+IFsxXVxcbiAgICAgKlxcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcXG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXFxuICAgICAqXFxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcXG4gICAgICogLy8gPT4gWydhYmMnXVxcbiAgICAgKlxcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcXG4gICAgICogLy8gPT4gW251bGxdXFxuICAgICAqXFxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XFxuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXFxuICAgICAqXFxuICAgICAqIF8uY2FzdEFycmF5KCk7XFxuICAgICAqIC8vID0+IFtdXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcXG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgICB9XFxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXFxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXFxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXFxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XFxuICAgICAqXFxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcXG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcXG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xcbiAgICAgKiAgIH1cXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XFxuICAgICAqIC8vID0+ICdCT0RZJ1xcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XFxuICAgICAqIC8vID0+IDBcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMS4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cXG4gICAgICogQHNlZSBfLmNsb25lXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xcbiAgICAgKlxcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XFxuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcXG4gICAgICogICB9XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcXG4gICAgICogLy8gPT4gJ0JPRFknXFxuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcXG4gICAgICogLy8gPT4gMjBcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcXG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XFxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMTQuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XFxuICAgICAqXFxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XFxuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZXJmb3JtcyBhXFxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXFxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcXG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcXG4gICAgICpcXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5lcSgnYScsICdhJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5lcShOYU4sIE5hTik7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy45LjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXFxuICAgICAqICBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBzZWUgXy5sdFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmd0KDMsIDEpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uZ3QoMywgMyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uZ3QoMSwgMyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy45LjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXFxuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBzZWUgXy5sdGVcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5ndGUoMywgMSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5ndGUoMywgMyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5ndGUoMSwgMyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcXG4gICAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4zLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXFxuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxcbiAgICAgKiBpcyBhbiBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcXG4gICAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcXG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4zLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cXG4gICAgICpcXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXFxuICAgICAqIHByb3BlcnRpZXMuXFxuICAgICAqXFxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXFxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzRW1wdHkoMSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcXG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XFxuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcXG4gICAgICB9XFxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XFxuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxcbiAgICAgKiBlcXVpdmFsZW50LlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXFxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xcbiAgICAgKlxcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XFxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXFxuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XFxuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XFxuICAgICAqICAgfVxcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcXG4gICAgICpcXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcXG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XFxuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XFxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XFxuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXFxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXFxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXFxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxcbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc0ludGVnZXIoMyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNMZW5ndGgoMyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc09iamVjdCh7fSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcXFwib2JqZWN0XFxcIi5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjMuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xcblxcbiAgICAvKipcXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xcbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXFxuICAgICAqXFxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcXG4gICAgICpcXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXFxuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcXG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XFxuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XFxuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICogICB9XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XFxuICAgICAqXFxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxcbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc05hTihOYU4pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XFxuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXFxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXFxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXFxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcXG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcXG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc05pbChudWxsKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc05pbChOYU4pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNOdW1iZXIoMyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcXG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjguMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xcbiAgICAgKiAgIHRoaXMuYSA9IDE7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XFxuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcXG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxcbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4zLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pc1N0cmluZygxKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMy4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMy4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjkuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcXG4gICAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQHNlZSBfLmd0XFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ubHQoMSwgMyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5sdCgzLCAzKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5sdCgzLCAxKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjkuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQHNlZSBfLmd0ZVxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmx0ZSgxLCAzKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmx0ZSgzLCAzKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmx0ZSgzLCAxKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XFxuICAgICAqIC8vID0+IFsxLCAyXVxcbiAgICAgKlxcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cXG4gICAgICpcXG4gICAgICogXy50b0FycmF5KDEpO1xcbiAgICAgKiAvLyA9PiBbXVxcbiAgICAgKlxcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XFxuICAgICAqIC8vID0+IFtdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XFxuICAgICAgaWYgKCF2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4xMi4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcXG4gICAgICogLy8gPT4gMy4yXFxuICAgICAqXFxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XFxuICAgICAqIC8vID0+IDVlLTMyNFxcbiAgICAgKlxcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcXG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcXG4gICAgICpcXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XFxuICAgICAqIC8vID0+IDMuMlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcXG4gICAgICBpZiAoIXZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XFxuICAgICAgfVxcbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcXG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICpcXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XFxuICAgICAqIC8vID0+IDBcXG4gICAgICpcXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxcbiAgICAgKlxcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XFxuICAgICAqIC8vID0+IDNcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXFxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcXG4gICAgICogLy8gPT4gM1xcbiAgICAgKlxcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xcbiAgICAgKiAvLyA9PiAwXFxuICAgICAqXFxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XFxuICAgICAqXFxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xcbiAgICAgKiAvLyA9PiAzXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50b051bWJlcigzLjIpO1xcbiAgICAgKiAvLyA9PiAzLjJcXG4gICAgICpcXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcXG4gICAgICogLy8gPT4gNWUtMzI0XFxuICAgICAqXFxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxcbiAgICAgKlxcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcXG4gICAgICogLy8gPT4gMy4yXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuIE5BTjtcXG4gICAgICB9XFxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcXG4gICAgICB9XFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcXG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXFxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IExhbmdcXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xcbiAgICAgKiAgIHRoaXMuYiA9IDI7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gICAgICpcXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XFxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxcbiAgICAgKlxcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcXG4gICAgICogLy8gPT4gM1xcbiAgICAgKlxcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XFxuICAgICAqIC8vID0+IDBcXG4gICAgICpcXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcXG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxcbiAgICAgKlxcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xcbiAgICAgKiAvLyA9PiAzXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlXFxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XFxuICAgICAqIC8vID0+ICcnXFxuICAgICAqXFxuICAgICAqIF8udG9TdHJpbmcoLTApO1xcbiAgICAgKiAvLyA9PiAnLTAnXFxuICAgICAqXFxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcXG4gICAgICogLy8gPT4gJzEsMiwzJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxcbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC4xMC4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQHNlZSBfLmFzc2lnbkluXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gICAgICogICB0aGlzLmEgPSAxO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcXG4gICAgICogICB0aGlzLmMgPSAzO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XFxuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XFxuICAgICAqXFxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cXG4gICAgICovXFxuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcXG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBhbGlhcyBleHRlbmRcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAc2VlIF8uYXNzaWduXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gICAgICogICB0aGlzLmEgPSAxO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcXG4gICAgICogICB0aGlzLmMgPSAzO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XFxuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XFxuICAgICAqXFxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XFxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cXG4gICAgICovXFxuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XFxuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xcbiAgICAgKlxcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcXG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XFxuICAgICAqL1xcbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XFxuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcXG4gICAgICpcXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XFxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxcbiAgICAgKi9cXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcXG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMS4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XFxuICAgICAqXFxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XFxuICAgICAqIC8vID0+IFszLCA0XVxcbiAgICAgKi9cXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXFxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAyLjMuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xcbiAgICAgKiAgIHRoaXMueCA9IDA7XFxuICAgICAqICAgdGhpcy55ID0gMDtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XFxuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XFxuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXFxuICAgICAqIH0pO1xcbiAgICAgKlxcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcXG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXFxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXFxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XFxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxcbiAgICAgKi9cXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XFxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XFxuXFxuICAgICAgdmFyIGluZGV4ID0gLTE7XFxuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xcblxcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcXG4gICAgICAgIGxlbmd0aCA9IDE7XFxuICAgICAgfVxcblxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XFxuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcXG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XFxuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcXG5cXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcXG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9iamVjdDtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXFxuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMTAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cXG4gICAgICovXFxuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XFxuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XFxuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcXG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDEuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0ge1xcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxcbiAgICAgKiB9O1xcbiAgICAgKlxcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xcbiAgICAgKiAvLyA9PiAncGViYmxlcydcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcXG4gICAgICogLy8gPT4gJ2ZyZWQnXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gJ2Jhcm5leSdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcXG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXFxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDIuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIHVzZXJzID0ge1xcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxcbiAgICAgKiB9O1xcbiAgICAgKlxcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcXG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XFxuICAgICAqIC8vID0+ICdiYXJuZXknXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xcbiAgICAgKiAvLyA9PiAnZnJlZCdcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcXG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxcbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcXG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuMy4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXFxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gICAgICogICB0aGlzLmEgPSAxO1xcbiAgICAgKiAgIHRoaXMuYiA9IDI7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gICAgICpcXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XFxuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxcbiAgICAgICAgPyBvYmplY3RcXG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXFxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMi4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQHNlZSBfLmZvckluXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gICAgICogICB0aGlzLmEgPSAxO1xcbiAgICAgKiAgIHRoaXMuYiA9IDI7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gICAgICpcXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcXG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xcbiAgICAgKiB9KTtcXG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXFxuICAgICAgICA/IG9iamVjdFxcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxcbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjMuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xcbiAgICAgKiAgIHRoaXMuYSA9IDE7XFxuICAgICAqICAgdGhpcy5iID0gMjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xcbiAgICAgKlxcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XFxuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXFxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMi4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQHNlZSBfLmZvck93blxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XFxuICAgICAqICAgdGhpcy5hID0gMTtcXG4gICAgICogICB0aGlzLmIgPSAyO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XFxuICAgICAqXFxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XFxuICAgICAqIH0pO1xcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcXG4gICAgICogb2YgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXFxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XFxuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XFxuICAgICAqXFxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XFxuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XFxuICAgICAqXFxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XFxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy43LjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXFxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcXG4gICAgICpcXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcXG4gICAgICogLy8gPT4gM1xcbiAgICAgKlxcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcXG4gICAgICogLy8gPT4gM1xcbiAgICAgKlxcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XFxuICAgICAqIC8vID0+ICdkZWZhdWx0J1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcXG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xcbiAgICAgKlxcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcXG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xcbiAgICAgKlxcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXFxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMC43LjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XFxuICAgICAqXFxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XFxuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cXG4gICAgICovXFxuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcXG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXFxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xcbiAgICAgKlxcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XFxuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cXG4gICAgICpcXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XFxuICAgICAqL1xcbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcXG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XFxuICAgICAgfVxcbiAgICB9LCBnZXRJdGVyYXRlZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXFxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcXG4gICAgICpcXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcXG4gICAgICogLy8gPT4gWzIsIDNdXFxuICAgICAqL1xcbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xcbiAgICAgKiAgIHRoaXMuYSA9IDE7XFxuICAgICAqICAgdGhpcy5iID0gMjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xcbiAgICAgKlxcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XFxuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcXG4gICAgICpcXG4gICAgICogXy5rZXlzKCdoaScpO1xcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XFxuICAgICAqICAgdGhpcy5hID0gMTtcXG4gICAgICogICB0aGlzLmIgPSAyO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XFxuICAgICAqXFxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcXG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXFxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjguMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XFxuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xcbiAgICAgKiB9KTtcXG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcXG5cXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XFxuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcXG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDIuNC4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxcbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSB7XFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cXG4gICAgICogfTtcXG4gICAgICpcXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcXG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcXG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0ge307XFxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XFxuXFxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXFxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcXG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuNS4wXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHtcXG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxcbiAgICAgKiB9O1xcbiAgICAgKlxcbiAgICAgKiB2YXIgb3RoZXIgPSB7XFxuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cXG4gICAgICogfTtcXG4gICAgICpcXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcXG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxcbiAgICAgKi9cXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XFxuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXFxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXFxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XFxuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcXG4gICAgICogICB9XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XFxuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XFxuICAgICAqXFxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XFxuICAgICAqL1xcbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XFxuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcXG4gICAgICpcXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XFxuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxcbiAgICAgKi9cXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcXG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xcbiAgICAgICAgcmV0dXJuIHBhdGg7XFxuICAgICAgfSk7XFxuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xcbiAgICAgIGlmIChpc0RlZXApIHtcXG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcXG4gICAgICB9XFxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XFxuICAgICAqXFxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XFxuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XFxuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcXG4gICAgICpcXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XFxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxcbiAgICAgKi9cXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXFxuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XFxuICAgICAqXFxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XFxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XFxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4ge307XFxuICAgICAgfVxcbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XFxuICAgICAgICByZXR1cm4gW3Byb3BdO1xcbiAgICAgIH0pO1xcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XFxuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXFxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XFxuICAgICAqXFxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xcbiAgICAgKiAvLyA9PiAzXFxuICAgICAqXFxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xcbiAgICAgKiAvLyA9PiA0XFxuICAgICAqXFxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XFxuICAgICAqIC8vID0+ICdkZWZhdWx0J1xcbiAgICAgKlxcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xcblxcbiAgICAgIHZhciBpbmRleCA9IC0xLFxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcXG5cXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXFxuICAgICAgaWYgKCFsZW5ndGgpIHtcXG4gICAgICAgIGxlbmd0aCA9IDE7XFxuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XFxuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9iamVjdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjcuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcXG4gICAgICpcXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcXG4gICAgICogLy8gPT4gNFxcbiAgICAgKlxcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcXG4gICAgICogLy8gPT4gNVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xcbiAgICAgKlxcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXFxuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAYWxpYXMgZW50cmllc1xcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gICAgICogICB0aGlzLmEgPSAxO1xcbiAgICAgKiAgIHRoaXMuYiA9IDI7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gICAgICpcXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxcbiAgICAgKi9cXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xcbiAgICAgKiAgIHRoaXMuYSA9IDE7XFxuICAgICAqICAgdGhpcy5iID0gMjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xcbiAgICAgKlxcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcXG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXFxuICAgICAqL1xcbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xcblxcbiAgICAvKipcXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXFxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxcbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXFxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMS4zLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcXG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xcbiAgICAgKiB9LCBbXSk7XFxuICAgICAqIC8vID0+IFs0LCA5XVxcbiAgICAgKlxcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XFxuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcXG4gICAgICogfSwge30pO1xcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcXG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XFxuXFxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XFxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcXG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcXG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XFxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcXG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcXG4gICAgICpcXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC42LjBcXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xcbiAgICAgKlxcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcXG4gICAgICogLy8gPT4gOVxcbiAgICAgKlxcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xcbiAgICAgKiAvLyA9PiAwXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjYuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xcbiAgICAgKlxcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XFxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XFxuICAgICAqICAgdGhpcy5hID0gMTtcXG4gICAgICogICB0aGlzLmIgPSAyO1xcbiAgICAgKiB9XFxuICAgICAqXFxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XFxuICAgICAqXFxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcXG4gICAgICpcXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XFxuICAgICAqIC8vID0+IFsnaCcsICdpJ11cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gICAgICogICB0aGlzLmEgPSAxO1xcbiAgICAgKiAgIHRoaXMuYiA9IDI7XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gICAgICpcXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XFxuICAgIH1cXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvKipcXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcXG4gICAgICogLy8gPT4gLTVcXG4gICAgICpcXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xcbiAgICAgKiAvLyA9PiA1XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB1cHBlciA9IGxvd2VyO1xcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcXG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xcbiAgICAgIH1cXG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XFxuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxcbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcXG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjMuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXFxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKlxcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKlxcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XFxuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XFxuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBlbmQgPSBzdGFydDtcXG4gICAgICAgIHN0YXJ0ID0gMDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcXG4gICAgICB9XFxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcXG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAwLjcuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcXG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcXG4gICAgICpcXG4gICAgICogXy5yYW5kb20oNSk7XFxuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcXG4gICAgICpcXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XFxuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XFxuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XFxuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcXG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcXG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcXG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGxvd2VyID0gMDtcXG4gICAgICAgIHVwcGVyID0gMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcXG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XFxuICAgICAgICAgIGxvd2VyID0gMDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcXG4gICAgICAgIGxvd2VyID0gdXBwZXI7XFxuICAgICAgICB1cHBlciA9IHRlbXA7XFxuICAgICAgfVxcbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XFxuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xcbiAgICB9XFxuXFxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcXG4gICAgICogLy8gPT4gJ2Zvb0JhcidcXG4gICAgICpcXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XFxuICAgICAqIC8vID0+ICdmb29CYXInXFxuICAgICAqXFxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xcbiAgICAgKi9cXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcXG4gICAgICogdG8gbG93ZXIgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xcbiAgICAgKiAvLyA9PiAnRnJlZCdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XFxuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXFxuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXFxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqXFxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XFxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XFxuXFxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XFxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXFxuICAgICAgICA/IGxlbmd0aFxcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcXG5cXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XFxuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcXG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcXFwiJlxcXCIsIFxcXCI8XFxcIiwgXFxcIj5cXFwiLCAnXFxcIicsIGFuZCBcXFwiJ1xcXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXFxuICAgICAqXFxuICAgICAqIFRob3VnaCB0aGUgXFxcIj5cXFwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXFxuICAgICAqIFxcXCI+XFxcIiBhbmQgXFxcIi9cXFwiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXFxuICAgICAqICh1bmRlciBcXFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XFxcIikgZm9yIG1vcmUgZGV0YWlscy5cXG4gICAgICpcXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxcbiAgICAgKiBYU1MgdmVjdG9ycy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcXG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXFxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXFxuICAgICAgICA6IHN0cmluZztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFxcXCJeXFxcIiwgXFxcIiRcXFwiLCBcXFwiXFxcXFxcXCIsIFxcXCIuXFxcIiwgXFxcIipcXFwiLCBcXFwiK1xcXCIsXFxuICAgICAqIFxcXCI/XFxcIiwgXFxcIihcXFwiLCBcXFwiKVxcXCIsIFxcXCJbXFxcIiwgXFxcIl1cXFwiLCBcXFwie1xcXCIsIFxcXCJ9XFxcIiwgYW5kIFxcXCJ8XFxcIiBpbiBgc3RyaW5nYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcXG4gICAgICogLy8gPT4gJ1xcXFxbbG9kYXNoXFxcXF1cXFxcKGh0dHBzOi8vbG9kYXNoXFxcXC5jb20vXFxcXCknXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XFxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcXG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcXFxcXCQmJylcXG4gICAgICAgIDogc3RyaW5nO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xcbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcXG4gICAgICpcXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcXG4gICAgICpcXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XFxuICAgICAqIC8vID0+ICdmb28tYmFyJ1xcbiAgICAgKi9cXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcXG4gICAgICpcXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcXG4gICAgICpcXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XFxuICAgICAqIC8vID0+ICdmb28gYmFyJ1xcbiAgICAgKi9cXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xcbiAgICAgKiAvLyA9PiAnZnJlZCdcXG4gICAgICpcXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XFxuICAgICAqIC8vID0+ICdmUkVEJ1xcbiAgICAgKi9cXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XFxuICAgICAqIC8vID0+ICcgIGFiYyAgICdcXG4gICAgICpcXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXFxuICAgICAqXFxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcXG4gICAgICogLy8gPT4gJ2FiYydcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xcblxcbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBzdHJpbmc7XFxuICAgICAgfVxcbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XFxuICAgICAgcmV0dXJuIChcXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcXG4gICAgICAgIHN0cmluZyArXFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xcbiAgICAgKlxcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XFxuICAgICAqIC8vID0+ICdhYmNfLV8nXFxuICAgICAqXFxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcXG4gICAgICogLy8gPT4gJ2FiYydcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xcblxcbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXFxuICAgICAgICA6IHN0cmluZztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXFxuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcXG4gICAgICogLy8gPT4gJyAgIGFiYydcXG4gICAgICpcXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XFxuICAgICAqIC8vID0+ICdfLV9hYmMnXFxuICAgICAqXFxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xcbiAgICAgKiAvLyA9PiAnYWJjJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XFxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcXG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcXG5cXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcXG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXFxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxcbiAgICAgICAgOiBzdHJpbmc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXFxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAxLjEuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xcbiAgICAgKiAvLyA9PiA4XFxuICAgICAqXFxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcXG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcXG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xcbiAgICAgICAgcmFkaXggPSAwO1xcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcXG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXFxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcXG4gICAgICogLy8gPT4gJyoqKidcXG4gICAgICpcXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xcbiAgICAgKlxcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XFxuICAgICAqIC8vID0+ICcnXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcXG4gICAgICAgIG4gPSAxO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXFxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcXG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xcblxcbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcXG4gICAgICogLy8gPT4gJ2Zvb19iYXInXFxuICAgICAqXFxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcXG4gICAgICogLy8gPT4gJ2Zvb19iYXInXFxuICAgICAqXFxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcXG4gICAgICovXFxuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcXG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXFxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XFxuICAgICAqIC8vID0+IFsnYScsICdiJ11cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcXG4gICAgICBpZiAoIWxpbWl0KSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XFxuICAgICAgaWYgKHN0cmluZyAmJiAoXFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcXG4gICAgICAgICAgKSkge1xcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XFxuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcXG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMS4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcXG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXFxuICAgICAqXFxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcXG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXFxuICAgICAqXFxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcXG4gICAgICovXFxuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcXG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcXG4gICAgICogIGVsc2UgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqXFxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XFxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXFxuICAgICAgICA/IDBcXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xcblxcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXFxuICAgICAqIGluIFxcXCJpbnRlcnBvbGF0ZVxcXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxcbiAgICAgKiBcXFwiZXNjYXBlXFxcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFxcXCJldmFsdWF0ZVxcXCIgZGVsaW1pdGVycy4gRGF0YVxcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXFxuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cXG4gICAgICpcXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxcbiAgICAgKlxcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cXG4gICAgICogIFRoZSBIVE1MIFxcXCJlc2NhcGVcXFwiIGRlbGltaXRlci5cXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cXG4gICAgICogIFRoZSBcXFwiZXZhbHVhdGVcXFwiIGRlbGltaXRlci5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXFxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxcbiAgICAgKiAgVGhlIFxcXCJpbnRlcnBvbGF0ZVxcXCIgZGVsaW1pdGVyLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXFxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogLy8gVXNlIHRoZSBcXFwiaW50ZXJwb2xhdGVcXFwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XFxuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XFxuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcXG4gICAgICpcXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFxcXCJlc2NhcGVcXFwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcXG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xcbiAgICAgKlxcbiAgICAgKiAvLyBVc2UgdGhlIFxcXCJldmFsdWF0ZVxcXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcXG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XFxuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xcbiAgICAgKlxcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXFxcImV2YWx1YXRlXFxcIiBkZWxpbWl0ZXJzLlxcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcXFwiaGVsbG8gXFxcIiArIHVzZXIpOyAlPiEnKTtcXG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcXG4gICAgICpcXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcXFwiaW50ZXJwb2xhdGVcXFwiIGRlbGltaXRlci5cXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXFxcImludGVycG9sYXRlXFxcIiBkZWxpbWl0ZXIuXFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcXG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcXG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xcbiAgICAgKlxcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXFxcIlxcXFxcXFxcPCUtIHZhbHVlICVcXFxcXFxcXD5cXFwiICU+Jyk7XFxuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xcbiAgICAgKlxcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXFxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XFxuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcXG4gICAgICpcXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xcbiAgICAgKiBjb21waWxlZChkYXRhKTtcXG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFxcXCJncmVldGluZy5qc3RcXFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXFxuICAgICAqXFxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XFxuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcXG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcXG4gICAgICogLy8gICByZXR1cm4gX19wO1xcbiAgICAgKiAvLyB9XFxuICAgICAqXFxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXFxcc1xcXFxTXSs/KX19L2c7XFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XFxuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xcbiAgICAgKlxcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXFxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXFxcXG4gICAgICogICB2YXIgSlNUID0ge1xcXFxcXG4gICAgICogICAgIFxcXCJtYWluXFxcIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxcXFxuICAgICAqICAgfTtcXFxcXFxuICAgICAqICcpO1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXFxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXFxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XFxuXFxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XFxuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcXG5cXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XFxuXFxuICAgICAgdmFyIGlzRXNjYXBpbmcsXFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcXG4gICAgICAgICAgaW5kZXggPSAwLFxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxcbiAgICAgICAgICBzb3VyY2UgPSBcXFwiX19wICs9ICdcXFwiO1xcblxcbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXFxuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXFxuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcXG4gICAgICAsICdnJyk7XFxuXFxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxcbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcXG4gICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXFxuICAgICAgICAgID8gb3B0aW9ucy5zb3VyY2VVUkxcXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXFxuICAgICAgICApICsgJ1xcXFxuJztcXG5cXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcXG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xcblxcbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXFxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xcblxcbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXFxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcXG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XFxuICAgICAgICAgIHNvdXJjZSArPSBcXFwiJyArXFxcXG5fX2UoXFxcIiArIGVzY2FwZVZhbHVlICsgXFxcIikgK1xcXFxuJ1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xcbiAgICAgICAgICBzb3VyY2UgKz0gXFxcIic7XFxcXG5cXFwiICsgZXZhbHVhdGVWYWx1ZSArIFxcXCI7XFxcXG5fX3AgKz0gJ1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xcbiAgICAgICAgICBzb3VyY2UgKz0gXFxcIicgK1xcXFxuKChfX3QgPSAoXFxcIiArIGludGVycG9sYXRlVmFsdWUgKyBcXFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxcXG4nXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xcblxcbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXFxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHNvdXJjZSArPSBcXFwiJztcXFxcblxcXCI7XFxuXFxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xcbiAgICAgIGlmICghdmFyaWFibGUpIHtcXG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXFxcbicgKyBzb3VyY2UgKyAnXFxcXG59XFxcXG4nO1xcbiAgICAgIH1cXG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXFxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXFxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XFxuXFxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxcXG4nICtcXG4gICAgICAgICh2YXJpYWJsZVxcbiAgICAgICAgICA/ICcnXFxuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcXFxuJ1xcbiAgICAgICAgKSArXFxuICAgICAgICBcXFwidmFyIF9fdCwgX19wID0gJydcXFwiICtcXG4gICAgICAgIChpc0VzY2FwaW5nXFxuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xcbiAgICAgICAgICAgOiAnJ1xcbiAgICAgICAgKSArXFxuICAgICAgICAoaXNFdmFsdWF0aW5nXFxuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxcXG4nICtcXG4gICAgICAgICAgICBcXFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxcXG5cXFwiXFxuICAgICAgICAgIDogJztcXFxcbidcXG4gICAgICAgICkgK1xcbiAgICAgICAgc291cmNlICtcXG4gICAgICAgICdyZXR1cm4gX19wXFxcXG59JztcXG5cXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxcbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XFxuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXFxuICAgICAqXFxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XFxuICAgICAqIC8vID0+ICdmb29iYXInXFxuICAgICAqXFxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcXG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXFxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcXG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xcbiAgICAgKlxcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xcbiAgICAgKlxcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XFxuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xcbiAgICAgKiAvLyA9PiAnYWJjJ1xcbiAgICAgKlxcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xcbiAgICAgKiAvLyA9PiAnYWJjJ1xcbiAgICAgKlxcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XFxuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XFxuICAgICAgICByZXR1cm4gc3RyaW5nO1xcbiAgICAgIH1cXG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XFxuXFxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XFxuICAgICAqIC8vID0+ICcgIGFiYydcXG4gICAgICpcXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcXG4gICAgICogLy8gPT4gJy1fLWFiYydcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XFxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XFxuICAgICAgfVxcbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xcbiAgICAgICAgcmV0dXJuIHN0cmluZztcXG4gICAgICB9XFxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcXG5cXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcXG4gICAgICogLy8gPT4gJ2FiYyAgJ1xcbiAgICAgKlxcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XFxuICAgICAqIC8vID0+ICdhYmMtXy0nXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XFxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XFxuICAgICAgICByZXR1cm4gc3RyaW5nO1xcbiAgICAgIH1cXG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xcblxcbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxcbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxcbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXFxcIi4uLlxcXCIuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XFxuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXFxuICAgICAqXFxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XFxuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcXG4gICAgICogfSk7XFxuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xcbiAgICAgKlxcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXFxuICAgICAqIH0pO1xcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xcbiAgICAgKlxcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXFxuICAgICAqIH0pO1xcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XFxuXFxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XFxuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XFxuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xcbiAgICAgIH1cXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcblxcbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XFxuICAgICAgfVxcbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gc3RyaW5nO1xcbiAgICAgIH1cXG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XFxuICAgICAgaWYgKGVuZCA8IDEpIHtcXG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcXG4gICAgICB9XFxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XFxuXFxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XFxuICAgICAgfVxcbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XFxuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XFxuICAgICAgICAgIHZhciBtYXRjaCxcXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcXG5cXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XFxuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XFxuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xcbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDAuNi4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxcbiAgICAgICAgOiBzdHJpbmc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XFxuICAgICAqIC8vID0+ICdGT08gQkFSJ1xcbiAgICAgKlxcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XFxuICAgICAqIC8vID0+ICdGT08gQkFSJ1xcbiAgICAgKlxcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcXG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXFxuICAgICAqL1xcbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XFxuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcXG4gICAgfSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XFxuICAgICAqIC8vID0+ICdGcmVkJ1xcbiAgICAgKlxcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcXG4gICAgICogLy8gPT4gJ0ZSRUQnXFxuICAgICAqL1xcbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcXG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cXG4gICAgICpcXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XFxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcXG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xcblxcbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XFxuICAgIH1cXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvKipcXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XFxuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xcbiAgICAgKiB9LCAnPl8+Jyk7XFxuICAgICAqXFxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XFxuICAgICAqICAgZWxlbWVudHMgPSBbXTtcXG4gICAgICogfVxcbiAgICAgKi9cXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICAvKipcXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xcbiAgICAgKiBtZXRob2QuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXFxcImxlbmd0aFxcXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdmlldyA9IHtcXG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XFxuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XFxuICAgICAqICAgfVxcbiAgICAgKiB9O1xcbiAgICAgKlxcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cXG4gICAgICovXFxuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gb2JqZWN0O1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxcbiAgICAgKiBmdW5jdGlvbi5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXFxuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxcbiAgICAgKiBdKTtcXG4gICAgICpcXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xcbiAgICAgKlxcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XFxuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXFxuICAgICAqXFxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XFxuICAgICAqIC8vID0+ICdubyBtYXRjaCdcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xcblxcbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XFxuICAgICAgfSk7XFxuXFxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcXG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XFxuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gW1xcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAyLjQuMFxcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcXG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXFxuICAgICAqXFxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xcbiAgICAgKiAvLyA9PiB0cnVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXFxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMTQuMFxcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xcbiAgICAgKiAvLyA9PiAxXFxuICAgICAqXFxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xcbiAgICAgKiAvLyA9PiAxMFxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcXG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXFxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXFxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcXG4gICAgICogICByZXR1cm4gbiAqIG47XFxuICAgICAqIH1cXG4gICAgICpcXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XFxuICAgICAqIC8vID0+IDlcXG4gICAgICovXFxuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAzLjAuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxcbiAgICAgKiBAc2VlIF8uZmxvd1xcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xcbiAgICAgKiAgIHJldHVybiBuICogbjtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcXG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xcbiAgICAgKiAvLyA9PiA5XFxuICAgICAqL1xcbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBzaW5jZSAwLjEuMFxcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XFxuICAgICAqXFxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXFxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgdXNlcnMgPSBbXFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcXG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXFxuICAgICAqXFxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XFxuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XFxuICAgICAqICAgfTtcXG4gICAgICogfSk7XFxuICAgICAqXFxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcXG4gICAgICogLy8gPT4gWydkZWYnXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXFxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cXG4gICAgICpcXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gW1xcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XFxuICAgICAqIF07XFxuICAgICAqXFxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcXG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcXG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXFxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXFxuICAgICAqXFxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXFxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjIuMFxcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxcbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBbXFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuNy4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxcbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gW1xcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxcbiAgICAgKiBdO1xcbiAgICAgKlxcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xcbiAgICAgKiAvLyA9PiBbMiwgMV1cXG4gICAgICpcXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xcbiAgICAgKiAvLyA9PiBbMiwgMV1cXG4gICAgICovXFxuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXFxuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy43LjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcXG4gICAgICpcXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcXG4gICAgICogLy8gPT4gWzIsIDBdXFxuICAgICAqXFxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcXG4gICAgICogLy8gPT4gWzIsIDBdXFxuICAgICAqL1xcbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXFxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cXG4gICAgICpcXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXFxuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XFxuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcXG4gICAgICogICB9KTtcXG4gICAgICogfVxcbiAgICAgKlxcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcXG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcXG4gICAgICogLy8gPT4gWydlJ11cXG4gICAgICpcXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XFxuICAgICAqIC8vID0+IFsnZSddXFxuICAgICAqXFxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XFxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcXG4gICAgICogLy8gPT4gWydlJ11cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XFxuXFxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcXG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XFxuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XFxuICAgICAgICBvYmplY3QgPSB0aGlzO1xcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcXG4gICAgICB9XFxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xcblxcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XFxuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xcbiAgICAgICAgaWYgKGlzRnVuYykge1xcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XFxuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XFxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XFxuXFxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcXG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICByZXR1cm4gb2JqZWN0O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXFxuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcXG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XFxuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMi4zLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBub29wKCkge1xcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XFxuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcXG4gICAgICogLy8gPT4gJ2InXFxuICAgICAqXFxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XFxuICAgICAqIC8vID0+ICdjJ1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcXG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XFxuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxcbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XFxuICAgICAqXFxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XFxuICAgICAqIC8vID0+IFs0LCAxXVxcbiAgICAgKi9cXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXFxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxcbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xcbiAgICAgKlxcbiAgICAgKiBmdW5jKCcxJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogZnVuYyhudWxsKTtcXG4gICAgICogLy8gPT4gZmFsc2VcXG4gICAgICpcXG4gICAgICogZnVuYyhOYU4pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxcbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xcbiAgICAgKlxcbiAgICAgKiBmdW5jKCcxJyk7XFxuICAgICAqIC8vID0+IHRydWVcXG4gICAgICpcXG4gICAgICogZnVuYyhudWxsKTtcXG4gICAgICogLy8gPT4gdHJ1ZVxcbiAgICAgKlxcbiAgICAgKiBmdW5jKE5hTik7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDIuNC4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cXG4gICAgICogXTtcXG4gICAgICpcXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xcbiAgICAgKiAvLyA9PiBbMiwgMV1cXG4gICAgICpcXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcXG4gICAgICogLy8gPT4gWzEsIDJdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XFxuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4wLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XFxuICAgICAqXFxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcXG4gICAgICogLy8gPT4gWzIsIDBdXFxuICAgICAqXFxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xcbiAgICAgKiAvLyA9PiBbMiwgMF1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcXG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxcbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxcbiAgICAgKlxcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXFxuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXFxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5yYW5nZSg0KTtcXG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXFxuICAgICAqXFxuICAgICAqIF8ucmFuZ2UoLTQpO1xcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cXG4gICAgICpcXG4gICAgICogXy5yYW5nZSgxLCA1KTtcXG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXFxuICAgICAqXFxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XFxuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cXG4gICAgICpcXG4gICAgICogXy5yYW5nZSgwKTtcXG4gICAgICogLy8gPT4gW11cXG4gICAgICovXFxuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXFxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXFxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcXG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXFxuICAgICAqXFxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XFxuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XFxuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxcbiAgICAgKlxcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcXG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXFxuICAgICAqXFxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcXG4gICAgICogLy8gPT4gWzEsIDEsIDFdXFxuICAgICAqXFxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcXG4gICAgICogLy8gPT4gW11cXG4gICAgICovXFxuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjEzLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcXG4gICAgICogLy8gPT4gW1tdLCBbXV1cXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xcbiAgICAgKiAvLyA9PiBmYWxzZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xcbiAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjEzLjBcXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XFxuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4xMy4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xcbiAgICAgKlxcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcXG4gICAgICogLy8gPT4gW3t9LCB7fV1cXG4gICAgICpcXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XFxuICAgICAqIC8vID0+IGZhbHNlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xcbiAgICAgIHJldHVybiB7fTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMTMuMFxcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcXG4gICAgICogLy8gPT4gWycnLCAnJ11cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XFxuICAgICAgcmV0dXJuICcnO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4xMy4wXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcXG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IFV0aWxcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cXG4gICAgICpcXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XFxuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcXG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XFxuXFxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XFxuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xcblxcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XFxuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XFxuICAgICAgICBpdGVyYXRlZShpbmRleCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXFxuICAgICAqXFxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XFxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XFxuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcXG4gICAgICpcXG4gICAgICogXy51bmlxdWVJZCgpO1xcbiAgICAgKiAvLyA9PiAnMTA1J1xcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XFxuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XFxuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcXG4gICAgfVxcblxcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjQuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmFkZCg2LCA0KTtcXG4gICAgICogLy8gPT4gMTBcXG4gICAgICovXFxuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XFxuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcXG4gICAgfSwgMCk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSAzLjEwLjBcXG4gICAgICogQGNhdGVnb3J5IE1hdGhcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5jZWlsKDQuMDA2KTtcXG4gICAgICogLy8gPT4gNVxcbiAgICAgKlxcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xcbiAgICAgKiAvLyA9PiA2LjAxXFxuICAgICAqXFxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XFxuICAgICAqIC8vID0+IDYxMDBcXG4gICAgICovXFxuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC43LjBcXG4gICAgICogQGNhdGVnb3J5IE1hdGhcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xcbiAgICAgKiAvLyA9PiAxLjVcXG4gICAgICovXFxuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XFxuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcXG4gICAgfSwgMSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDMuMTAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcXG4gICAgICogLy8gPT4gNFxcbiAgICAgKlxcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcXG4gICAgICogLy8gPT4gMC4wNFxcbiAgICAgKlxcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcXG4gICAgICogLy8gPT4gNDAwMFxcbiAgICAgKi9cXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQHNpbmNlIDAuMS4wXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xcbiAgICAgKiAvLyA9PiA4XFxuICAgICAqXFxuICAgICAqIF8ubWF4KFtdKTtcXG4gICAgICogLy8gPT4gdW5kZWZpbmVkXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxcbiAgICAgICAgOiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgNC4wLjBcXG4gICAgICogQGNhdGVnb3J5IE1hdGhcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XFxuICAgICAqXFxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcXG4gICAgICogLy8gPT4geyAnbic6IDIgfVxcbiAgICAgKlxcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcXG4gICAgICAgIDogdW5kZWZpbmVkO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuMC4wXFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xcbiAgICAgKiAvLyA9PiA1XFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XFxuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXFxuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXFxuICAgICAqXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQHNpbmNlIDQuNy4wXFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XFxuICAgICAqXFxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XFxuICAgICAqIC8vID0+IDVcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XFxuICAgICAqIC8vID0+IDVcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcXG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAc2luY2UgMC4xLjBcXG4gICAgICogQG1lbWJlck9mIF9cXG4gICAgICogQGNhdGVnb3J5IE1hdGhcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XFxuICAgICAqIC8vID0+IDJcXG4gICAgICpcXG4gICAgICogXy5taW4oW10pO1xcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXFxuICAgICAgICA6IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcXG4gICAgICpcXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XFxuICAgICAqXFxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XFxuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxcbiAgICAgICAgOiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjcuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcXG4gICAgICogLy8gPT4gMjRcXG4gICAgICovXFxuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XFxuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XFxuICAgIH0sIDEpO1xcblxcbiAgICAvKipcXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy4xMC4wXFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xcbiAgICAgKiAvLyA9PiA0XFxuICAgICAqXFxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xcbiAgICAgKiAvLyA9PiA0LjAxXFxuICAgICAqXFxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xcbiAgICAgKiAvLyA9PiA0MTAwXFxuICAgICAqL1xcbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqXFxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XFxuICAgICAqIC8vID0+IDJcXG4gICAgICovXFxuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcXG4gICAgfSwgMCk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cXG4gICAgICpcXG4gICAgICogQHN0YXRpY1xcbiAgICAgKiBAbWVtYmVyT2YgX1xcbiAgICAgKiBAc2luY2UgMy40LjBcXG4gICAgICogQGNhdGVnb3J5IE1hdGhcXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKlxcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xcbiAgICAgKiAvLyA9PiAyMFxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XFxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXFxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxcbiAgICAgICAgOiAwO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXFxuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXFxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEBzaW5jZSA0LjAuMFxcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICpcXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XFxuICAgICAqXFxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcXG4gICAgICogLy8gPT4gMjBcXG4gICAgICpcXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXFxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcXG4gICAgICogLy8gPT4gMjBcXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXFxuICAgICAgICA6IDA7XFxuICAgIH1cXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXFxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcXG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcXG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xcbiAgICBsb2Rhc2guYXQgPSBhdDtcXG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcXG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XFxuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcXG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcXG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XFxuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XFxuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XFxuICAgIGxvZGFzaC5jb25kID0gY29uZDtcXG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XFxuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XFxuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XFxuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XFxuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcXG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcXG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XFxuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XFxuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XFxuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XFxuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XFxuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XFxuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XFxuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcXG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XFxuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XFxuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcXG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XFxuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XFxuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcXG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcXG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XFxuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XFxuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XFxuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XFxuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcXG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XFxuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcXG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcXG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcXG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XFxuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XFxuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcXG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XFxuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XFxuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XFxuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcXG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcXG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcXG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XFxuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcXG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcXG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcXG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XFxuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcXG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcXG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcXG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcXG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XFxuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcXG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcXG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XFxuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XFxuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XFxuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XFxuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcXG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XFxuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcXG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XFxuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XFxuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcXG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcXG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XFxuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XFxuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcXG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcXG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcXG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcXG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XFxuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcXG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XFxuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XFxuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XFxuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcXG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcXG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XFxuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XFxuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XFxuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcXG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcXG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XFxuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcXG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcXG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcXG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcXG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcXG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xcbiAgICBsb2Rhc2gueG9yID0geG9yO1xcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcXG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xcbiAgICBsb2Rhc2guemlwID0gemlwO1xcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XFxuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcXG5cXG4gICAgLy8gQWRkIGFsaWFzZXMuXFxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcXG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcXG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcXG5cXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxcbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XFxuXFxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXFxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XFxuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcXG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcXG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XFxuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcXG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcXG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XFxuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XFxuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XFxuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XFxuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xcbiAgICBsb2Rhc2guZXEgPSBlcTtcXG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcXG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcXG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XFxuICAgIGxvZGFzaC5maW5kID0gZmluZDtcXG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcXG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcXG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcXG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XFxuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcXG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcXG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XFxuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcXG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcXG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XFxuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XFxuICAgIGxvZGFzaC5ndCA9IGd0O1xcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcXG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcXG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XFxuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcXG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcXG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XFxuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcXG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcXG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XFxuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XFxuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XFxuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcXG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcXG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcXG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcXG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XFxuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcXG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XFxuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcXG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XFxuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XFxuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcXG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcXG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcXG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcXG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcXG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcXG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcXG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XFxuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XFxuICAgIGxvZGFzaC5sdCA9IGx0O1xcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcXG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xcbiAgICBsb2Rhc2gubWluID0gbWluO1xcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcXG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcXG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcXG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XFxuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcXG4gICAgbG9kYXNoLm50aCA9IG50aDtcXG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XFxuICAgIGxvZGFzaC5ub3cgPSBub3c7XFxuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XFxuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XFxuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcXG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcXG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcXG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XFxuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XFxuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcXG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcXG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XFxuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XFxuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XFxuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcXG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcXG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcXG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XFxuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XFxuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcXG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcXG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcXG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcXG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XFxuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcXG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XFxuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XFxuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XFxuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XFxuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XFxuICAgIGxvZGFzaC50cmltID0gdHJpbTtcXG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcXG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XFxuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XFxuXFxuICAgIC8vIEFkZCBhbGlhc2VzLlxcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XFxuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XFxuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XFxuXFxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcXG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XFxuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHNvdXJjZTtcXG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcXG5cXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiAgICAvKipcXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxcbiAgICAgKlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBtZW1iZXJPZiBfXFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgICAqL1xcbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XFxuXFxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcXG4gICAgfSk7XFxuXFxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XFxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcXG5cXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcXG5cXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XFxuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XFxuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH07XFxuXFxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuXFxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcXG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XFxuXFxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XFxuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcXG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH07XFxuICAgIH0pO1xcblxcbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXFxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XFxuXFxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG5cXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxcbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcXG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xcblxcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuXFxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcXG4gICAgfTtcXG5cXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XFxuICAgIH07XFxuXFxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XFxuICAgIH07XFxuXFxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XFxuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xcbiAgICB9O1xcblxcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XFxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xcblxcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcXG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcXG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xcbiAgICB9O1xcblxcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XFxuICAgIH07XFxuXFxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxcbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XFxuXFxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcXG5cXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcXG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XFxuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcXFwibGVuZ3RoXFxcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XFxuXFxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XFxuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcXG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcXG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuXFxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxcbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcXG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xcblxcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcXG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuXFxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcXG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcXG4gICAgICBpZiAobG9kYXNoRnVuYykge1xcbiAgICAgICAgdmFyIGtleSA9IChsb2Rhc2hGdW5jLm5hbWUgKyAnJyksXFxuICAgICAgICAgICAgbmFtZXMgPSByZWFsTmFtZXNba2V5XSB8fCAocmVhbE5hbWVzW2tleV0gPSBbXSk7XFxuXFxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXFxuICAgIH1dO1xcblxcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XFxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XFxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcXG5cXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXFxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XFxuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XFxuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcXG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XFxuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XFxuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XFxuXFxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXFxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XFxuXFxuICAgIGlmIChzeW1JdGVyYXRvcikge1xcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XFxuICAgIH1cXG4gICAgcmV0dXJuIGxvZGFzaDtcXG4gIH0pO1xcblxcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuICAvLyBFeHBvcnQgbG9kYXNoLlxcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcXG5cXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxcbiAgaWYgKHRydWUpIHtcXG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxcbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxcbiAgICByb290Ll8gPSBfO1xcblxcbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcXFwidW5kZXJzY29yZVxcXCIgbW9kdWxlLlxcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBfO1xcbiAgICB9KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfVxcbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXFxuICBlbHNlIHt9XFxufS5jYWxsKHRoaXMpKTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ob21lL2FsYW4vLm52bS92ZXJzaW9ucy9ub2RlL3Y5LjExLjEvbGliL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFxcXCIuLi8uLi8uLi8uLi8uLi9ob21lL2FsYW4vLm52bS92ZXJzaW9ucy9ub2RlL3Y5LjExLjEvbGliL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hbGFuLy5udm0vdmVyc2lvbnMvbm9kZS92OS4xMS4xL2xpYi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcyAqLyBcXFwiLi4vLi4vLi4vLi4vLi4vaG9tZS9hbGFuLy5udm0vdmVyc2lvbnMvbm9kZS92OS4xMS4xL2xpYi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xcXCIpKG1vZHVsZSkpKVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0RhdGFUYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaW5kZXguY2xpZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC5jbGllbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNoYW5nZXNldHMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2RpZmZfanNvbl9kaXN0X2NoYW5nZXNldHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL25vZGVfbW9kdWxlcy9kaWZmLWpzb24vZGlzdC9jaGFuZ2VzZXRzICovIFxcXCIuL25vZGVfbW9kdWxlcy9kaWZmLWpzb24vZGlzdC9jaGFuZ2VzZXRzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfZGlmZl9qc29uX2Rpc3RfY2hhbmdlc2V0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfZGlmZl9qc29uX2Rpc3RfY2hhbmdlc2V0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChkZWZhdWx0IGZyb20gbm9uLWhhcm1vbnkpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY2hhbmdlc2V0c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX25vZGVfbW9kdWxlc19kaWZmX2pzb25fZGlzdF9jaGFuZ2VzZXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hOyB9KTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EYXRhVGFibGUvLi9zcmMvaW5kZXguY2xpZW50LmpzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTsiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJib1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJib1wiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vaW5kZXguY2xpZW50LmdlbmVyYXRlZC5qc1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL2luZGV4LmNsaWVudC5nZW5lcmF0ZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXguY2xpZW50LmdlbmVyYXRlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvYXJyYXktYXZlcmFnZS5qcyAqLyBcXFwiLi9zcmMvYXJyYXktYXZlcmFnZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9hcnJheS1ub3JtYWxpemUuanMgKi8gXFxcIi4vc3JjL2FycmF5LW5vcm1hbGl6ZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9hcnJheS1wZXJjZW50LXJhbmdlLmpzICovIFxcXCIuL3NyYy9hcnJheS1wZXJjZW50LXJhbmdlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2FycmF5LXRvLW9iamVjdC5qcyAqLyBcXFwiLi9zcmMvYXJyYXktdG8tb2JqZWN0LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2NoZWNrLWRhdGEtdHlwZXMtZXF1YWwuanMgKi8gXFxcIi4vc3JjL2NoZWNrLWRhdGEtdHlwZXMtZXF1YWwuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvY3JlYXRlLXN2Zy1pbi1tZW1vcnktbm9kZS5qcyAqLyBcXFwiLi9zcmMvY3JlYXRlLXN2Zy1pbi1tZW1vcnktbm9kZS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9kMy1zaW1wbGUtYmFyLWNoYXJ0LmpzICovIFxcXCIuL3NyYy9kMy1zaW1wbGUtYmFyLWNoYXJ0LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2QzLXNwYXJrbGluZS5qcyAqLyBcXFwiLi9zcmMvZDMtc3BhcmtsaW5lLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2RpZmYtbnVtZXJpYy1zdHJpbmdzLmpzICovIFxcXCIuL3NyYy9kaWZmLW51bWVyaWMtc3RyaW5ncy5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9mb3JtYXQtbnVtYmVyLWFzLWN1cnJlbmN5LmpzICovIFxcXCIuL3NyYy9mb3JtYXQtbnVtYmVyLWFzLWN1cnJlbmN5LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2Zvcm1hdC1udW1iZXItYXMuanMgKi8gXFxcIi4vc3JjL2Zvcm1hdC1udW1iZXItYXMuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvZ2V0LXJhbmRvbS1pbnQuanMgKi8gXFxcIi4vc3JjL2dldC1yYW5kb20taW50LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2h0bWwtcG9sbC1lbGVtZW50LmpzICovIFxcXCIuL3NyYy9odG1sLXBvbGwtZWxlbWVudC5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9odG1sLXRvZ2dsZS1jbGFzcy5qcyAqLyBcXFwiLi9zcmMvaHRtbC10b2dnbGUtY2xhc3MuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvaXMtZmxvYXQuanMgKi8gXFxcIi4vc3JjL2lzLWZsb2F0LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2lzLWludGVnZXIuanMgKi8gXFxcIi4vc3JjL2lzLWludGVnZXIuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvaXMtbnVtYmVyLmpzICovIFxcXCIuL3NyYy9pcy1udW1iZXIuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbnVtYmVyLWdyb3VwLWRpZ2l0cy5qcyAqLyBcXFwiLi9zcmMvbnVtYmVyLWdyb3VwLWRpZ2l0cy5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9udW1iZXItbm9ybWFsaXplLmpzICovIFxcXCIuL3NyYy9udW1iZXItbm9ybWFsaXplLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL251bWJlci1zY2FsZS5qcyAqLyBcXFwiLi9zcmMvbnVtYmVyLXNjYWxlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL29iamVjdC1nZXQtbmVzdGVkLXByb3BlcnR5LmpzICovIFxcXCIuL3NyYy9vYmplY3QtZ2V0LW5lc3RlZC1wcm9wZXJ0eS5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9vYmplY3QtaXMtZW1wdHktb2JqZWN0LmpzICovIFxcXCIuL3NyYy9vYmplY3QtaXMtZW1wdHktb2JqZWN0LmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL29iamVjdC1pcy1vYmplY3QuanMgKi8gXFxcIi4vc3JjL29iamVjdC1pcy1vYmplY3QuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvb2JqZWN0LXRvLWFycmF5LmpzICovIFxcXCIuL3NyYy9vYmplY3QtdG8tYXJyYXkuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcGFydGlhbC1hcHBsaWNhdGlvbi5qcyAqLyBcXFwiLi9zcmMvcGFydGlhbC1hcHBsaWNhdGlvbi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9zdHJpbmctY2FtZWxjYXNlLmpzICovIFxcXCIuL3NyYy9zdHJpbmctY2FtZWxjYXNlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3N0cmluZy1jYXBpdGFsaXplLWZpcnN0LWxldHRlci5qcyAqLyBcXFwiLi9zcmMvc3RyaW5nLWNhcGl0YWxpemUtZmlyc3QtbGV0dGVyLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3RpbWUtYWdvLmpzICovIFxcXCIuL3NyYy90aW1lLWFnby5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy90aW1lc2VyaWVzLXBydW5lLmpzICovIFxcXCIuL3NyYy90aW1lc2VyaWVzLXBydW5lLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3RpbWVzZXJpZXMtcmVzY2FsZS5qcyAqLyBcXFwiLi9zcmMvdGltZXNlcmllcy1yZXNjYWxlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3RpbWVzZXJpZXMtc2NhbGUuanMgKi8gXFxcIi4vc3JjL3RpbWVzZXJpZXMtc2NhbGUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvdGltZXNlcmllcy10aGluLmpzICovIFxcXCIuL3NyYy90aW1lc2VyaWVzLXRoaW4uanNcXFwiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cywgX2FycmF5QXZlcmFnZSwgX2FycmF5Tm9ybWFsaXplLCBfYXJyYXlQZXJjZW50UmFuZ2UsIF9hcnJheVRvT2JqZWN0LCBfY2hlY2tEYXRhVHlwZXNFcXVhbCwgX2NyZWF0ZVN2Z0luTWVtb3J5Tm9kZSwgX2QzU2ltcGxlQmFyQ2hhcnQsIF9kM1NwYXJrbGluZSwgX2RpZmZOdW1lcmljU3RyaW5ncywgX2Zvcm1hdE51bWJlckFzQ3VycmVuY3ksIF9mb3JtYXROdW1iZXJBcywgX2dldFJhbmRvbUludCwgX2h0bWxQb2xsRWxlbWVudCwgX2h0bWxUb2dnbGVDbGFzcywgX2lzRmxvYXQsIF9pc0ludGVnZXIsIF9pc051bWJlciwgX251bWJlckdyb3VwRGlnaXRzLCBfbnVtYmVyTm9ybWFsaXplLCBfbnVtYmVyU2NhbGUsIF9vYmplY3RHZXROZXN0ZWRQcm9wZXJ0eSwgX29iamVjdElzRW1wdHlPYmplY3QsIF9vYmplY3RJc09iamVjdCwgX29iamVjdFRvQXJyYXksIF9wYXJ0aWFsQXBwbGljYXRpb24sIF9zdHJpbmdDYW1lbGNhc2UsIF9zdHJpbmdDYXBpdGFsaXplRmlyc3RMZXR0ZXIsIF90aW1lQWdvLCBfdGltZXNlcmllc1BydW5lLCBfdGltZXNlcmllc1Jlc2NhbGUsIF90aW1lc2VyaWVzU2NhbGUsIF90aW1lc2VyaWVzVGhpbikge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiYXJyYXlBdmVyYWdlXFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2FycmF5QXZlcmFnZS5kZWZhdWx0O1xcbiAgICB9XFxuICB9KTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcImFycmF5Tm9ybWFsaXplXFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2FycmF5Tm9ybWFsaXplLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiYXJyYXlQZXJjZW50UmFuZ2VcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfYXJyYXlQZXJjZW50UmFuZ2UuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJhcnJheVRvT2JqZWN0XFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2FycmF5VG9PYmplY3QuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJjaGVja0RhdGFUeXBlc0VxdWFsXFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2NoZWNrRGF0YVR5cGVzRXF1YWwuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJjcmVhdGVTdmdJbk1lbW9yeU5vZGVcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfY3JlYXRlU3ZnSW5NZW1vcnlOb2RlLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiZDNTaW1wbGVCYXJDaGFydFxcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9kM1NpbXBsZUJhckNoYXJ0LmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiZDNTcGFya2xpbmVcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfZDNTcGFya2xpbmUuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJkaWZmTnVtZXJpY1N0cmluZ3NcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfZGlmZk51bWVyaWNTdHJpbmdzLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiZm9ybWF0TnVtYmVyQXNDdXJyZW5jeVxcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9mb3JtYXROdW1iZXJBc0N1cnJlbmN5LmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiZm9ybWF0TnVtYmVyQXNcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfZm9ybWF0TnVtYmVyQXMuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJnZXRSYW5kb21JbnRcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfZ2V0UmFuZG9tSW50LmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiaHRtbFBvbGxFbGVtZW50XFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2h0bWxQb2xsRWxlbWVudC5kZWZhdWx0O1xcbiAgICB9XFxuICB9KTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcImh0bWxUb2dnbGVDbGFzc1xcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9odG1sVG9nZ2xlQ2xhc3MuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJpc0Zsb2F0XFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2lzRmxvYXQuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJpc0ludGVnZXJcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfaXNJbnRlZ2VyLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiaXNOdW1iZXJcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfaXNOdW1iZXIuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJudW1iZXJHcm91cERpZ2l0c1xcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9udW1iZXJHcm91cERpZ2l0cy5kZWZhdWx0O1xcbiAgICB9XFxuICB9KTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIm51bWJlck5vcm1hbGl6ZVxcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9udW1iZXJOb3JtYWxpemUuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJudW1iZXJTY2FsZVxcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9udW1iZXJTY2FsZS5kZWZhdWx0O1xcbiAgICB9XFxuICB9KTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIm9iamVjdEdldE5lc3RlZFByb3BlcnR5XFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX29iamVjdEdldE5lc3RlZFByb3BlcnR5LmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwib2JqZWN0SXNFbXB0eU9iamVjdFxcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9vYmplY3RJc0VtcHR5T2JqZWN0LmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwib2JqZWN0SXNPYmplY3RcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfb2JqZWN0SXNPYmplY3QuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJvYmplY3RUb0FycmF5XFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX29iamVjdFRvQXJyYXkuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJwYXJ0aWFsQXBwbGljYXRpb25cXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfcGFydGlhbEFwcGxpY2F0aW9uLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwic3RyaW5nQ2FtZWxjYXNlXFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX3N0cmluZ0NhbWVsY2FzZS5kZWZhdWx0O1xcbiAgICB9XFxuICB9KTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcInN0cmluZ0NhcGl0YWxpemVGaXJzdExldHRlclxcXCIsIHtcXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIF9zdHJpbmdDYXBpdGFsaXplRmlyc3RMZXR0ZXIuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJ0aW1lQWdvXFxcIiwge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX3RpbWVBZ28uZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJ0aW1lc2VyaWVzUHJ1bmVcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfdGltZXNlcmllc1BydW5lLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwidGltZXNlcmllc1Jlc2NhbGVcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfdGltZXNlcmllc1Jlc2NhbGUuZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJ0aW1lc2VyaWVzU2NhbGVcXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfdGltZXNlcmllc1NjYWxlLmRlZmF1bHQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwidGltZXNlcmllc1RoaW5cXFwiLCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBfdGltZXNlcmllc1RoaW4uZGVmYXVsdDtcXG4gICAgfVxcbiAgfSk7XFxuICBfYXJyYXlBdmVyYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlBdmVyYWdlKTtcXG4gIF9hcnJheU5vcm1hbGl6ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5Tm9ybWFsaXplKTtcXG4gIF9hcnJheVBlcmNlbnRSYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5UGVyY2VudFJhbmdlKTtcXG4gIF9hcnJheVRvT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlUb09iamVjdCk7XFxuICBfY2hlY2tEYXRhVHlwZXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NoZWNrRGF0YVR5cGVzRXF1YWwpO1xcbiAgX2NyZWF0ZVN2Z0luTWVtb3J5Tm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN2Z0luTWVtb3J5Tm9kZSk7XFxuICBfZDNTaW1wbGVCYXJDaGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2QzU2ltcGxlQmFyQ2hhcnQpO1xcbiAgX2QzU3BhcmtsaW5lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZDNTcGFya2xpbmUpO1xcbiAgX2RpZmZOdW1lcmljU3RyaW5ncyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RpZmZOdW1lcmljU3RyaW5ncyk7XFxuICBfZm9ybWF0TnVtYmVyQXNDdXJyZW5jeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zvcm1hdE51bWJlckFzQ3VycmVuY3kpO1xcbiAgX2Zvcm1hdE51bWJlckFzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9ybWF0TnVtYmVyQXMpO1xcbiAgX2dldFJhbmRvbUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFJhbmRvbUludCk7XFxuICBfaHRtbFBvbGxFbGVtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaHRtbFBvbGxFbGVtZW50KTtcXG4gIF9odG1sVG9nZ2xlQ2xhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9odG1sVG9nZ2xlQ2xhc3MpO1xcbiAgX2lzRmxvYXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0Zsb2F0KTtcXG4gIF9pc0ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0ludGVnZXIpO1xcbiAgX2lzTnVtYmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNOdW1iZXIpO1xcbiAgX251bWJlckdyb3VwRGlnaXRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbnVtYmVyR3JvdXBEaWdpdHMpO1xcbiAgX251bWJlck5vcm1hbGl6ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX251bWJlck5vcm1hbGl6ZSk7XFxuICBfbnVtYmVyU2NhbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9udW1iZXJTY2FsZSk7XFxuICBfb2JqZWN0R2V0TmVzdGVkUHJvcGVydHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RHZXROZXN0ZWRQcm9wZXJ0eSk7XFxuICBfb2JqZWN0SXNFbXB0eU9iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdElzRW1wdHlPYmplY3QpO1xcbiAgX29iamVjdElzT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0SXNPYmplY3QpO1xcbiAgX29iamVjdFRvQXJyYXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RUb0FycmF5KTtcXG4gIF9wYXJ0aWFsQXBwbGljYXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJ0aWFsQXBwbGljYXRpb24pO1xcbiAgX3N0cmluZ0NhbWVsY2FzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ0NhbWVsY2FzZSk7XFxuICBfc3RyaW5nQ2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nQ2FwaXRhbGl6ZUZpcnN0TGV0dGVyKTtcXG4gIF90aW1lQWdvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZUFnbyk7XFxuICBfdGltZXNlcmllc1BydW5lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZXNlcmllc1BydW5lKTtcXG4gIF90aW1lc2VyaWVzUmVzY2FsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVzZXJpZXNSZXNjYWxlKTtcXG4gIF90aW1lc2VyaWVzU2NhbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lc2VyaWVzU2NhbGUpO1xcbiAgX3RpbWVzZXJpZXNUaGluID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZXNlcmllc1RoaW4pO1xcblxcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL2luZGV4LmNsaWVudC5nZW5lcmF0ZWQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9hcnJheS1hdmVyYWdlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYXJyYXktYXZlcmFnZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBBcnJheSBBdmVyYWdlXFxuICAgKlxcbiAgICogVGFrZSB0aGUgYXZlcmFnZSBvZiBhbGwgdGhlIG51bWJlcnMgaW4gYW4gYXJyYXlcXG4gICAqXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIGFycmF5IG9mIG51bWJlcnNcXG4gICAqIEByZXR1cm4ge051bWJlcn1cXG4gICAqXFxuICAgKi9cXG4gIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KGFycmF5KSB7XFxuICAgIHZhciB0b3RhbCA9IDA7XFxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHgpIHtcXG4gICAgICByZXR1cm4gdG90YWwgKz0geDtcXG4gICAgfSk7XFxuICAgIHJldHVybiB0b3RhbCAvIGFycmF5Lmxlbmd0aDtcXG4gIH07XFxuXFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvYXJyYXktYXZlcmFnZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2FycmF5LW5vcm1hbGl6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYXJyYXktbm9ybWFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL251bWJlci1ub3JtYWxpemUuanMgKi8gXFxcIi4vc3JjL251bWJlci1ub3JtYWxpemUuanNcXFwiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cywgX251bWJlck5vcm1hbGl6ZSkge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcXG4gIF9udW1iZXJOb3JtYWxpemUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9udW1iZXJOb3JtYWxpemUpO1xcblxcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxcblxcbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVxcXCIpOyB9XFxuXFxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcXFwiW29iamVjdCBBcmd1bWVudHNdXFxcIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cXG5cXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIEFycmF5IE5vcm1hbGl6ZVxcbiAgICpcXG4gICAqIEFwcGxpZXMgdGhlIG5vcm1hbGl6ZSBmdW5jdGlvbiB0byBhbiBhcnJheSBvZiBudW1iZXJzXFxuICAgKlxcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gYmUgbm9ybWFsaXplZFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbiAtIHRoZSBtaW4gcmFuZ2UgdG8gYXBwbHlcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggLSB0aGUgbWF4IHJhbmdlIHRvIGFwcGx5XFxuICAgKiBAcmV0dXJuIHtBcnJheX0gcmV0dXJuIHRoZSBub3JtYWxpemVkIGFycmF5XFxuICAgKlxcbiAgICovXFxuICB2YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChhcnJheSwgbWluLCBtYXgpIHtcXG4gICAgdmFyIGFNYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcXG4gICAgdmFyIGFNaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcXG4gICAgdmFyIHJlc3VsdCA9IGFycmF5Lm1hcChmdW5jdGlvbiAobikge1xcbiAgICAgIHJldHVybiAoMCwgX251bWJlck5vcm1hbGl6ZS5kZWZhdWx0KShuLCBtaW4sIG1heCwgYU1pbiwgYU1heCk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfTtcXG5cXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9hcnJheS1ub3JtYWxpemUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9hcnJheS1wZXJjZW50LXJhbmdlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYXJyYXktcGVyY2VudC1yYW5nZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBQZXJjZW50IFJhbmdlXFxuICAgKlxcbiAgICogQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIGNoYW5nZSBiZXR3ZWVuIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHZhbHVlc1xcbiAgICogaW4gdGhlIGFycmF5IGNvbXBhcmVkIHRvIHRoZSBmaXJzdCB2YWx1ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gYXJyYXkgb2YgbnVtYmVyc1xcbiAgICogQHJldHVybiB7TnVtYmVyfVxcbiAgICpcXG4gICAqXFxuICAgKi9cXG4gIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KGFycmF5KSB7XFxuICAgIHZhciBvbGRlc3QgPSBhcnJheVswXTtcXG4gICAgdmFyIG1pbiA9IGQzLm1pbihhcnJheSk7XFxuICAgIHZhciBtYXggPSBkMy5tYXgoYXJyYXkpO1xcbiAgICB2YXIgZGlmZiA9IG1heCAtIG1pbjtcXG4gICAgdmFyIHJlc3VsdCA9IE1hdGgucm91bmQoZGlmZiAvIChvbGRlc3QgLyAxMDApKTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH07XFxuXFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvYXJyYXktcGVyY2VudC1yYW5nZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2FycmF5LXRvLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYXJyYXktdG8tb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xcblxcbiAgLyoqXFxuICAgKlxcbiAgICogQXJyYXkgdG8gT2JqZWN0XFxuICAgKlxcbiAgICogQ29udmVydCBhbiBhcnJheSBvZiBPYmplY3RzIHRvIGFuIE9iamVjdCBvZiBPYmplY3RzXFxuICAgKiB2aWEgb25lIG9mIHRoZSBPYmplY3RzIGZpZWxkcyBhcyB0aGUgSWRcXG4gICAqXFxuICAgKiBgYGBcXG4gICAqIC8vIGlucHV0XFxuICAgKiBjb25zdCBhcnJheSA9IFtcXG4gICAqICAge2lkOiAxLCBmb286ICdiYXInfSxcXG4gICAqICAge2lkOiAyLCBiYXo6ICdxdXgnfSxcXG4gICAqIF1cXG4gICAqXFxuICAgKiBhcnJheVRvT2JqZWN0KGFycmF5LCAnaWQnKTtcXG4gICAqXFxuICAgKiAvLyBvdXRwdXRcXG4gICAqIHtcXG4gICAqICAgMToge2lkOiAxLCBmb286ICdiYXInfVxcbiAgICogICAyOiB7aWQ6IDIsIGJhejogJ3F1eCd9XFxuICAgKiB9XFxuICAgKiBgYGBcXG4gICAqXFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIGFuIEFycmF5IG9mIE9iamVjdHNcXG4gICAqIEBwYXJhbSB7ZmllbGR9IGZpZWxkIC0gZmllbGQgdG8gdXNlIGFzIGEga2V5XFxuICAgKiBAcmV0dXJuIHtPYmplY2N0fVxcbiAgICpcXG4gICAqL1xcbiAgdmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoYXJyYXksIGZpZWxkKSB7XFxuICAgIHZhciByZXN1bHQgPSB7fTtcXG4gICAgdmFyIG9iajtcXG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcXG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xcblxcbiAgICB0cnkge1xcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFycmF5W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xcbiAgICAgICAgb2JqID0gX3N0ZXAudmFsdWU7XFxuICAgICAgICByZXN1bHRbb2JqW2ZpZWxkXV0gPSBvYmo7XFxuICAgICAgfVxcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XFxuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcXG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcXG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9O1xcblxcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL2FycmF5LXRvLW9iamVjdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NoZWNrLWRhdGEtdHlwZXMtZXF1YWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jaGVjay1kYXRhLXR5cGVzLWVxdWFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgJ3VzZSBzdHJpY3QnO1xcbiAgLyoqXFxuICAgKlxcbiAgICogQ2hlY2sgRGF0YSBUeXBlcyBFcXVhbFxcbiAgICpcXG4gICAqIFRPRE86IHVwZGF0ZSB0byBzdXBwb3J0IGFuIGFyYnJpdGFyeSBudW1iZXIgb2YgYXJndW1lbnRzXFxuICAgKlxcbiAgICovXFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gY2hlY2tEYXRhVHlwZXNFcXVhbDtcXG5cXG4gIGZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzRXF1YWwoZGF0YTEsIGRhdGEyKSB7XFxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YTEpID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YTIpO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL2NoZWNrLWRhdGEtdHlwZXMtZXF1YWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jcmVhdGUtc3ZnLWluLW1lbW9yeS1ub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3JlYXRlLXN2Zy1pbi1tZW1vcnktbm9kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBDcmVhdGUgYW4gU1ZHIG5vZGUgd2l0aG91dCBhZGRpbmcgaXQgdG8gdGhlIERPTVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB0aGUgdHlwZSBvZiBub2RlIHRvIGNyZWF0ZSwgZS5nLiAncmVjdCcsICdnJyBldGNcXG4gICAqIEByZXR1cm4ge0QzTm9kZU9iamVjdH0gLSBhIEQzIG5vZGVcXG4gICAqXFxuICAgKi9cXG4gIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KHR5cGUpIHtcXG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0eXBlKTtcXG4gICAgcmV0dXJuIGQzLnNlbGVjdChlbG0pO1xcbiAgfTtcXG5cXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9jcmVhdGUtc3ZnLWluLW1lbW9yeS1ub2RlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZDMtc2ltcGxlLWJhci1jaGFydC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2QzLXNpbXBsZS1iYXItY2hhcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZS1zdmctaW4tbWVtb3J5LW5vZGUuanMgKi8gXFxcIi4vc3JjL2NyZWF0ZS1zdmctaW4tbWVtb3J5LW5vZGUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcnJheS1wZXJjZW50LXJhbmdlLmpzICovIFxcXCIuL3NyYy9hcnJheS1wZXJjZW50LXJhbmdlLmpzXFxcIildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMsIF9jcmVhdGVTdmdJbk1lbW9yeU5vZGUsIF9hcnJheVBlcmNlbnRSYW5nZSkge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcXG4gIF9jcmVhdGVTdmdJbk1lbW9yeU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVTdmdJbk1lbW9yeU5vZGUpO1xcbiAgX2FycmF5UGVyY2VudFJhbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlQZXJjZW50UmFuZ2UpO1xcblxcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxcblxcbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVxcXCIpOyB9XFxuXFxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcXFwiW29iamVjdCBBcmd1bWVudHNdXFxcIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cXG5cXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIEQzIFNpbXBsZSBCYXIgQ2hhcnRcXG4gICAqXFxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhbmdlIC0gc2hvdyB0aGUgcGVyY2VudCBmbHVjdHVhdGlvbiBvZiB0aGUgZGF0YVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aF1cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0XVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdHlsZXNdXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZpbGxdXFxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxcbiAgICpcXG4gICAqL1xcbiAgdmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoX3JlZikge1xcbiAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcXG4gICAgICAgIHJhbmdlID0gX3JlZi5yYW5nZSxcXG4gICAgICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxcbiAgICAgICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB2b2lkIDAgPyAxMDAgOiBfcmVmJHdpZHRoLFxcbiAgICAgICAgX3JlZiRoZWlnaHQgPSBfcmVmLmhlaWdodCxcXG4gICAgICAgIGhlaWdodCA9IF9yZWYkaGVpZ2h0ID09PSB2b2lkIDAgPyAzMCA6IF9yZWYkaGVpZ2h0LFxcbiAgICAgICAgX3JlZiRzdHlsZXMgPSBfcmVmLnN0eWxlcyxcXG4gICAgICAgIHN0eWxlcyA9IF9yZWYkc3R5bGVzID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkc3R5bGVzLFxcbiAgICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxcbiAgICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gJyNlZWUnIDogX3JlZiRmaWxsO1xcbiAgICB2YXIgcmFuZ2VYT2Zmc2V0ID0gcmFuZ2UgPyAyMCA6IDA7XFxuICAgIHZhciB4QXJyYXkgPSBkYXRhLm1hcChmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBkLng7XFxuICAgIH0pO1xcbiAgICB2YXIgeUFycmF5ID0gZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcXG4gICAgICByZXR1cm4gZC55O1xcbiAgICB9KTtcXG4gICAgdmFyIHlNYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoeUFycmF5KSk7XFxuICAgIHZhciB5TWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHlBcnJheSkpO1xcbiAgICB2YXIgc3ZnRWxlbWVudCA9ICgwLCBfY3JlYXRlU3ZnSW5NZW1vcnlOb2RlLmRlZmF1bHQpKCdzdmcnKS5hdHRyKCdzdHlsZScsICdwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogMCcpO1xcbiAgICB2YXIgc3ZnID0gc3ZnRWxlbWVudC5hdHRyKCd3aWR0aCcsIHdpZHRoKS5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpLmF0dHIoJ3N0eWxlJywgc3R5bGVzKS5hcHBlbmQoJ2cnKTtcXG4gICAgdmFyIHggPSBkMy5zY2FsZUJhbmQoKS5yYW5nZVJvdW5kKFtyYW5nZVhPZmZzZXQsIHdpZHRoXSkucGFkZGluZygwLjEpO1xcbiAgICB2YXIgeSA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2VSb3VuZChbaGVpZ2h0LCAwXSk7XFxuICAgIHguZG9tYWluKHhBcnJheSk7XFxuICAgIHkuZG9tYWluKFswLCB5TWF4XSk7XFxuICAgIHN2Zy5zZWxlY3RBbGwoKS5kYXRhKGRhdGEpLmVudGVyKCkuYXBwZW5kKCdyZWN0JykuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XFxuICAgICAgcmV0dXJuIHgoZC54KTtcXG4gICAgfSkuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XFxuICAgICAgcmV0dXJuIHkoZC55KTtcXG4gICAgfSkuYXR0cignZmlsbCcsIGZpbGwpLmF0dHIoJ3dpZHRoJywgeC5iYW5kd2lkdGgoKSkuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcXG4gICAgICByZXR1cm4gaGVpZ2h0IC0geShkLnkpO1xcbiAgICB9KTtcXG5cXG4gICAgaWYgKHJhbmdlKSB7XFxuICAgICAgdmFyIHZvbHVtZUFycmF5ID0gZGF0YS5tYXAoZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgIHJldHVybiB2Lnk7XFxuICAgICAgfSk7XFxuICAgICAgdmFyIHBlcmNlbnRTd2luZyA9ICgwLCBfYXJyYXlQZXJjZW50UmFuZ2UuZGVmYXVsdCkodm9sdW1lQXJyYXkpO1xcbiAgICAgIHZhciByYW5nZUdyb3VwID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2NyeXB0b2h1Yi1zcGFya2xpbmUtcmFuZ2UnKTtcXG4gICAgICByYW5nZUdyb3VwLmFwcGVuZCgndGl0bGUnKS50ZXh0KCdQZXJjZW50IGZsdWN0dWF0aW9uIG92ZXIgNyBkYXlzJyk7IC8vIHJhbmdlR3JvdXAuYXBwZW5kKCdyZWN0JylcXG4gICAgICAvLyAgIC5hdHRyKCd3aWR0aCcsICcyMCcpXFxuICAgICAgLy8gICAuYXR0cignaGVpZ2h0JywgJzEyJylcXG4gICAgICAvLyAgIC5hdHRyKCdmaWxsJywgJyNmZmYnKVxcbiAgICAgIC8vICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsICcwLjgnKVxcbiAgICAgIC8vICAgLmF0dHIoJ3gnLCAwKVxcbiAgICAgIC8vICAgLmF0dHIoJ3knLCAwKVxcbiAgICAgIC8vICAgLmF0dHIoJ3J4JywgMClcXG4gICAgICAvLyAgIC5hdHRyKCdyeScsIDApO1xcblxcbiAgICAgIHJhbmdlR3JvdXAuYXBwZW5kKCd0ZXh0JykuYXR0cigneCcsICcyJykuYXR0cigneScsIDgpLmF0dHIoJ2ZpbGwnLCAnIzAwQTNFNScpLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMHB4JykuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKS50ZXh0KHBlcmNlbnRTd2luZyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XFxuICB9O1xcblxcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL2QzLXNpbXBsZS1iYXItY2hhcnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kMy1zcGFya2xpbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2QzLXNwYXJrbGluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGUtc3ZnLWluLW1lbW9yeS1ub2RlLmpzICovIFxcXCIuL3NyYy9jcmVhdGUtc3ZnLWluLW1lbW9yeS1ub2RlLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXJyYXktcGVyY2VudC1yYW5nZS5qcyAqLyBcXFwiLi9zcmMvYXJyYXktcGVyY2VudC1yYW5nZS5qc1xcXCIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzLCBfY3JlYXRlU3ZnSW5NZW1vcnlOb2RlLCBfYXJyYXlQZXJjZW50UmFuZ2UpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XFxuICBfY3JlYXRlU3ZnSW5NZW1vcnlOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3ZnSW5NZW1vcnlOb2RlKTtcXG4gIF9hcnJheVBlcmNlbnRSYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5UGVyY2VudFJhbmdlKTtcXG5cXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBEMyBTcGFya2xpbmVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhbmdlIC0gc2hvdyB0aGUgcGVyY2VudCBmbHVjdHVhdGlvbiBvZiB0aGUgZGF0YVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aF1cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0XVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdHlsZXNdXFxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxcbiAgICpcXG4gICAqL1xcbiAgdmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoX3JlZikge1xcbiAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcXG4gICAgICAgIHJhbmdlID0gX3JlZi5yYW5nZSxcXG4gICAgICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxcbiAgICAgICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB2b2lkIDAgPyAxMDAgOiBfcmVmJHdpZHRoLFxcbiAgICAgICAgX3JlZiRoZWlnaHQgPSBfcmVmLmhlaWdodCxcXG4gICAgICAgIGhlaWdodCA9IF9yZWYkaGVpZ2h0ID09PSB2b2lkIDAgPyAzMCA6IF9yZWYkaGVpZ2h0LFxcbiAgICAgICAgX3JlZiRzdHlsZXMgPSBfcmVmLnN0eWxlcyxcXG4gICAgICAgIHN0eWxlcyA9IF9yZWYkc3R5bGVzID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkc3R5bGVzO1xcbiAgICB2YXIgcmFuZ2VYT2Zmc2V0ID0gcmFuZ2UgPyAyMCA6IDA7XFxuICAgIHZhciBzdmdFbGVtZW50ID0gKDAsIF9jcmVhdGVTdmdJbk1lbW9yeU5vZGUuZGVmYXVsdCkoJ3N2ZycpO1xcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XFxuICAgIGlmICghbGVuKSByZXR1cm4gc3ZnRWxlbWVudDsgLy9pbml0aWFsaXplIHNjYWxlc1xcblxcbiAgICB2YXIgeEV4dGVudCA9IGQzLmV4dGVudChkYXRhLCBmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBkLng7XFxuICAgIH0pO1xcbiAgICB2YXIgeUV4dGVudCA9IGQzLmV4dGVudChkYXRhLCBmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBkLnk7XFxuICAgIH0pO1xcbiAgICB2YXIgeCA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKHhFeHRlbnQpLnJhbmdlKFtyYW5nZVhPZmZzZXQsIHdpZHRoIC0gMl0pO1xcbiAgICB2YXIgeSA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKHlFeHRlbnQpLnJhbmdlKFtoZWlnaHQgLSA0LCAwXSk7XFxuICAgIHZhciBsaW5lID0gZDMubGluZSgpLngoZnVuY3Rpb24gKGQpIHtcXG4gICAgICByZXR1cm4geChkLngpO1xcbiAgICB9KS55KGZ1bmN0aW9uIChkKSB7XFxuICAgICAgcmV0dXJuIHkoZC55KTtcXG4gICAgfSkuY3VydmUoZDMuY3VydmVCYXNpcyk7XFxuICAgIHZhciBzdmcgPSBzdmdFbGVtZW50LmF0dHIoJ3dpZHRoJywgd2lkdGgpLmF0dHIoJ2hlaWdodCcsIGhlaWdodCkuYXR0cignc3R5bGUnLCBzdHlsZXMpLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMiknKTtcXG4gICAgc3ZnLmFwcGVuZCgncGF0aCcpLmRhdHVtKGRhdGEpLmF0dHIoJ2NsYXNzJywgJ2NyeXB0b2h1Yi1zcGFya2xpbmUnKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzdHJva2UnLCAnIzAwMCcpLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcwLjVweCcpLmF0dHIoJ2QnLCBsaW5lKTtcXG4gICAgc3ZnLmFwcGVuZCgnY2lyY2xlJykuYXR0cignY2xhc3MnLCAnY3J5cHRvaHViLXNwYXJrbGluZS1jaXJjbGUnKS5hdHRyKCdjeCcsIHgoZGF0YVtsZW4gLSAxXS54KSkuYXR0cignY3knLCB5KGRhdGFbbGVuIC0gMV0ueSkpLmF0dHIoJ2ZpbGwnLCAnIzAwQTNFNScpLmF0dHIoJ3N0cm9rZScsICdub25lJykuYXR0cigncicsIDEuNSk7XFxuXFxuICAgIGlmIChyYW5nZSkge1xcbiAgICAgIHZhciBwcmljZUFycmF5ID0gZGF0YS5tYXAoZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgIHJldHVybiB2Lnk7XFxuICAgICAgfSk7XFxuICAgICAgdmFyIHBlcmNlbnRTd2luZyA9ICgwLCBfYXJyYXlQZXJjZW50UmFuZ2UuZGVmYXVsdCkocHJpY2VBcnJheSk7XFxuICAgICAgdmFyIHJhbmdlR3JvdXAgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnY3J5cHRvaHViLXNwYXJrbGluZS1yYW5nZScpO1xcbiAgICAgIHJhbmdlR3JvdXAuYXBwZW5kKCd0aXRsZScpLnRleHQoJ1BlcmNlbnQgZmx1Y3R1YXRpb24gb3ZlciA3IGRheXMnKTsgLy8gcmFuZ2VHcm91cC5hcHBlbmQoJ3JlY3QnKVxcbiAgICAgIC8vICAgLmF0dHIoJ3dpZHRoJywgJzIwJylcXG4gICAgICAvLyAgIC5hdHRyKCdoZWlnaHQnLCAnMTInKVxcbiAgICAgIC8vICAgLmF0dHIoJ2ZpbGwnLCAnI2ZmZicpXFxuICAgICAgLy8gICAuYXR0cignZmlsbC1vcGFjaXR5JywgJzAuOCcpXFxuICAgICAgLy8gICAuYXR0cigneCcsIDApXFxuICAgICAgLy8gICAuYXR0cigneScsIDApXFxuICAgICAgLy8gICAuYXR0cigncngnLCAwKVxcbiAgICAgIC8vICAgLmF0dHIoJ3J5JywgMCk7XFxuXFxuICAgICAgcmFuZ2VHcm91cC5hcHBlbmQoJ3RleHQnKS5hdHRyKCd4JywgJzInKS5hdHRyKCd5JywgJzgnKS5hdHRyKCdmaWxsJywgJyM1NTUnKS5hdHRyKCdmb250LXNpemUnLCAnMTBweCcpLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JykudGV4dChwZXJjZW50U3dpbmcpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBzdmdFbGVtZW50O1xcbiAgfTtcXG5cXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9kMy1zcGFya2xpbmUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kaWZmLW51bWVyaWMtc3RyaW5ncy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kaWZmLW51bWVyaWMtc3RyaW5ncy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gZGlmZk51bWVyaWNTdHJpbmdzO1xcblxcbiAgLyoqXFxuICAgKlxcbiAgICogRGlmZiBOdW1lcmljIFN0cmluZ3NcXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGlkZW50aWZ5aW5nIHRoZSBjaGFuZ2VzIGJldHdlZW4gMiBudW1iZXJzXFxuICAgKiBGb3IgZXhhbXBsZSBpbiBzdG9jayBkYXRhIGlmIHlvdSB3YW50ZWQgdG8ga25vdyBieSBob3cgbXVjaCBhIHZhbHVlXFxuICAgKiBoYXMgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZFxcbiAgICpcXG4gICAqIHYxICAgICB2MiAgICAgcmV0dXJuXFxuICAgKiAxMjM0ICAgMTI0NCAgIHtzdGFydDogMTIsIGVuZDogNDR9XFxuICAgKiAxMDAxMCAgMTEwMDAgIHtzdGFydDogMSwgIGVuZDogMTAwMH1cXG4gICAqIDIwMDAwICAxMjM0NSAge3N0YXJ0OiAsICAgZW5kOiAxMjM0NX1cXG4gICAqXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdjFcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2MlxcbiAgICogQHJldHVybiB7T2JqZWN0fVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gZGlmZk51bWVyaWNTdHJpbmdzKHYxLCB2Mikge1xcbiAgICB2YXIgczE7XFxuICAgIHZhciBzMjtcXG4gICAgdjEgPSBTdHJpbmcodjEpO1xcbiAgICB2MiA9IFN0cmluZyh2Mik7XFxuXFxuICAgIGlmICh2Mi5sZW5ndGggPiB2MS5sZW5ndGgpIHtcXG4gICAgICBzMSA9ICcnO1xcbiAgICAgIHMyID0gdjI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGkgPSB2MS5sZW5ndGggLSAxO1xcbiAgICAgIHZhciBpZHg7XFxuXFxuICAgICAgZm9yICg7IGkgPiAtMTsgaS0tKSB7XFxuICAgICAgICBpZiAodjEuY2hhckF0KGkpICE9PSB2Mi5jaGFyQXQoaSkpIHtcXG4gICAgICAgICAgaWR4ID0gaTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgczEgPSB2Mi5zdWJzdHJpbmcoMCwgaWR4KTtcXG4gICAgICBzMiA9IHYyLnN1YnN0cmluZyhpZHgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzMSA9PT0gczIpIHMxID0gJyc7XFxuICAgIHJldHVybiB7XFxuICAgICAgc3RhcnQ6IHMxLFxcbiAgICAgIGVuZDogczJcXG4gICAgfTtcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9kaWZmLW51bWVyaWMtc3RyaW5ncy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Zvcm1hdC1udW1iZXItYXMtY3VycmVuY3kuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mb3JtYXQtbnVtYmVyLWFzLWN1cnJlbmN5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdE51bWJlckFzQ3VycmVuY3k7XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBGb3JtYXQgTnVtYmVyIGFzIEJpdGNvaW5cXG4gICAqXFxuICAgKiBudW0gICAgICBwcmVjaXNpb24gICAgIHJldHVyblxcbiAgICogMTIzNDUgICAgMiAgICAgICAgICAgICDJgzEyLDM0NS4wMFxcbiAgICogMC4wMDEgICAgMiAgICAgICAgICAgICDJgzAuMDBcXG4gICAqXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZSAtIGN1cnJlbmN5IGNvZGVcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlY2lzaW9uXVxcbiAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyQXNDdXJyZW5jeShudW0sIGNvZGUsIHByZWNpc2lvbikge1xcbiAgICB2YXIgc3BlY2lhbCA9IHtcXG4gICAgICAnQlRDJzogJ+C4vycsXFxuICAgICAgJ1NBVCc6ICdzYXQnXFxuICAgIH07XFxuXFxuICAgIGlmIChzcGVjaWFsW2NvZGVdKSB7XFxuICAgICAgaWYgKCFwcmVjaXNpb24pIHtcXG4gICAgICAgIGlmIChjb2RlID09PSAnQlRDJykgcHJlY2lzaW9uID0gODtcXG4gICAgICAgIGlmIChjb2RlID09PSAnU0FUJykgcHJlY2lzaW9uID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG91dHB1dCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XFxuICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcXG4gICAgICAgIGN1cnJlbmN5OiAnVVNEJyxcXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogcHJlY2lzaW9uLFxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBwcmVjaXNpb25cXG4gICAgICB9KS5mb3JtYXQobnVtKS5yZXBsYWNlKCckJywgJycpO1xcbiAgICAgIGlmIChjb2RlID09PSAnU0FUJykgb3V0cHV0ICs9IFxcXCIgXFxcIi5jb25jYXQoc3BlY2lhbFtjb2RlXSk7ZWxzZSBvdXRwdXQgPSBzcGVjaWFsW2NvZGVdICsgb3V0cHV0O1xcbiAgICAgIHJldHVybiBvdXRwdXQ7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKCFwcmVjaXNpb24pIHtcXG4gICAgICAgIHByZWNpc2lvbiA9IDI7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLVVTJywge1xcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXFxuICAgICAgICBjdXJyZW5jeTogY29kZSxcXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogcHJlY2lzaW9uLFxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBwcmVjaXNpb25cXG4gICAgICB9KS5mb3JtYXQobnVtKTtcXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL2Zvcm1hdC1udW1iZXItYXMtY3VycmVuY3kuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9mb3JtYXQtbnVtYmVyLWFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZm9ybWF0LW51bWJlci1hcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXROdW1iZXJBc0N1cnJlbmN5O1xcblxcbiAgLyoqXFxuICAgKlxcbiAgICogRm9ybWF0IE51bWJlciBhcyBCaXRjb2luXFxuICAgKlxcbiAgICogbnVtICAgICAgcHJlY2lzaW9uICAgICByZXR1cm5cXG4gICAqIDEyMzQ1ICAgIDIgICAgICAgICAgICAgyYMxMiwzNDUuMDBcXG4gICAqIDAuMDAxICAgIDIgICAgICAgICAgICAgyYMwLjAwXFxuICAgKlxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgLSBjdXJyZW5jeSBjb2RlXFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XFxuICAgKlxcbiAgICovXFxuICBmdW5jdGlvbiBmb3JtYXROdW1iZXJBc0N1cnJlbmN5KG51bSwgcHJlY2lzaW9uLCBjb2RlKSB7XFxuICAgIHZhciBzcGVjaWFsID0ge1xcbiAgICAgICdCVEMnOiAnyYMnXFxuICAgIH07XFxuXFxuICAgIGlmIChzcGVjaWFsW2NvZGVdKSB7XFxuICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XFxuICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcXG4gICAgICAgIGN1cnJlbmN5OiAnVVNEJyxcXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogcHJlY2lzaW9uXFxuICAgICAgfSkuZm9ybWF0KG51bSkucmVwbGFjZSgnJCcsICfJgycpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoJ2VuLVVTJywge1xcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXFxuICAgICAgICBjdXJyZW5jeTogY29kZSxcXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogcHJlY2lzaW9uXFxuICAgICAgfSkuZm9ybWF0KG51bSk7XFxuICAgIH1cXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9mb3JtYXQtbnVtYmVyLWFzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZ2V0LXJhbmRvbS1pbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZ2V0LXJhbmRvbS1pbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IGdldFJhbmRvbUludDtcXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIEdFVCBSQU5ET00gSU5UXFxuICAgKlxcbiAgICogR2V0IGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzIHByb3ZpZGVkXFxuICAgKiBJZiBubyB2YWx1ZXMgYXJlIHByb3ZpZGVkIGl0IHdpbGwgcmV0dXJuIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCAxLDAwMCwwMDBcXG4gICAqXFxuICAgKiBOT1RFOiBUaGUgbWluIGFuZCBtYXggYXJlIGluY2x1c2l2ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhdXFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XFxuICAgKlxcbiAgICovXFxuICBmdW5jdGlvbiBnZXRSYW5kb21JbnQoKSB7XFxuICAgIHZhciBtaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XFxuICAgIHZhciBtYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDAwMDA7XFxuICAgIG1pbiA9IE1hdGguY2VpbChtaW4pO1xcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heCk7XFxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL2dldC1yYW5kb20taW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaHRtbC1wb2xsLWVsZW1lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaHRtbC1wb2xsLWVsZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IGh0bWxQb2xsRWxlbWVudDtcXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIEhUTUwgUE9MTCBFTEVNRU5UXFxuICAgKlxcbiAgICogUmVwZWF0aWRseSBjaGVjayBpZiBhbiBlbGVtZW50IGlzIGF2YWlsYWJsZSBpbiB0aGUgRE9NLlxcbiAgICogQ2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBpdCBiZWNvbWVzIGF2YWlsYWJsZVxcbiAgICogYW5kIGNsZWFyIHRoZSBpbnRlcnZhbFxcbiAgICpcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gaHRtbFBvbGxFbGVtZW50KHNlbGVjdG9yLCBpbnRlcnZhbCwgY2FsbGJhY2spIHtcXG4gICAgdmFyIGludGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVswXSkge1xcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcik7XFxuICAgICAgICBjYWxsYmFjaygpO1xcbiAgICAgIH1cXG4gICAgfSwgaW50ZXJ2YWwpO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL2h0bWwtcG9sbC1lbGVtZW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaHRtbC10b2dnbGUtY2xhc3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaHRtbC10b2dnbGUtY2xhc3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IGh0bWxUb2dnbGVDbGFzcztcXG5cXG4gIC8qKlxcbiAgKlxcbiAgKiBIVE1MIFRPR0dMRSBDTEFTU1xcbiAgKlxcbiAgKiBUb2dnbGUgYSBjbGFzcyBvbiBhIERPTSBub2RlXFxuICAqXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcXG4gICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzXFxuICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cXG4gICpcXG4gICovXFxuICBmdW5jdGlvbiBodG1sVG9nZ2xlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpID8gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNzc0NsYXNzKSA6IGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzcyk7XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvaHRtbC10b2dnbGUtY2xhc3MuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pcy1mbG9hdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pcy1mbG9hdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gaXNGbG9hdDtcXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIElzIEZsb2F0XFxuICAgKlxcbiAgICogQHBhcmFtIHsqfSB4XFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gaXNGbG9hdCh4KSB7XFxuICAgIHJldHVybiBOdW1iZXIoeCkgPT09IHggJiYgeCAlIDEgIT09IDA7XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvaXMtZmxvYXQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pcy1pbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaXMtaW50ZWdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBpc0ludGVnZXI7XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBJcyBJbnRlZ2VyXFxuICAgKlxcbiAgICogQHBhcmFtIHsqfSB4XFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gaXNJbnRlZ2VyKHgpIHtcXG4gICAgcmV0dXJuIE51bWJlcih4KSA9PT0geCAmJiB4ICUgMSA9PT0gMDtcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9pcy1pbnRlZ2VyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaXMtbnVtYmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pcy1udW1iZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtaW50ZWdlci5qcyAqLyBcXFwiLi9zcmMvaXMtaW50ZWdlci5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZsb2F0LmpzICovIFxcXCIuL3NyYy9pcy1mbG9hdC5qc1xcXCIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzLCBfaXNJbnRlZ2VyLCBfaXNGbG9hdCkge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IGlzTnVtYmVyO1xcbiAgX2lzSW50ZWdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSW50ZWdlcik7XFxuICBfaXNGbG9hdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRmxvYXQpO1xcblxcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIElzIE51bWJlclxcbiAgICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGFuIEludGVnZXIgb3IgYSBGbG9hdFxcbiAgICpcXG4gICAqIEBwYXJhbSB7Kn0geFxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcXG4gICAgcmV0dXJuICgwLCBfaXNJbnRlZ2VyLmRlZmF1bHQpKHgpIHx8ICgwLCBfaXNGbG9hdC5kZWZhdWx0KSh4KTtcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9pcy1udW1iZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9udW1iZXItZ3JvdXAtZGlnaXRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbnVtYmVyLWdyb3VwLWRpZ2l0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtaW50ZWdlci5qcyAqLyBcXFwiLi9zcmMvaXMtaW50ZWdlci5qc1xcXCIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzLCBfaXNJbnRlZ2VyKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gbnVtYmVyR3JvdXBEaWdpdHM7XFxuICBfaXNJbnRlZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJbnRlZ2VyKTtcXG5cXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBOVU1CRVIgR1JPVVAgRElHSVRTXFxuICAgKlxcbiAgICogR3JvdXAgbnVtYmVycyB3aXRoIGEgZGVsaW1pdGVyXFxuICAgKlxcbiAgICogZnVuYygxMjM0KSAgICAgIC8vIDEsMjM0XFxuICAgKiBmdW5jKDEyMzQ1NikgICAgLy8gMTIzLDQ1NlxcbiAgICogZnVuYygxMjM0LCAnICcpIC8vIDEgMjM0XFxuICAgKlxcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZWNpbWFsX3NlcGFyYXRvciBmb3IgZnVydGhlciBlbmhhbmNlbWVudHNcXG4gICAqXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cXG4gICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gbnVtYmVyR3JvdXBEaWdpdHMobnVtYmVyKSB7XFxuICAgIHZhciBkZWxpbWl0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcsJztcXG4gICAgaWYgKCEoMCwgX2lzSW50ZWdlci5kZWZhdWx0KShudW1iZXIpKSByZXR1cm4gdm9pZCBmYWxzZTtcXG4gICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKS50b1N0cmluZygpLnJlcGxhY2UoLyhcXFxcZCkoPz0oXFxcXGR7M30pKyg/IVxcXFxkKSkvZywgXFxcIiQxXFxcIi5jb25jYXQoZGVsaW1pdGVyKSk7XFxuICB9XFxuXFxuICA7XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvbnVtYmVyLWdyb3VwLWRpZ2l0cy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL251bWJlci1ub3JtYWxpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9udW1iZXItbm9ybWFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIE51bWJlciBOb3JtYWxpemVcXG4gICAqXFxuICAgKiBOb3JtYWxpemUgYSBudW1iZXIgZnJvbSBvbmUgcmFuZ2UgdG8gYW5vdGhlclxcbiAgICpcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSB0aGUgbnVtYmVyIHRvIGJlIG5vcm1hbGl6ZWRcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gLSB0aGUgbWluIHJhbmdlIG9mIHRoZSBvcmlnaW5hbCBudW1iZXJzXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IC0gdGhlIG1heCByYW5nZSBvZiB0aGUgb3JpZ2luYWwgbnVtYmVyXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbk1pbiAtIHRoZSBuZXcgbWluIHJhbmdlIHRvIGFwcGx5XFxuICAgKiBAcGFyYW0ge051bWJlcn0gbk1heCAtIHRoZSBuZXcgbWF4IHJhbmdlIHRvIGFwcGx5XFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJldHVybiB0aGUgbm9ybWFsaXplZCBudW1iZXJcXG4gICAqXFxuICAgKi9cXG4gIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KG51bSwgbWluLCBtYXgsIG5NaW4sIG5NYXgpIHtcXG4gICAgdmFyIHBlcmNlbnQgPSAobnVtIC0gbk1pbikgLyAobk1heCAtIG5NaW4pO1xcbiAgICB2YXIgb3V0cHV0ID0gcGVyY2VudCAqIChtYXggLSBtaW4pICsgbWluO1xcbiAgICByZXR1cm4gb3V0cHV0O1xcbiAgfTtcXG5cXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9udW1iZXItbm9ybWFsaXplLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbnVtYmVyLXNjYWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9udW1iZXItc2NhbGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gICd1c2Ugc3RyaWN0JztcXG4gIC8qKlxcbiAgICpcXG4gICAqIE51bWJlciBTY2FsZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNaW5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNYXhcXG4gICAqIEByZXR1cm4ge051YmVyfVxcbiAgICpcXG4gICAqL1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IG51bWJlclNjYWxlO1xcblxcbiAgZnVuY3Rpb24gbnVtYmVyU2NhbGUobnVtLCBtaW4sIG1heCkge1xcbiAgICB2YXIgbmV3TWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xcbiAgICB2YXIgbmV3TWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxMDA7XFxuICAgIGlmIChudW0gPCBtaW4pIG51bSA9IG1pbjtcXG4gICAgaWYgKG51bSA+IG1heCkgbnVtID0gbWF4OyAvLyBJZiB0aGUgcmFuZ2VzIHN1Y2tcXG5cXG4gICAgaWYgKG1pbiA9PT0gbWF4KSBtaW4gKj0gMC45OSwgbWF4ICo9IDEuMDE7XFxuICAgIGlmIChuZXdNaW4gPT09IG5ld01heCkgdGhyb3cgbmV3IEVycm9yKFxcXCJudW1iZXJTY2FsZSgpOiBJbmNvcnJlY3QgcmFuZ2UgXFxcIi5jb25jYXQobWluLCBcXFwiLVxcXCIpLmNvbmNhdChtYXgpKTtcXG4gICAgdmFyIHBlcmNlbnQgPSAobnVtIC0gbWluKSAvIChtYXggLSBtaW4pO1xcbiAgICByZXR1cm4gcGVyY2VudCAqIChuZXdNYXggLSBuZXdNaW4pICsgbmV3TWluO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL251bWJlci1zY2FsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL29iamVjdC1nZXQtbmVzdGVkLXByb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL29iamVjdC1nZXQtbmVzdGVkLXByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBvYmplY3RHZXROZXN0ZWRQcm9wZXJ0eTtcXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIEdldCBuZXN0ZWQgcHJvcGVydHlcXG4gICAqXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXFxuICAgKiBAcmV0dXJuIHtPYmplY3R8U3RyaW5nfSByZXR1cm4gdGhlIHByb3BlcnR5LCBjYW4gYmUgYW55IHZhbHVlXFxuICAgKlxcbiAgICovXFxuICBmdW5jdGlvbiBvYmplY3RHZXROZXN0ZWRQcm9wZXJ0eShvYmosIHN0cikge1xcbiAgICB2YXIgcGF0aEFyciA9IHN0ci5zcGxpdCgnLicpO1xcbiAgICByZXR1cm4gcGF0aEFyci5yZWR1Y2UoZnVuY3Rpb24gKG8sIGspIHtcXG4gICAgICByZXR1cm4gbyAmJiBvW2tdICE9PSB2b2lkIDAgPyBvW2tdIDogdm9pZCAwO1xcbiAgICB9LCBvYmopO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL29iamVjdC1nZXQtbmVzdGVkLXByb3BlcnR5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvb2JqZWN0LWlzLWVtcHR5LW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL29iamVjdC1pcy1lbXB0eS1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29iamVjdC1pcy1vYmplY3QgKi8gXFxcIi4vc3JjL29iamVjdC1pcy1vYmplY3QuanNcXFwiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cywgX29iamVjdElzT2JqZWN0KSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0SXNFbXB0eU9iamVjdDtcXG4gIF9vYmplY3RJc09iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdElzT2JqZWN0KTtcXG5cXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBJUyBFTVBUWSBPQkpFQ1RcXG4gICAqXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gb2JqZWN0IG9yIGFueSBvdGhlciB0eXBlXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gb2JqZWN0SXNFbXB0eU9iamVjdChkYXRhKSB7XFxuICAgIHJldHVybiAoMCwgX29iamVjdElzT2JqZWN0LmRlZmF1bHQpKGRhdGEpICYmICFPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGg7XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvb2JqZWN0LWlzLWVtcHR5LW9iamVjdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL29iamVjdC1pcy1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9vYmplY3QtaXMtb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IG9iamVjdElzT2JqZWN0O1xcblxcbiAgLyoqXFxuICAgKlxcbiAgICogb2JqZWN0SXNPYmplY3RcXG4gICAqXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gb2JqZWN0IG9yIGFueSBvdGhlciB0eXBlXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gb2JqZWN0SXNPYmplY3Qob2JqZWN0KSB7XFxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvb2JqZWN0LWlzLW9iamVjdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL29iamVjdC10by1hcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvb2JqZWN0LXRvLWFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxcblxcbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVxcXCIpOyB9XFxuXFxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1xcXCJyZXR1cm5cXFwiXSAhPSBudWxsKSBfaVtcXFwicmV0dXJuXFxcIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XFxuXFxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqXFxuICAgKi9cXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb2JqZWN0VG9BcnJheShkYXRhKSB7XFxuICAgIHZhciBhcnJheURhdGEgPSBbXTtcXG5cXG4gICAgdmFyIF9hcnIgPSBPYmplY3QuZW50cmllcyhkYXRhKTtcXG5cXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgdmFyIF9hcnIkX2kgPSBfc2xpY2VkVG9BcnJheShfYXJyW19pXSwgMiksXFxuICAgICAgICAgIGlkID0gX2FyciRfaVswXSxcXG4gICAgICAgICAgb2JqID0gX2FyciRfaVsxXTtcXG5cXG4gICAgICBvYmouaWQgPSBvYmouSWQ7XFxuICAgICAgYXJyYXlEYXRhLnB1c2gob2JqKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gYXJyYXlEYXRhO1xcbiAgfTtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9vYmplY3QtdG8tYXJyYXkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wYXJ0aWFsLWFwcGxpY2F0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGFydGlhbC1hcHBsaWNhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XFxuXFxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cXG5cXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcXFwiKTsgfVxcblxcbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXFxcIltvYmplY3QgQXJndW1lbnRzXVxcXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XFxuXFxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBwYXJ0aWFsQXBwbGljYXRpb25cXG4gICAqXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICogQHBhcmFtIHtBcmd1bWVudHN9IGNhY2hlXFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cXG4gICAqXFxuICAgKi9cXG4gIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KGZuKSB7XFxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjYWNoZSA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgICAgY2FjaGVbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XFxuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhbGwgPSBjYWNoZS5jb25jYXQoYXJncyk7XFxuICAgICAgcmV0dXJuIGFsbC5sZW5ndGggPj0gZm4ubGVuZ3RoID8gZm4uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoYWxsKSkgOiBwQXBwbHkuYXBwbHkodm9pZCAwLCBbZm5dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxsKSkpO1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy9wYXJ0aWFsLWFwcGxpY2F0aW9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3RyaW5nLWNhbWVsY2FzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0cmluZy1jYW1lbGNhc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0cmluZy1jYXBpdGFsaXplLWZpcnN0LWxldHRlciAqLyBcXFwiLi9zcmMvc3RyaW5nLWNhcGl0YWxpemUtZmlyc3QtbGV0dGVyLmpzXFxcIildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMsIF9zdHJpbmdDYXBpdGFsaXplRmlyc3RMZXR0ZXIpIHtcXG4gICd1c2Ugc3RyaWN0JzsgLy8gYm8tdXRpbHNcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBjYW1lbGNhc2U7XFxuICBfc3RyaW5nQ2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nQ2FwaXRhbGl6ZUZpcnN0TGV0dGVyKTtcXG5cXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsaW1pdGVyXFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XFxuICAgKlxcbiAgICovXFxuICBmdW5jdGlvbiBjYW1lbGNhc2Uoc3RyLCBkZWxpbWl0ZXIpIHtcXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLScpLm1hcChmdW5jdGlvbiAoeCwgaSkge1xcbiAgICAgIHJldHVybiAhaSA/IHggOiAoMCwgX3N0cmluZ0NhcGl0YWxpemVGaXJzdExldHRlci5kZWZhdWx0KSh4KTtcXG4gICAgfSkuam9pbignJyk7XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vYm8vLi9zcmMvc3RyaW5nLWNhbWVsY2FzZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0cmluZy1jYXBpdGFsaXplLWZpcnN0LWxldHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3RyaW5nLWNhcGl0YWxpemUtZmlyc3QtbGV0dGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xcblxcdFxcdFxcdFxcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuICB9IGVsc2UgeyB2YXIgbW9kOyB9XFxufSkodGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyO1xcblxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxcbiAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN0cikge1xcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL3N0cmluZy1jYXBpdGFsaXplLWZpcnN0LWxldHRlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RpbWUtYWdvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RpbWUtYWdvLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB0aW1lQWdvO1xcblxcbiAgLyoqXFxuICAgKlxcbiAgICogVGltZWFnb1xcbiAgICpcXG4gICAqIE5PVEU6IFJlcXVpcmVzIG1vbWVudFxcbiAgICpcXG4gICAqIEBwYXJhbSB7U3RyaW5nfERhdGV8TnVtYmVyfSB0aW1lc3RhbXBcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZS5nLiAnYSBmZXcgc2Vjb25kcydcXG4gICAqXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHRpbWVBZ28odGltZXN0YW1wKSB7XFxuICAgIHZhciB0aW1lYWdvO1xcblxcbiAgICBpZiAodGltZXN0YW1wICE9PSB2b2lkIDApIHtcXG4gICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50KHRpbWVzdGFtcCk7XFxuICAgICAgdmFyIGVuZERhdGUgPSBtb21lbnQobmV3IERhdGUoKSk7XFxuICAgICAgdmFyIG1zID0gTWF0aC5hYnMoc3RhcnREYXRlLmRpZmYoZW5kRGF0ZSkpO1xcbiAgICAgIHZhciBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihtcykuaHVtYW5pemUoKTtcXG4gICAgICB0aW1lYWdvID0gXFxcIlxcXCIuY29uY2F0KGR1cmF0aW9uKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGltZWFnbztcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy90aW1lLWFnby5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RpbWVzZXJpZXMtcHJ1bmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90aW1lc2VyaWVzLXBydW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cykge1xcbiAgJ3VzZSBzdHJpY3QnO1xcbiAgLyoqXFxuICAgKlxcbiAgICogVGltZXNlcmllcyBwcnVuZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRzIC0gQXJyYXkgb2YgdGltZXNlcmllcyBvYmplY3RzXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4QWdlIC0gUmVtb3ZlIGFsbCBpdGVtcyBvbGRlciB0aGFuIG5vdyAtIG1heEFnZSBpbiBtc1xcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0aW1lc3RhbXBGaWVsZF0gLSBUaGUgbmFtZSBvZiB0aGUgdGltZXN0YW1wIGZpZWxkXFxuICAgKlxcbiAgICovXFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gdGltZXNlcmllc1BydW5lO1xcblxcbiAgZnVuY3Rpb24gdGltZXNlcmllc1BydW5lKHRzLCBtYXhBZ2UpIHtcXG4gICAgdmFyIHRpbWVzdGFtcEZpZWxkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndGltZXN0YW1wJztcXG4gICAgdmFyIHRpbWVOb3cgPSArbmV3IERhdGUoKTtcXG4gICAgcmV0dXJuIHRzLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xcbiAgICAgIHJldHVybiB0aW1lTm93IC0gdlt0aW1lc3RhbXBGaWVsZF0gPCBtYXhBZ2U7XFxuICAgIH0pO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL3RpbWVzZXJpZXMtcHJ1bmUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90aW1lc2VyaWVzLXJlc2NhbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RpbWVzZXJpZXMtcmVzY2FsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aW1lc2VyaWVzLXRoaW4gKi8gXFxcIi4vc3JjL3RpbWVzZXJpZXMtdGhpbi5qc1xcXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVzZXJpZXMtcHJ1bmUgKi8gXFxcIi4vc3JjL3RpbWVzZXJpZXMtcHJ1bmUuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aW1lc2VyaWVzLXNjYWxlICovIFxcXCIuL3NyYy90aW1lc2VyaWVzLXNjYWxlLmpzXFxcIildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMsIF90aW1lc2VyaWVzVGhpbiwgX3RpbWVzZXJpZXNQcnVuZSwgX3RpbWVzZXJpZXNTY2FsZSkge1xcbiAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG4gIH0pO1xcbiAgX2V4cG9ydHMuZGVmYXVsdCA9IHRpbWVzZXJpZXNSZXNjYWxlO1xcbiAgX3RpbWVzZXJpZXNUaGluID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZXNlcmllc1RoaW4pO1xcbiAgX3RpbWVzZXJpZXNQcnVuZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVzZXJpZXNQcnVuZSk7XFxuICBfdGltZXNlcmllc1NjYWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZXNlcmllc1NjYWxlKTtcXG5cXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuICAvKipcXG4gICAqXFxuICAgKiBUaW1lc2VyaWVzIFJlc2NhbGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0FycmF5fSB0cyAtIEFycmF5IG9mIHRpbWVzZXJpZXMgb2JqZWN0c1xcbiAgICogQHJldHVybiB7QXJyYXl9IC0gQXJyYXkgb2YgdXBkYXRlZCB0aW1lc2VyaWVzIG9iamVjdFxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gdGltZXNlcmllc1Jlc2NhbGUoaXRlbSkge1xcbiAgICB2YXIgbGltaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDUwO1xcbiAgICB2YXIgbWF4QWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDAwICogNjAgKiA2MCAqIDI0ICogNztcXG4gICAgdmFyIHByaWNlID0gaXRlbVsnY2MtdG90YWwtdm9sLWZ1bGwtUFJJQ0UnXTtcXG4gICAgdmFyIHZvbHVtZSA9IGl0ZW1bJ2NjLXRvdGFsLXZvbC1mdWxsLVRPVEFMVk9MVU1FMjRIVE8nXTtcXG4gICAgdmFyIHRzID0gaXRlbVsnY3J5cHRvaHViLXByaWNlLWhpc3RvcnknXTtcXG4gICAgdmFyIG1pblAgPSBpdGVtWydjcnlwdG9odWItcHJpY2UtaGlzdG9yeS1taW4nXSB8fCBwcmljZSAtIDE7XFxuICAgIHZhciBtYXhQID0gaXRlbVsnY3J5cHRvaHViLXByaWNlLWhpc3RvcnktbWF4J10gfHwgcHJpY2U7XFxuICAgIHZhciBtaW5WID0gaXRlbVsnY3J5cHRvaHViLXZvbHVtZS1oaXN0b3J5LW1pbiddIHx8IHZvbHVtZSAtIDE7XFxuICAgIHZhciBtYXhWID0gaXRlbVsnY3J5cHRvaHViLXZvbHVtZS1oaXN0b3J5LW1heCddIHx8IHZvbHVtZTtcXG4gICAgdmFyIHRpbWVzdGFtcCA9IGl0ZW1bJ2NjLXRvdGFsLXZvbC1mdWxsLVBSSUNFLXRpbWVzdGFtcCddO1xcbiAgICAoMCwgX3RpbWVzZXJpZXNQcnVuZS5kZWZhdWx0KSh0cywgbWF4QWdlKTtcXG4gICAgKDAsIF90aW1lc2VyaWVzVGhpbi5kZWZhdWx0KSh0cywgbGltaXQpOyAvLyBzY2FsZSB1cFxcblxcbiAgICAoMCwgX3RpbWVzZXJpZXNTY2FsZS5kZWZhdWx0KSh7XFxuICAgICAgdHM6IHRzLFxcbiAgICAgIG1pbjogbWluUCxcXG4gICAgICBtYXg6IG1heFAsXFxuICAgICAgc2NhbGVGaWVsZDogJ3ByaWNlJ1xcbiAgICB9KTtcXG4gICAgKDAsIF90aW1lc2VyaWVzU2NhbGUuZGVmYXVsdCkoe1xcbiAgICAgIHRzOiB0cyxcXG4gICAgICBtaW46IG1pblYsXFxuICAgICAgbWF4OiBtYXhWLFxcbiAgICAgIHNjYWxlRmllbGQ6ICd2b2x1bWUnXFxuICAgIH0pOyAvLyBhZGQgaXRlbVxcblxcbiAgICB2YXIgbGFzdCA9IHRzW3RzLmxlbmd0aCAtIDFdO1xcbiAgICB2YXIgbmV4dCA9IHtcXG4gICAgICBwcmljZTogcHJpY2UsXFxuICAgICAgdm9sdW1lOiB2b2x1bWUsXFxuICAgICAgdGltZXN0YW1wOiArbmV3IERhdGUodGltZXN0YW1wKVxcbiAgICB9O1xcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkobGFzdCkgIT09IEpTT04uc3RyaW5naWZ5KG5leHQpKSB0cy5wdXNoKG5leHQpOyAvLyBzY2FsZSBkb3duXFxuXFxuICAgICgwLCBfdGltZXNlcmllc1NjYWxlLmRlZmF1bHQpKHtcXG4gICAgICB0czogdHMsXFxuICAgICAgbWluOiAwLFxcbiAgICAgIG1heDogMTAwMCxcXG4gICAgICBzY2FsZUZpZWxkOiAncHJpY2UnXFxuICAgIH0pO1xcbiAgICAoMCwgX3RpbWVzZXJpZXNTY2FsZS5kZWZhdWx0KSh7XFxuICAgICAgdHM6IHRzLFxcbiAgICAgIG1pbjogMCxcXG4gICAgICBtYXg6IDEwMDAsXFxuICAgICAgc2NhbGVGaWVsZDogJ3ZvbHVtZSdcXG4gICAgfSk7IC8vIHJldHVybiB7XFxuICAgIC8vICAgdGltZXNlcmllczogdHNBcnIsXFxuICAgIC8vICAgcHJpY2VNaW46IG5ld1ByaWNlTWluLFxcbiAgICAvLyAgIHByaWNlTWF4OiBuZXdQcmljZU1heCxcXG4gICAgLy8gICB2b2x1bWVNaW46IG5ld1ZvbE1pbixcXG4gICAgLy8gICB2b2x1bWVNYXg6IG5ld1ZvbE1heCxcXG4gICAgLy8gfTtcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy90aW1lc2VyaWVzLXJlc2NhbGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90aW1lc2VyaWVzLXNjYWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGltZXNlcmllcy1zY2FsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbnVtYmVyLXNjYWxlICovIFxcXCIuL3NyYy9udW1iZXItc2NhbGUuanNcXFwiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cXG5cXHRcXHRcXHRcXHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcbiAgfSBlbHNlIHsgdmFyIG1vZDsgfVxcbn0pKHRoaXMsIGZ1bmN0aW9uIChfZXhwb3J0cywgX251bWJlclNjYWxlKSB7XFxuICAndXNlIHN0cmljdCc7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbiAgfSk7XFxuICBfZXhwb3J0cy5kZWZhdWx0ID0gdGltZXNlcmllc1NjYWxlO1xcbiAgX251bWJlclNjYWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbnVtYmVyU2NhbGUpO1xcblxcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxcblxcbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVxcXCIpOyB9XFxuXFxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcXFwiW29iamVjdCBBcmd1bWVudHNdXFxcIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cXG5cXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cXG5cXG4gIC8qKlxcbiAgICpcXG4gICAqIFRpbWVzZXJpZXMgU2NhbGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0FycmF5fSB0cyAtIEFycmF5IG9mIHRpbWVzZXJpZXMgb2JqZWN0c1xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbiAtIE1pbmltdW0gdmFsdWUgb2YgcmFuZ2UgdG8gc2NhbGUgdG9cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggLSBNYXhpbWltIHZhbHVlIG9mIHRoZSByYW5nZSB0byBzY2FsZSB0b1xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNjYWxlRmllbGQgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gc2NhbGVcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdGltZXN0YW1wRmllbGRdIC0gVGhlIG5hbWUgb2YgdGhlIHRpbWVzdGFtcCBmaWVsZFxcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjZWlsXSAtIFJvdW50IHRoZSB2YWx1ZSB1cFxcbiAgICogQHJldHVybiB7QXJyYXl9IC0gQXJyYXkgb2YgdXBkYXRlZCB0aW1lc2VyaWVzIG9iamVjdFxcbiAgICpcXG4gICAqL1xcbiAgZnVuY3Rpb24gdGltZXNlcmllc1NjYWxlKF9yZWYpIHtcXG4gICAgdmFyIHRzID0gX3JlZi50cyxcXG4gICAgICAgIG1pbiA9IF9yZWYubWluLFxcbiAgICAgICAgbWF4ID0gX3JlZi5tYXgsXFxuICAgICAgICBzY2FsZUZpZWxkID0gX3JlZi5zY2FsZUZpZWxkLFxcbiAgICAgICAgX3JlZiR0aW1lc3RhbXBGaWVsZCA9IF9yZWYudGltZXN0YW1wRmllbGQsXFxuICAgICAgICB0aW1lc3RhbXBGaWVsZCA9IF9yZWYkdGltZXN0YW1wRmllbGQgPT09IHZvaWQgMCA/ICd0aW1lc3RhbXAnIDogX3JlZiR0aW1lc3RhbXBGaWVsZCxcXG4gICAgICAgIF9yZWYkY2VpbCA9IF9yZWYuY2VpbCxcXG4gICAgICAgIGNlaWwgPSBfcmVmJGNlaWwgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGNlaWw7XFxuICAgIHZhciBhcnIgPSB0cy5tYXAoZnVuY3Rpb24gKHgpIHtcXG4gICAgICByZXR1cm4geFtzY2FsZUZpZWxkXTtcXG4gICAgfSk7XFxuICAgIHZhciBtaW5PbGQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSk7XFxuICAgIHZhciBtYXhPbGQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSk7XFxuICAgIHZhciB2YWw7XFxuICAgIHZhciBzY2FsZTtcXG5cXG4gICAgdmFyIF9hcnIgPSBPYmplY3QudmFsdWVzKHRzKTtcXG5cXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgdmFsID0gX2FycltfaV07XFxuICAgICAgc2NhbGUgPSAoMCwgX251bWJlclNjYWxlLmRlZmF1bHQpKHZhbFtzY2FsZUZpZWxkXSwgbWluT2xkLCBtYXhPbGQsIG1pbiwgbWF4KTtcXG4gICAgICB2YWxbc2NhbGVGaWVsZF0gPSBjZWlsID8gTWF0aC5jZWlsKHNjYWxlKSA6IHNjYWxlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0cztcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9iby8uL3NyYy90aW1lc2VyaWVzLXNjYWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGltZXNlcmllcy10aGluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90aW1lc2VyaWVzLXRoaW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cXG59KSh0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcXG4gICd1c2Ugc3RyaWN0JztcXG4gIC8qKlxcbiAgICpcXG4gICAqIFRpbWVzZXJpZXMgdGhpblxcbiAgICpcXG4gICAqIFJlbW92ZSB0aGUgdGltZXNlcmllcyBpdGVtcyB0aGF0IGhhdmUgdGhlXFxuICAgKiBzaG9ydGVzdCB0aW1lIHNwYW4gYmV0d2VlbiB0aGVtIGFuZCB0aGVpciBzaWJsaW5nc1xcbiAgICogS2VlcCByZW1vdmluZyB1bnRpbCB0aGUgbGltaXQgaGFzIGJlZW4gcmVhY2hlZFxcbiAgICpcXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRzXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXRcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdGltZXN0YW1wRmllbGRdXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqXFxuICAgKi9cXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxuICB9KTtcXG4gIF9leHBvcnRzLmRlZmF1bHQgPSB0aW1lc2VyaWVzVGhpbjtcXG5cXG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XFxuXFxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXFxcIik7IH1cXG5cXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXFxcInJldHVyblxcXCJdICE9IG51bGwpIF9pW1xcXCJyZXR1cm5cXFwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cXG5cXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxcblxcbiAgZnVuY3Rpb24gdGltZXNlcmllc1RoaW4odHMsIGxpbWl0KSB7XFxuICAgIHZhciB0aW1lc3RhbXBGaWVsZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3RpbWVzdGFtcCc7XFxuICAgIHZhciBudW1Ub1JlbW92ZSA9IHRzLmxlbmd0aCAtIGxpbWl0O1xcblxcbiAgICBpZiAoIW51bVRvUmVtb3ZlKSB7XFxuICAgICAgcmV0dXJuIHRzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBpZHg7XFxuICAgICAgdmFyIGRpZmY7XFxuICAgICAgdmFyIGRpZmZzID0ge307XFxuXFxuICAgICAgdmFyIF9hcnIgPSBPYmplY3Qua2V5cyh0cyk7XFxuXFxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBpZHggPSBfYXJyW19pXTtcXG5cXG4gICAgICAgIGlmIChpZHggPiAwKSB7XFxuICAgICAgICAgIGRpZmYgPSBNYXRoLmFicyh0c1tpZHggLSAxXVt0aW1lc3RhbXBGaWVsZF0gLSB0c1tpZHhdW3RpbWVzdGFtcEZpZWxkXSk7XFxuICAgICAgICAgIGRpZmZzW2RpZmZdID0gaWR4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaTtcXG4gICAgICB2YXIgaXRlbXNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKGRpZmZzKS5zb3J0KCkuc3BsaWNlKDAsIG51bVRvUmVtb3ZlKTtcXG5cXG4gICAgICB2YXIgX2FycjIgPSBPYmplY3QuZW50cmllcyhpdGVtc1RvUmVtb3ZlKTtcXG5cXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfYXJyMi5sZW5ndGg7IF9pMisrKSB7XFxuICAgICAgICB2YXIgX2FycjIkX2kgPSBfc2xpY2VkVG9BcnJheShfYXJyMltfaTJdLCAyKTtcXG5cXG4gICAgICAgIGkgPSBfYXJyMiRfaVswXTtcXG4gICAgICAgIGlkeCA9IF9hcnIyJF9pWzFdO1xcbiAgICAgICAgdHMuc3BsaWNlKGRpZmZzW2lkeF0gLSBpLCAxKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRzO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2JvLy4vc3JjL3RpbWVzZXJpZXMtdGhpbi5qcz9cIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBCaW5hcnkgT3ZlcmRvc2UgUHJvamVjdHNcbmltcG9ydCB7IGdldFJhbmRvbUludCB9ICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IGh0bWxUb2dnbGVDbGFzcyB9ICAgICAgICAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IG51bWJlckdyb3VwRGlnaXRzIH0gICAgICAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IG9iamVjdEdldE5lc3RlZFByb3BlcnR5IGFzIGducCB9IGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcblxuLy8gQ3J5cHRvaHViXG5pbXBvcnQgcG9wRGl2ICBmcm9tICcuL3BvcGRpdi5qcyc7XG5pbXBvcnQgaW5pdFB1ZyBmcm9tICcuLi9nZW5lcmF0ZWQvaW5pdC1wdWcuZ2VuZXJhdGVkLmpzJztcblxuLyoqXG4gKlxuICpcbiAqXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjZWxsT25DbGlja0V4Y2hhbmdlcyhwYXJhbXMpIHtcblxuICBmdW5jdGlvbiBleGNoYW5nZURhdGFNb2RlbCgpIHtcblxuICAgIC8vIEV4Y2hhbmdlIGRhdGFcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQ2VudHJhbGl6YXRpb25UeXBlIDogXCJDZW50cmFsaXplZFwiXG4gICAgLy8gQ291bnRyeSA6IFwiVW5pdGVkIEtpbmdkb21cIlxuICAgIC8vIEl0ZW1UeXBlIDogKDIpIFtcIkNyeXB0b2N1cnJlbmN5XCIsIFwiRmlhdFwiXVxuICAgIC8vIFVybDogXCIvZXhjaGFuZ2VzL2JpdHN0YW1wL292ZXJ2aWV3XCJcbiAgICAvLyBMb2dvVXJsIDogXCIvbWVkaWEvMzQ0Nzg0OTcvYml0c3RhbXAuanBnXCJcbiAgICAvLyBOYW1lIDogXCJCaXRzdGFtcFwiXG4gICAgLy8gaWQgOiBcIjI0MzFcIlxuICAgIC8vIG5hbWUgOiBcIkJpdHN0YW1wXCJcbiAgICAvLyBwYWlycyA6IFNldCgxOCkge1wiWFJQLEVVUlwiLCBcIlhSUCxCVENcIiwgXCJYUlAsVVNEXCIsIFwiQlRDLFVTRFwiLCBcIkJUQyxFVVJcIiwg4oCmfVxuICAgIC8vIF9jcnlwdG9DdXJyZW5jaWVzIDogU2V0KDYpIHtcIlhSUFwiLCBcIkJUQ1wiLCBcIkVUSFwiLCBcIkJDSFwiLCBcIkJDSEFCQ1wiLCDigKZ9XG4gICAgLy8gX2ZpYXRDdXJyZW5jaWVzIDogU2V0KDIpIHtcIkVVUlwiLCBcIlVTRFwifVxuICAgIC8vIF9udW1iZXJPZkNyeXB0b0N1cnJlbmNpZXMgOiA2XG4gICAgLy8gX251bWJlck9mQ3J5cHRvUGFpcnMgOiA1XG4gICAgLy8gX251bWJlck9mQ3VycmVuY2llcyA6IDhcbiAgICAvLyBfbnVtYmVyT2ZGaWF0Q3VycmVuY2llcyA6IDJcbiAgICAvLyBfbnVtYmVyT2ZGaWF0UGFpcnMgOiAxM1xuICAgIC8vIF9udW1iZXJPZlBhaXJzIDogMThcbiAgICAvLyBfcG9pbnRzIDogMFxuXG4gICAgY29uc3QgZmlhdElkcyAgID0gcGFyYW1zLmRhdGFbJ2NyeXB0b2h1Yi1leGNoYW5nZXNMaXN0QWNjZXB0c0JvdGgnXSB8fCBbXTtcbiAgICBjb25zdCBjcnlwdG9JZHMgPSBwYXJhbXMuZGF0YVsnY3J5cHRvaHViLWV4Y2hhbmdlc0xpc3RDcnlwdG9Pbmx5J10gfHwgW107XG4gICAgY29uc3QgZXhjaGFuZ2VzID0gZ25wKHdpbmRvdy5jaCwgJ2V4Y2hhbmdlcycpO1xuXG4gICAgLy9cbiAgICAvLyBTdGVwIDE6IENyZWF0ZSB0aGUgYmVsb3cgZGF0YSBzdHJ1Y3R1cmVcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIHtcbiAgICAvLyAgIFVLOiB7ZmlhdDogW10sIGNyeXB0bzogW119LFxuICAgIC8vICAgVVM6IHtmaWF0OiBbXSwgY3J5cHRvOiBbXX0sXG4gICAgLy8gfVxuICAgIC8vIGBgYFxuICAgIC8vXG4gICAgY29uc3Qgb3V0cHV0T2JqZWN0ID0ge307XG4gICAge1xuICAgICAgbGV0IGlkO1xuICAgICAgbGV0IGlkcztcbiAgICAgIGxldCB0eXBlO1xuICAgICAgbGV0IGNvdW50cnk7XG4gICAgICBsZXQgZXhjaGFuZ2U7XG4gICAgICBmb3IgKFt0eXBlLCBpZHNdIG9mIE9iamVjdC5lbnRyaWVzKHtmaWF0OiBmaWF0SWRzLCBjcnlwdG86IGNyeXB0b0lkc30pKSB7XG4gICAgICAgIGZvciAoaWQgb2YgaWRzKSB7XG4gICAgICAgICAgZXhjaGFuZ2UgPSBleGNoYW5nZXNbaWRdO1xuICAgICAgICAgIGlmICghZXhjaGFuZ2UpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvdW50cnkgPSBleGNoYW5nZS5Db3VudHJ5O1xuICAgICAgICAgIGlmICghb3V0cHV0T2JqZWN0W2NvdW50cnldKSB7XG4gICAgICAgICAgICBvdXRwdXRPYmplY3RbY291bnRyeV0gPSB7XG4gICAgICAgICAgICAgIGZpYXQ6IFtdLFxuICAgICAgICAgICAgICBjcnlwdG86IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dE9iamVjdFtjb3VudHJ5XVt0eXBlXS5wdXNoKHtcbiAgICAgICAgICAgIC8vIFRPRE86IGdldCBleGNoYW5nZSB1cmxzXG4gICAgICAgICAgICB1cmw6IGBodHRwczovL3d3dy5jcnlwdG9jb21wYXJlLmNvbSR7ZXhjaGFuZ2UuVXJsfWAsXG4gICAgICAgICAgICBuYW1lOiBleGNoYW5nZS5OYW1lLFxuICAgICAgICAgICAgbG9nb1VybDogZXhjaGFuZ2UuTG9nb1VybCxcbiAgICAgICAgICAgIGRleDogZXhjaGFuZ2UuQ2VudHJhbGl6YXRpb25UeXBlID09PSAnRGVjZW50cmFsaXplZCcsXG4gICAgICAgICAgICBudW1iZXJPZkZpYXRDdXJyZW5jaWVzOiBleGNoYW5nZS5fbnVtYmVyT2ZGaWF0Q3VycmVuY2llcyxcbiAgICAgICAgICAgIG51bWJlck9mQ3J5cHRvY3VycmVuY2llczogZXhjaGFuZ2UuX251bWJlck9mQ3J5cHRvQ3VycmVuY2llc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBTdGVwIDI6IFNvcnQgdGhlIGRhdGEgaW50byBhbiBBcnJheSBiYXNlZCBvbiB0aGUgbW9zdFxuICAgIC8vIHBvcHVsYXIgZ2VvZ3JhcGhpYyBsb2NhdGlvbiAoYXMgYmVsb3cpXG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyBbXG4gICAgLy8gICB7XG4gICAgLy8gICAgIGNvdW50cnk6ICdVSycsXG4gICAgLy8gICAgIGZpYXQ6IFt7bmFtZTogJ0tyYWtlbicsIGRleDogdHJ1ZSwgdXJsLCBmaWF0UGFpcnM6IDMsIGNyeXB0b1BhaXJzOiA0fV0sXG4gICAgLy8gICAgIGNyeXB0bzogW3tuYW1lOiAnQmluYW5jZScsIGRleDogZmFsc2UsIHVybCwgY3J5cHRvUGFpcnM6IDU1fV0sXG4gICAgLy8gICB9XG4gICAgLy8gXVxuICAgIC8vIGBgYFxuICAgIC8vXG4gICAgY29uc3Qgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICB7XG4gICAgICBsZXQgY291bnRyeTtcbiAgICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgICAgZm9yIChbY291bnRyeSwgcHJvcGVydGllc10gb2YgT2JqZWN0LmVudHJpZXMob3V0cHV0T2JqZWN0KSkge1xuICAgICAgICBvdXRwdXRBcnJheS5wdXNoKHtjb3VudHJ5LCAuLi5wcm9wZXJ0aWVzfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dEFycmF5O1xuXG4gIH1cblxuICBmdW5jdGlvbiBleGNoYW5nZUh0bWxDb250ZW50KCkge1xuXG4gICAgY29uc3QgbmFtZSAgICAgICAgICA9IGducChwYXJhbXMsICdkYXRhLmNjLXRvdGFsLXZvbC1mdWxsLUZ1bGxOYW1lLnZhbHVlJyk7XG4gICAgY29uc3QgdG90YWwgICAgICAgICA9IG51bWJlckdyb3VwRGlnaXRzKGducChwYXJhbXMsICd2YWx1ZS52YWx1ZScpKTtcbiAgICBjb25zdCBjbGFzc2VzICAgICAgID0gJ2NoLW51bWJlcm9mZXhjaGFuZ2VzJztcbiAgICBjb25zdCBkZXhMaXN0ICAgICAgID0gcGFyYW1zLmRhdGFbJ2NyeXB0b2h1Yi1leGNoYW5nZXNMaXN0RGV4J10gfHwgW107XG4gICAgY29uc3QgZmlhdElkcyAgICAgICA9IHBhcmFtcy5kYXRhWydjcnlwdG9odWItZXhjaGFuZ2VzTGlzdEFjY2VwdHNCb3RoJ10gfHwgW107XG4gICAgY29uc3QgY3J5cHRvSWRzICAgICA9IHBhcmFtcy5kYXRhWydjcnlwdG9odWItZXhjaGFuZ2VzTGlzdENyeXB0b09ubHknXSB8fCBbXTtcbiAgICBjb25zdCBvdXRwdXRBcnJheSAgID0gZXhjaGFuZ2VEYXRhTW9kZWwoKTtcbiAgICBjb25zdCBudW1iZXJPZlBhaXJzID0gZ25wKHBhcmFtcywgJ2RhdGEuY3J5cHRvaHViLW51bWJlck9mUGFpcnMudmFsdWUnKTtcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0b3RhbCxcbiAgICAgICAgY2xhc3NlcyxcbiAgICAgICAgbnVtYmVyT2ZQYWlycyxcbiAgICAgICAgbnVtYmVyT2ZEZXg6IGRleExpc3QubGVuZ3RoLFxuICAgICAgICBudW1iZXJPZkZpYXQ6IGZpYXRJZHMubGVuZ3RoLFxuICAgICAgICBudW1iZXJPZkNyeXB0bzogY3J5cHRvSWRzLmxlbmd0aCxcbiAgICAgIH0sXG4gICAgICBib2R5OiBvdXRwdXRBcnJheVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnRIdG1sID0gaW5pdFB1Z1snY2gtdGlwcHktY2xpY2snXShvdXRwdXQpO1xuICAgIHJldHVybiBjb250ZW50SHRtbDtcblxuICB9XG5cbiAgY29uc3QgJGNlbGwgPSBwYXJhbXMuZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5hZy1jZWxsJyk7XG4gIGNvbnN0IGlkID0gYGNoLXRpcHB5LSR7Z2V0UmFuZG9tSW50KCl9YDtcbiAgY29uc3QgY3NzSWQgPSBgIyR7aWR9YDtcbiAgY29uc3QgY29udGVudFBvcGRpdiA9IGluaXRQdWdbJ2NoLXRpcHB5LWNsaWNrLXRyYWRpbmd2aWV3J10oe2lkfSk7XG4gIGNvbnN0IGNvbnRlbnRFeGNoYW5nZSA9IGV4Y2hhbmdlSHRtbENvbnRlbnQoKTtcblxuICBodG1sVG9nZ2xlQ2xhc3MoJGNlbGwsICdjaC1jZWxsLWFjdGl2ZScpO1xuICBwb3BEaXYoJGNlbGwsIGNvbnRlbnRQb3BkaXYpO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNzc0lkKS5pbm5lckhUTUwgPSBjb250ZW50RXhjaGFuZ2U7XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gQmluYXJ5IE92ZXJkb3NlIFByb2plY3RzXG5pbXBvcnQgeyBnZXRSYW5kb21JbnQgfSAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5pbXBvcnQgeyBodG1sUG9sbEVsZW1lbnQgfSAgICAgICAgICAgICAgICBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5pbXBvcnQgeyBwYXJ0aWFsQXBwbGljYXRpb24gfSAgICAgICAgICAgICBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5pbXBvcnQgeyBvYmplY3RHZXROZXN0ZWRQcm9wZXJ0eSBhcyBnbnAgfSBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5cbi8vIENyeXB0b2h1YiBVdGlsIGZ1bmN0aW9uc1xuaW1wb3J0IHBvcERpdiBmcm9tICcuL3BvcGRpdi5qcyc7XG5pbXBvcnQgaW5pdFB1ZyBmcm9tICcuLi9nZW5lcmF0ZWQvaW5pdC1wdWcuZ2VuZXJhdGVkLmpzJztcblxuLyoqXG4gKlxuICogTk9URTogTm90IGN1cnJlbnRseSB1c2VkXG4gKlxuICovXG5mdW5jdGlvbiBleGNoYW5nZVN1cHBvcnRlZChleGNoYW5nZXMpIHtcbiAgY29uc3QgbWFwTmFtZUlkID0gZ25wKGNoLCAnZXhjaGFuZ2UtbWFwLW5hbWVJZCcpO1xuICAvLyBUT0RPOiByYW5rIGJ5IGV4Y2hhbmdlIHJhbmtpbmcgdGhhdCB3ZSBoYXZudCBjcmVhdGVkIHlldFxuICBjb25zdCBzdXBwb3J0ZWQgPSBbXG4gICAgJ1BPTE9OSUVYJyxcbiAgICAnQklOQU5DRScsXG4gICAgJ0JJVEZJTkVYJyxcbiAgICAnQklUU1RBTVAnLFxuICAgICdDT0lOQkFTRScsXG4gICAgJ0JJVEZMWUVSJyxcbiAgICAnS09SQklUJyxcbiAgICAnQklUVFJFWCcsXG4gICAgJ01FUkNBRE8nLFxuICAgICdHRU1JTkknLFxuICAgICdCSVRIVU1CJyxcbiAgICAnQ0VYLklPJyxcbiAgICAnQlRDWU9VJyxcbiAgICAnQklUU08nLFxuICAgICdPS0NPSU4nLFxuICAgICdDT0lORkxPT1InLFxuICAgICdUSEVST0NLVFJBRElORycsXG4gICAgJ0lUQklUJyxcbiAgICAnSElUQlRDJyxcbiAgICAnSFVPQkknLFxuICAgICdGT1JFWENPTScsXG4gIF07XG5cbiAgY29uc3QgbWFwID0gT2JqZWN0LmVudHJpZXMobWFwTmFtZUlkKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gICAgYWNjW3ZhbFswXS50b1VwcGVyQ2FzZSgpXSA9IHZhbFsxXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIGNvbnN0IHN1cHBvcnRlZElkcyA9IHN1cHBvcnRlZC5tYXAoYSA9PiBtYXBbYV0pXG5cbiAgcmV0dXJuIHN1cHBvcnRlZElkcztcbn07XG5cbi8qKlxuICpcbiAqIFRSQURJTkdWSUVXIEdFVCBTWU1CT0xcbiAqXG4gKiBUcmFkaW5ndmlldyBzeW1ib2xzIGxvb2tzIGxpa2U6XG4gKlxuICogICBzeW1ib2xGcm9tU3ltYm9sVG9cbiAqICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgIEJUQ1VTRFxuICogICBFVEhCVENcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gYWctZ3JpZCBjZWxsIHBhcmFtcyBvYmplY3RcbiAqIEBwYXJhbSB7U1RyaW5nfSBbc3ltYm9sVG9dIC0gdG8gc3ltYm9sLCBkZWZhdWx0cyB0byBCVENcbiAqIEByZXR1cm4ge1N0cmluZ3x1bmRlZmluZWR9IHN5bWJvbCAtIHRyYWRpbmd2aWV3IHN5bWJvbFxuICpcbiAqL1xuZnVuY3Rpb24gdHJhZGluZ3ZpZXdHZXRTeW1ib2wocGFyYW1zLCBzeW1ib2xUbyA9ICdCVEMnKSB7XG5cbiAgY29uc3QgbWFwID0gZ25wKGNoLCAnZXhjaGFuZ2UtbWFwLWlkTmFtZScpO1xuICBjb25zdCBzeW1ib2xGcm9tID0gZ25wKHBhcmFtcywgJ2RhdGEuY2MtY29pbmxpc3QtU3ltYm9sLnZhbHVlJyk7XG5cbiAgLy9cbiAgLy8gTk9URTogZG9uJ3QgdXNlIGV4Y2hhbmdlLCB0cmFkaW5ndmlldyBmaW5kcyBhIGRlZmF1bHRcbiAgLy9cbiAgLy8gVHJ5IGFuIGV4Y2hhbmdlIHRoYXQgc3VwcG9ydHMgZmlhdCBmaXJzdFxuICAvLyBjb25zdCBleGNoYW5nZUxpc3QxID0gZXhjaGFuZ2VTdXBwb3J0ZWQoZ25wKHBhcmFtcywgJ2RhdGEuY3J5cHRvaHViLWV4Y2hhbmdlc0xpc3RBY2NlcHRzQm90aCcpKTtcbiAgLy8gY29uc3QgZXhjaGFuZ2VMaXN0MiA9IGV4Y2hhbmdlU3VwcG9ydGVkKGducChwYXJhbXMsICdkYXRhLmNyeXB0b2h1Yi1leGNoYW5nZXNMaXN0Q3J5cHRvT25seScpKTtcblxuICAvLyBjb25zdCBleGNoYW5nZSA9IG1hcCAmJiBleGNoYW5nZUxpc3QxLmxlbmd0aFxuICAvLyAgID8gbWFwW2V4Y2hhbmdlTGlzdDFbMF1dXG4gIC8vICAgOiBtYXAgJiYgZXhjaGFuZ2VMaXN0Mi5sZW5ndGhcbiAgLy8gICAgID8gbWFwW2V4Y2hhbmdlTGlzdDJbMF1dXG4gIC8vICAgICA6IHZvaWQgMDtcblxuICBpZiAoc3ltYm9sRnJvbSAmJiBzeW1ib2xUbykge1xuICAgIGNvbnN0IHBhaXIgPSBzeW1ib2xGcm9tLnRvVXBwZXJDYXNlKCkgKyBzeW1ib2xUby50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IGAke3BhaXJ9YDtcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ2Fubm90IGNvbnN0cnVjdCB0cmFkaW5ndmlldyBzeW1ib2wnKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBMT0FEIFRSQURJTkdWSUVXXG4gKlxuICogTG9hZCBhIHRyYWRpbmcgdmlldyB3aWRnZXQgdXNpbmcgYWctZ3JpZCBjZWxsIHBhcmFtcyBhcyBkYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIGFnLWdyaWQgY2VsbCBwYXJhbXMgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGFpbmVyX2lkIC0gaHRtbCBpZCBvZiB3aGVyZSB0byBsb2FkIHRoZSB3aWRnZXRcbiAqIEBwYXJhbSB7U1RyaW5nfSBbc3ltYm9sVG9dIC0gdG8gc3ltYm9sLCBkZWZhdWx0cyB0byBCVENcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGxvYWRUcmFkaW5ndmlldyhwYXJhbXMsIGNvbnRhaW5lcl9pZCwgc3ltYm9sVG8gPSAnQlRDJykge1xuICBjb25zdCBzeW1ib2wgPSB0cmFkaW5ndmlld0dldFN5bWJvbChwYXJhbXMsIHN5bWJvbFRvKTtcbiAgaWYgKHN5bWJvbCkge1xuICAgIG5ldyBUcmFkaW5nVmlldy53aWRnZXQoe1xuICAgICAgc3ltYm9sLFxuICAgICAgY29udGFpbmVyX2lkLFxuICAgICAgYXV0b3NpemU6IHRydWUsXG4gICAgICBpbnRlcnZhbDogJ0QnLFxuICAgICAgdGltZXpvbmU6ICdFdGMvVVRDJyxcbiAgICAgIHRoZW1lOiAnTGlnaHQnLFxuICAgICAgc3R5bGU6ICcxJyxcbiAgICAgIGxvY2FsZTogJ3VrJyxcbiAgICAgIHRvb2xiYXJfYmc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpJyxcbiAgICAgIGVuYWJsZV9wdWJsaXNoaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93X3N5bWJvbF9jaGFuZ2U6IHRydWUsXG4gICAgICBzYXZlX2ltYWdlOiBmYWxzZSxcbiAgICAgIHN0dWRpZXM6IFtcbiAgICAgICAgJ01BRXhwQHR2LWJhc2ljc3R1ZGllcydcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdDYW5ub3QgbG9hZCB0cmFkaW5ndmlldyB3aW5kb3csIG1pc3NpbmcgaW5pdGlhbGl6YXRpb24gZGF0YScpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNlbGxPbkNsaWNrVHJhZGluZ3ZpZXcoc3ltYm9sVG8sIHBhcmFtcykge1xuXG4gIGNvbnN0IGlkID0gYGNoLXRpcHB5LSR7Z2V0UmFuZG9tSW50KCl9YDtcbiAgY29uc3QgY3NzSWQgPSBgIyR7aWR9YDtcbiAgY29uc3QgY29udGVudCA9IGluaXRQdWdbJ2NoLXRpcHB5LWNsaWNrLXRyYWRpbmd2aWV3J10oe2lkfSk7XG4gIGNvbnN0ICRjZWxsID0gcGFyYW1zLmV2ZW50LnRhcmdldC5jbG9zZXN0KCcuYWctY2VsbCcpO1xuICBwb3BEaXYoJGNlbGwsIGNvbnRlbnQpO1xuICBodG1sUG9sbEVsZW1lbnQoY3NzSWQsIDEwMCwgcGFydGlhbEFwcGxpY2F0aW9uKGxvYWRUcmFkaW5ndmlldywgcGFyYW1zLCBpZCwgc3ltYm9sVG8pKTtcblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBCaW5hcnkgT3ZlcmRvc2UgUHJvamVjdHNcbmltcG9ydCB7IGlzTnVtYmVyIH0gICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IGRpZmZOdW1lcmljU3RyaW5ncyB9ICAgICAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IGZvcm1hdE51bWJlckFzQ3VycmVuY3kgfSAgICAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IG9iamVjdEdldE5lc3RlZFByb3BlcnR5IGFzIGducCB9IGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcblxuLy8gQ3J5cHRvaHViIFV0aWwgZnVuY3Rpb25zXG5pbXBvcnQgZ2V0Q3NzQ2xhc3MgZnJvbSAnLi9nZXQtY2VsbC1jc3MtY2xhc3MtZGlmZi5qcyc7XG5cbi8qKlxuICpcbiAqIENlbGwgUmVuZGVyZXIgQ3VycmVuY3lcbiAqXG4gKiBSZW5kZXIgbnVtYmVycyBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogJDEyMyw0NTYsNzg5LjAwXG4gKiBIaWdobGlnaHQgY2hhbmdlcyBiZXR3ZWVuIHByZXZpb3VzIHZlcnNpb25zIGxpa2Ugc286IDxzcGFuPiQxMjMsNDU8L3NwYW4+PHNwYW4+MSw3ODkuMDA8L3NwYW4+XG4gKiBDb2xvdXIgdGhlIGNoYW5nZWQgcGFydCBvZiB0aGUgbnVtYmVyIGluIGdyZWVuIG9yIHJlZCBkZXBlbmRpbmcgb24gY2hhbmdlIGRpcmVjdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZzXG4gKiBAcGFyYW0ge1N0cmluZ30gY3VycmVuY3lcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2VsbFJlbmRlcmVyQ3VycmVuY3kocmVmcywgcGFyYW1zKSB7XG5cbiAgbGV0IHJlc3VsdCA9IGNoLmVtcHR5Q2VsbFZhbHVlO1xuICBpZiAoIXBhcmFtcy52YWx1ZSkgcmV0dXJuIHJlc3VsdDtcblxuICBjb25zdCB7IGNvbERlZiwgZGF0YSB9ID0gcGFyYW1zO1xuICBjb25zdCBodG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgY29uc3QgbmV3VmFsdWUgPSBnbnAocGFyYW1zLCAndmFsdWUudmFsdWUnKTtcbiAgY29uc3Qgb2xkVmFsdWUgPSBnbnAocGFyYW1zLCBgZGF0YS4ke3BhcmFtcy5jb2xEZWYuZmllbGR9Omxhc3RgKTtcblxuICAvLyBmb3JtYXQgbnVtYmVyXG4gIGxldCBuZXdWYWw7XG4gIGxldCBvbGRWYWw7XG4gIGNvbnN0IGRpZ2l0cyA9IG5ld1ZhbHVlID49IDEgPyAyIDogNjtcbiAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkgbmV3VmFsID0gZm9ybWF0TnVtYmVyQXNDdXJyZW5jeShuZXdWYWx1ZSwgcGFyYW1zLmN1cnJlbmN5KTtcbiAgaWYgKGlzTnVtYmVyKG9sZFZhbHVlKSkgb2xkVmFsID0gZm9ybWF0TnVtYmVyQXNDdXJyZW5jeShvbGRWYWx1ZSwgcGFyYW1zLmN1cnJlbmN5KTtcblxuICBpZiAoaXNOdW1iZXIobmV3VmFsdWUpICYmICFpc051bWJlcihvbGRWYWx1ZSkpIHtcbiAgICByZXN1bHQgPSBuZXdWYWw7XG4gIH1cbiAgZWxzZSB7XG5cbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBkaWZmTnVtZXJpY1N0cmluZ3Mob2xkVmFsLCBuZXdWYWwpO1xuICAgIGNvbnN0IGNzc0NsYXNzID0gZ2V0Q3NzQ2xhc3Mob2xkVmFsLCBuZXdWYWwpO1xuICAgIHJlc3VsdCA9IGA8c3Bhbj4ke3N0YXJ0fTwvc3Bhbj48c3BhbiBjbGFzcz1cIiR7Y3NzQ2xhc3N9XCI+JHtlbmR9PC9zcGFuPmA7XG5cbiAgfVxuXG4gIGh0bWwuaW5uZXJIVE1MID0gcmVzdWx0O1xuXG4gIHJldHVybiBodG1sO1xuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEJpbmFyeSBPdmVyZG9zZSBQcm9qZWN0c1xuaW1wb3J0IHsgbnVtYmVyR3JvdXBEaWdpdHMgfSAgICAgICAgICAgICAgZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuaW1wb3J0IHsgb2JqZWN0R2V0TmVzdGVkUHJvcGVydHkgYXMgZ25wIH0gZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuXG4vKipcbiAqXG4gKiBDZWxsIFJlbmRlcmVyIEV4Y2hhbmdlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2VsbFJlbmRlcmVyRXhjaGFuZ2VzKHBhcmFtcykge1xuXG4gIGNvbnN0IHRvdGFsID0gbnVtYmVyR3JvdXBEaWdpdHMoZ25wKHBhcmFtcywgJ3ZhbHVlLnZhbHVlJykpO1xuICBjb25zdCBsaW5rSHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgbGlua0h0bWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGBjcnlwdG9odWItbGluayBjaC1udW1iZXJvZmV4Y2hhbmdlcy1saW5rYCk7XG4gIGxpbmtIdG1sLmlubmVySFRNTCA9IHRvdGFsO1xuICByZXR1cm4gbGlua0h0bWw7XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgb2JqZWN0R2V0TmVzdGVkUHJvcGVydHkgYXMgZ25wIH0gZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuXG4vKipcbiAqXG4gKiBDRUxMIFJFTkRFUkVSIE5BTUVcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNlbGxSZW5kZXJlck5hbWUocGFyYW1zKSB7XG5cbiAgY29uc3QgZmlsZU5hbWUgPSBnbnAocGFyYW1zLCAnZGF0YS5jYy10b3RhbC12b2wtZnVsbC1JbWFnZVVybC52YWx1ZScpO1xuICBjb25zdCBpbWdVcmwgPSBgaHR0cHM6Ly93d3cuY3J5cHRvY29tcGFyZS5jb20ke2ZpbGVOYW1lfWA7XG5cbiAgY29uc3Qgc3ltYm9sID0gZ25wKHBhcmFtcywgJ2RhdGEuY2MtY29pbmxpc3QtU3ltYm9sLnZhbHVlJyk7XG4gIGNvbnN0IGltZyA9IGltZ1VybCA/IGA8aW1nIHNyYz1cIiR7aW1nVXJsfVwiIGNsYXNzPVwiY2gtaWNvbnNcIiAvPmAgOiAnJztcblxuICBjb25zdCBvdXRwdXQgPSBgXG4gICAgPGRpdiBjbGFzcz1cImNoLWNvbC1uYW1lXCI+XG4gICAgICAke2ltZ31cbiAgICAgIDxzdHJvbmc+JHtwYXJhbXMudmFsdWV9PC9zdHJvbmc+PHNwYW4+ICgke3N5bWJvbH0pPC9zcGFuPlxuICAgIDwvZGl2PlxuICBgXG5cbiAgcmV0dXJuIG91dHB1dDtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgbnVtYmVyR3JvdXBEaWdpdHMgfSAgICAgICAgICAgICAgZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuaW1wb3J0IHsgb2JqZWN0R2V0TmVzdGVkUHJvcGVydHkgYXMgZ25wIH0gZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuXG4vKipcbiAqXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjZWxsUmVuZGVyZXJOdW1iZXIocGFyYW1zKSB7XG4gIGNvbnN0IG51bWJlciA9IGducChwYXJhbXMsICd2YWx1ZS52YWx1ZScpO1xuICByZXR1cm4gbnVtYmVyR3JvdXBEaWdpdHMobnVtYmVyKSB8fCAnLSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqXG4gKiBDZWxsIFJlbmRlcmVyIEV4Y2hhbmdlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2VsbFJlbmRlcmVyVHJhZGluZ3ZpZXcocGFyYW1zKSB7XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgdGltZUFnbyB9IGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcblxuLyoqXG4gKlxuICogQ0VMTCBUT09MVElQXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2VsbFRvb2x0aXAocGFyYW1zKSB7XG4gIGNvbnN0IHsgZGF0YSwgY29sRGVmIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGZpZWxkID0gZGF0YVtjb2xEZWYuZmllbGRdO1xuICBjb25zdCB0aW1lc3RhbXAgPSBmaWVsZCAmJiBmaWVsZC50aW1lc3RhbXA7XG4gIGNvbnN0IHQgPSB0aW1lQWdvKHRpbWVzdGFtcCkgfHwgJ3Vua25vd24gdGltZSBhZ28nO1xuICByZXR1cm4gYExhc3QgdXBkYXRlZCAke3R9YDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgZDNTcGFya2xpbmUgfSAgICAgIGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcbmltcG9ydCB7IGFycmF5QXZlcmFnZSB9ICAgICBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5pbXBvcnQgeyBkM1NpbXBsZUJhckNoYXJ0IH0gZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuXG5cbi8qKlxuICpcbiAqIFByaWNlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhbmdlXG4gKlxuICovXG5mdW5jdGlvbiBwcmljZShhcnIsIHJhbmdlKSB7XG5cbiAgY29uc3QgcHJpY2VEYXRhID0gYXJyLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICBhY2MucHVzaCh7XG4gICAgICB4OiB2YWwudGltZXN0YW1wLCB5OiB2YWwucHJpY2VcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGQzU3BhcmtsaW5lKHtcbiAgICByYW5nZSxcbiAgICBkYXRhOiBwcmljZURhdGEsXG4gICAgd2lkdGg6IDEwMCxcbiAgICBoZWlnaHQ6IDMyLFxuICAgIHN0eWxlczogJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMTFweCdcbiAgfSk7XG5cbn1cblxuLyoqXG4gKlxuICogVm9sdW1lXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZvbHVtZURheXNdXG4gKlxuICovXG5mdW5jdGlvbiB2b2x1bWUoYXJyLCByYW5nZSwgdm9sdW1lRGF5cyA9IDcpIHtcblxuICBjb25zdCB2b2x1bWVEYXRhID0gW107XG4gIGNvbnN0IGRhdGEgPSBhcnIucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgIGFjYy5wdXNoKHtcbiAgICAgIHg6IHZhbC50aW1lc3RhbXAsIHk6IHZhbC52b2x1bWVcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgbnVtRGF5cyA9IHZvbHVtZURheXM7XG4gIGNvbnN0IHN0ZXBzID0gTWF0aC5tYXgoTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIG51bURheXMpLCAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSA9IGkgKyBzdGVwcykge1xuXG4gICAgY29uc3QgcDAgPSBkYXRhW2ldO1xuICAgIGNvbnN0IHAxID0gZGF0YVtpICsgMV07XG4gICAgY29uc3QgcDIgPSBkYXRhW2kgKyAyXTtcbiAgICBjb25zdCB5MCA9IHAwLnk7XG4gICAgY29uc3QgeTEgPSBwMSA/IHAxLnkgOiB5MDtcbiAgICBjb25zdCB5MiA9IHAyID8gcDIueSA6IHkxO1xuXG4gICAgLy8gVGFrZSB0aGUgYXZlcmFnZSBvZiAzIHZvbHVtZXMgYW5kIHRoZSBtaWRkbGUgdGltZXN0YW1wXG4gICAgdm9sdW1lRGF0YS5wdXNoKHtcbiAgICAgIHg6IHAxID8gcDEueCA6IHAwLngsXG4gICAgICB5OiBhcnJheUF2ZXJhZ2UoW3kwLCB5MSwgeTJdKVxuICAgIH0pO1xuXG4gIH1cblxuICByZXR1cm4gZDNTaW1wbGVCYXJDaGFydCh7XG4gICAgcmFuZ2UsXG4gICAgZGF0YTogdm9sdW1lRGF0YSxcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAsXG4gICAgZmlsbDogJyNjYWVjZmMnLFxuICAgIHN0eWxlczogJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAwOyByaWdodDogMTFweCdcbiAgfSk7XG5cbn1cblxuLyoqXG4gKlxuICogQ2VsbCByZW5kZXJlciBjbGFzc1xuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgY2VsbFJlbmRlcmVyU3BhcmtsaW5lIHtcblxuICAvLyBnZXRzIGNhbGxlZCBvbmNlIGJlZm9yZSB0aGUgcmVuZGVyZXIgaXMgdXNlZFxuICBpbml0KHBhcmFtcykge1xuXG4gICAgaWYgKCFwYXJhbXMudmFsdWUpIHJldHVybjtcblxuICAgIGxldCB0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFyYW1zLnZhbHVlKSk7XG5cbiAgICBpZiAocGFyYW1zLnByaWNlKSAgdGhpcy5wcmljZSAgPSBwcmljZSh0cywgISFwYXJhbXMucmFuZ2UpO1xuICAgIGlmIChwYXJhbXMudm9sdW1lKSB0aGlzLnZvbHVtZSA9IHZvbHVtZSh0cywgISFwYXJhbXMucmFuZ2UsIHBhcmFtcy52b2x1bWVEYXlzKTtcblxuICB9XG5cbiAgLy8gZ2V0cyBjYWxsZWQgb25jZSB3aGVuIGdyaWQgcmVhZHkgdG8gaW5zZXJ0IHRoZSBlbGVtZW50XG4gIGdldEd1aSgpIHtcblxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgaWYgKHRoaXMudm9sdW1lKSB7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy52b2x1bWUubm9kZSgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJpY2UpIHtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnByaWNlLm5vZGUoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5lR3VpID0gZGl2O1xuICAgIHJldHVybiB0aGlzLmVHdWk7XG5cbiAgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEJpbmFyeSBPdmVyZG9zZSBQcm9qZWN0c1xuaW1wb3J0IHsgb2JqZWN0R2V0TmVzdGVkUHJvcGVydHkgYXMgZ25wIH0gZnJvbSAnLi4vbGlicy9iby11dGlscy1jbGllbnQnO1xuXG4vLyBDcnlwdG9odWIgVXRpbCBmdW5jdGlvbnNcbmltcG9ydCBnZXRDc3NDbGFzcyBmcm9tICcuL2dldC1jZWxsLWNzcy1jbGFzcy1kaWZmLmpzJztcblxuLyoqXG4gKlxuICogQ2VsbCByZW5kZXJlciBjbGFzc1xuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG91bmRDZWxsUmVuZGVyZXIge1xuXG4gIC8vIGdldHMgY2FsbGVkIG9uY2UgYmVmb3JlIHRoZSByZW5kZXJlciBpcyB1c2VkXG4gIGluaXQocGFyYW1zKSB7XG5cbiAgICB0aGlzLmVHdWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNyeXB0b2h1YkxvYWRDZWxsKHBhcmFtcyk7XG5cbiAgfVxuXG4gIC8vIGdldHMgY2FsbGVkIG9uY2Ugd2hlbiBncmlkIHJlYWR5IHRvIGluc2VydCB0aGUgZWxlbWVudFxuICBnZXRHdWkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZUd1aTtcbiAgfVxuXG4gIC8vIGdldHMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIGdldHMgdGhlIGNlbGwgdG8gcmVmcmVzaFxuICByZWZyZXNoKHBhcmFtcykge1xuICAgIHRoaXMuY3J5cHRvaHViTG9hZENlbGwocGFyYW1zKTtcbiAgfVxuXG4gIGNyeXB0b2h1YkxvYWRDZWxsKHBhcmFtcykge1xuXG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWRcbiAgICAgID8gcGFyYW1zLnZhbHVlRm9ybWF0dGVkXG4gICAgICA6IGducChwYXJhbXMsICd2YWx1ZS52YWx1ZScpO1xuXG4gICAgY29uc3QgZGF0YSA9IGA8c3BhbiBjbGFzcz1cImNyeXB0b2h1Yi1jZWxsLWRhdGFcIj4tPC9zcGFuPmA7XG5cbiAgICB0aGlzLmVHdWkuaW5uZXJIVE1MID0gZGF0YTtcblxuICAgIC8vIGdldCByZWZlcmVuY2VzIHRvIHRoZSBlbGVtZW50cyB3ZSB3YW50XG4gICAgdGhpcy5lVmFsdWUgPSB0aGlzLmVHdWkucXVlcnlTZWxlY3RvcignLmNyeXB0b2h1Yi1jZWxsLWRhdGEnKTtcblxuICAgIC8vIHNldCB2YWx1ZSBpbnRvIGNlbGxcbiAgICB0aGlzLmVWYWx1ZS5pbm5lckhUTUwgPSB2YWx1ZTtcblxuICB9XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKlxuICogQ29udmVydCBXb3JraW5nIERhdGEgdG8gUm93IERhdGFcbiAqXG4gKiBVbk1pbmlmeSBkYXRhICYgZXhwYW5kIHRpbWVzdGFtcHMgLyB2YWx1ZSBpbnRvIG9iamVjdFxuICogQ3JlYXRlcyBhZy1ncmlkIEFycmF5IHJvdyBkYXRhXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIGFycmF5IG9mIGRhdGEgb2JqZWN0cyB0byB1bnBhY2tcbiAqIEByZXR1cm4ge0FycmF5fSB1bnBhY2tlZCBhcnJheSBkYXRhXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0V29ya2luZ0RhdGFUb1Jvd0RhdGEoZGF0YSkge1xuXG4gIGRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcblxuICBpZiAoZGF0YS5rZXlzKSB7XG5cbiAgICAvL1xuICAgIC8vIFVuTWluaWZ5XG4gICAgLy9cbiAgICBsZXQgaWQsIGl0ZW07XG4gICAgbGV0IGtleSwgdmFsO1xuICAgIGxldCBuZXdPYmo7XG4gICAgbGV0IG5ld0RhdGEgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gZGF0YS5rZXlzO1xuICAgIGRlbGV0ZSBkYXRhLmtleXM7XG4gICAgZm9yIChbaWQsIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICBuZXdPYmogPSB7fTtcbiAgICAgIGZvciAoW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICBuZXdPYmpba2V5c1trZXldXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaWRdID0gbmV3T2JqO1xuICAgIH1cbiAgICBkYXRhID0gbmV3RGF0YTtcblxuICB9XG5cblxuICAvL1xuICAvLyBDb252ZXJ0IGRhdGEgT2JqZWN0IHRvIEFycmF5XG4gIC8vXG4gIGNvbnN0IGFycmF5RGF0YSA9IFtdO1xuICBmb3IgKGxldCBbaWQsIG9ial0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICBvYmouaWQgPSBvYmouSWQ7XG4gICAgYXJyYXlEYXRhLnB1c2gob2JqKTtcbiAgfVxuICBkYXRhID0gYXJyYXlEYXRhO1xuXG4gIC8vXG4gIC8vIEV4cGFuZCB0aW1lc3RhbXAgLyB2YWx1ZVxuICAvL1xuICBjb25zdCByZWdleCA9IC8tdGltZXN0YW1wJC9nO1xuICBsZXQgbWF0Y2g7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IHZhbHVlS2V5O1xuICBsZXQgdGltZXN0YW1wO1xuICBsZXQgZCwgaywgdjtcbiAgZm9yIChkIG9mIGRhdGEpIHtcbiAgICBmb3IgKFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhkKSkge1xuICAgICAgbWF0Y2ggPSBrLm1hdGNoKHJlZ2V4KTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVLZXkgPSBrLnJlcGxhY2UocmVnZXgsICcnKTtcbiAgICAgICAgdmFsdWUgPSBkW3ZhbHVlS2V5XTtcbiAgICAgICAgdGltZXN0YW1wID0gZFtrXTtcbiAgICAgICAgZFt2YWx1ZUtleV0gPSB7XG4gICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBkW2tdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBOdW1iZXJGbG9hdGluZ0ZpbHRlcigpIHt9XG5cbk51bWJlckZsb2F0aW5nRmlsdGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHRoaXMub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQgPSBwYXJhbXMub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQ7XG4gICAgdGhpcy5lR3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5lR3VpLmlubmVySFRNTCA9ICc8aW5wdXQgdHlwZT1cInRleHRcIi8+JztcbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5lRmlsdGVySW5wdXQgPSB0aGlzLmVHdWkucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb25JbnB1dEJveENoYW5nZWQoKXtcbiAgICAgICAgaWYgKHRoYXQuZUZpbHRlcklucHV0LnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgLy9SZW1vdmUgdGhlIGZpbHRlclxuICAgICAgICAgICAgdGhhdC5vbkZsb2F0aW5nRmlsdGVyQ2hhbmdlZChudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuY3VycmVudFZhbHVlID0gdGhhdC5lRmlsdGVySW5wdXQudmFsdWU7XG4gICAgICAgIHRoYXQub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQodGhhdC5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLmVGaWx0ZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIG9uSW5wdXRCb3hDaGFuZ2VkKTtcbn07XG5cbk51bWJlckZsb2F0aW5nRmlsdGVyLnByb3RvdHlwZS5vblBhcmVudE1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJlbnRNb2RlbCkge1xuICAgIC8vIFdoZW4gdGhlIGZpbHRlciBpcyBlbXB0eSB3ZSB3aWxsIHJlY2VpdmUgYSBudWxsIG1lc3NhZ2UgaGVyXG4gICAgaWYgKCFwYXJlbnRNb2RlbCkge1xuICAgICAgICB0aGlzLmVGaWx0ZXJJbnB1dC52YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZUZpbHRlcklucHV0LnZhbHVlID0gcGFyZW50TW9kZWwgKyAnJztcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VmFsdWUgPSBwYXJlbnRNb2RlbDtcbn07XG5cbk51bWJlckZsb2F0aW5nRmlsdGVyLnByb3RvdHlwZS5nZXRHdWkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZUd1aTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlckZsb2F0aW5nRmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBOdW1iZXJGaWx0ZXIoKSB7fVxuXG5OdW1iZXJGaWx0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdGhpcy52YWx1ZUdldHRlciA9IHBhcmFtcy52YWx1ZUdldHRlcjtcbiAgICB0aGlzLmZpbHRlclRleHQgPSBudWxsO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuc2V0dXBHdWkoKTtcbn07XG5cbi8vIG5vdCBjYWxsZWQgYnkgYWctR3JpZCwganVzdCBmb3IgdXMgdG8gaGVscCBzZXR1cFxuTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5zZXR1cEd1aSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmd1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZ3VpLmlubmVySFRNTCA9XG4gICAgICAgICc8ZGl2IHN0eWxlPVwicGFkZGluZzogNHB4OyB3aWR0aD0xMDBweFwiPicgK1xuICAgICAgICAnPGRpdiBzdHlsZT1cImZvbnQtd2VpZ2h0OiBib2xkO1wiPkdyZWF0ZXIgdGhhbjogPC9kaXY+JyArXG4gICAgICAgICc8ZGl2PjxpbnB1dCBzdHlsZT1cIm1hcmdpbjogNHB4IDBweCA0cHggMHB4OyB3aWR0aDogMTAwcHhcIiB0eXBlPVwidGV4dFwiIGlkPVwiZmlsdGVyVGV4dFwiIHBsYWNlaG9sZGVyPVwiTnVtYmVyIG9mIG1lZGFscy4uLlwiLz48L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2Pic7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5vbkZpbHRlckNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5leHRyYWN0RmlsdGVyVGV4dCgpO1xuICAgICAgICB0aGF0LnBhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgdGhpcy5lRmlsdGVyVGV4dCA9IHRoaXMuZ3VpLnF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXJUZXh0Jyk7XG4gICAgdGhpcy5lRmlsdGVyVGV4dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5vbkZpbHRlckNoYW5nZWQpO1xufTtcblxuTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5leHRyYWN0RmlsdGVyVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbHRlclRleHQgPSB0aGlzLmVGaWx0ZXJUZXh0LnZhbHVlO1xufTtcblxuTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5nZXRHdWkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3VpO1xufTtcblxuLy9cbi8vIFRPRE86ID0wIGRvZXNudCB3b3JrXG4vLyBUT0RPOiBkZWNpbWFscyBkb250IHdvcmtcbi8vXG5OdW1iZXJGaWx0ZXIucHJvdG90eXBlLmRvZXNGaWx0ZXJQYXNzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICBjb25zdCB2YWx1ZUdldHRlciA9IHRoaXMudmFsdWVHZXR0ZXI7XG4gIGNvbnN0IHZhbHVlID0gdmFsdWVHZXR0ZXIocGFyYW1zKS52YWx1ZTtcblxuICBjb25zdCBpbnB1dCA9IHRoaXMuZmlsdGVyVGV4dC5yZXBsYWNlKC9cXHMvZywnJyk7XG4gIGNvbnN0IHNwbGl0ID0gaW5wdXQubWF0Y2goL1swLTldK3w+PXw8PXxbPD4mfCgpXS9naSk7XG4gIGNvbnN0IHdoaXRlbGlzdCA9IFsnPCcsICc+JywgJzw9JywgJz49JywgJyYnLCAnfCcsICcoJywgJyknXTtcbiAgY29uc3Qgc2lnbnMgPSBzcGxpdC5maWx0ZXIoaXNOYU4pO1xuICBjb25zdCBhcmVBbGxWYWxpZCA9IHNpZ25zLnNvbWUoc2lnbiA9PiB7XG4gICAgcmV0dXJuIHdoaXRlbGlzdC5pbmNsdWRlcyhzaWduKTtcbiAgfSk7XG5cbiAgY29uc3QgbnVtQmVmb3JlU2lnbnMgPSBbJzwnLCAnPicsICc8PScsICc+PSddO1xuICBjb25zdCBudW0gPSA4MDtcbiAgY29uc3QgZ2VuZXJhdGVFeHByZXNzaW9uID0gbnVtID0+IHtcbiAgICByZXR1cm4gc3BsaXQucmVkdWNlKChhY2MsIHZhbCwgaWR4KSA9PiB7XG4gICAgICBpZiAobnVtQmVmb3JlU2lnbnMuaW5jbHVkZXModmFsKSkgYWNjLnB1c2gobnVtKTtcbiAgICAgIGFjYy5wdXNoKGlzTmFOKHZhbCkgPyB2YWwgOiBOdW1iZXIodmFsKSlcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pLmpvaW4oJycpO1xuICB9XG5cbiAgY29uc3QgZXhwcmVzc2lvblN0ciA9IGdlbmVyYXRlRXhwcmVzc2lvbih2YWx1ZSk7XG5cbiAgbGV0IHBhc3NlZDtcbiAgdHJ5IHtcbiAgICBwYXNzZWQgPSAobmV3IEZ1bmN0aW9uKGByZXR1cm4gJHtleHByZXNzaW9uU3RyfWApKSgpO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIHBhc3NlZCA9IDE7XG4gIH1cblxuICByZXR1cm4gcGFzc2VkO1xufTtcblxuTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5pc0ZpbHRlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIHRoaXMuZmlsdGVyVGV4dCAhPT0gbnVsbCAmJlxuICAgICAgICB0aGlzLmZpbHRlclRleHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0aGlzLmZpbHRlclRleHQgIT09ICcnO1xufTtcblxuTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ZpbHRlckFjdGl2ZSgpID8gdGhpcy5lRmlsdGVyVGV4dC52YWx1ZSA6IG51bGw7XG59O1xuXG5OdW1iZXJGaWx0ZXIucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgdGhpcy5lRmlsdGVyVGV4dC52YWx1ZSA9IG1vZGVsO1xuICAgIHRoaXMuZXh0cmFjdEZpbHRlclRleHQoKTtcbn07XG5cblxuTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZUZpbHRlclRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMub25GaWx0ZXJDaGFuZ2VkKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlckZpbHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKlxuICogR2V0IENlbGwgQ1NTIENsYXNzIERpZmZcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmV3VmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGEgQ1NTIGNsYXNzIG5hbWVcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENlbGxDc3NDbGFzc0RpZmYob2xkVmFsLCBuZXdWYWwpIHtcbiAgY29uc3QgY3NzQ2xhc3MgPSBuZXdWYWwgPCBvbGRWYWxcbiAgICA/ICdjcnlwdG9odWItdGV4dC1kZWZhdWx0IGNyeXB0b2h1Yi10ZXh0LWJhZC1mYWRlJ1xuICAgIDogbmV3VmFsID4gb2xkVmFsXG4gICAgICA/ICdjcnlwdG9odWItdGV4dC1kZWZhdWx0IGNyeXB0b2h1Yi10ZXh0LWdvb2QtZmFkZSdcbiAgICAgIDogJ2NyeXB0b2h1Yi10ZXh0LWRlZmF1bHQnO1xuICByZXR1cm4gY3NzQ2xhc3M7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIFBPUERJVlxuICpcbiAqIEluaXRpYWxpemUgYSBUaXBweSBwb3BkaXYgb24gYSBIVE1MIGVsZW1lbnRcbiAqIEJ5IGRlZmF1bHQgdGhlIHBvcGRpdiBpcyBzaG93biBvbiBpbml0aWFsaXphdGlvbiB2aWEgdGhlIGBzaG93T25Jbml0YCBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufSBjb250ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdGlwcHlPcHRpb25zIC0gdXNlIHRvIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBvcHRpb25zIHNldHVwIGhlcmVcbiAqXG4gKiBAc2VlIGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy9cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvcERpdihlbGVtZW50LCBjb250ZW50LCB0aXBweU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBhcHBlbmRUbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hZy1ib2R5Jyk7XG4gIGNvbnN0IGRlZmF1bHRUaXBweU9wdGlvbnMgPSB7XG4gICAgcG9wcGVyT3B0aW9uczoge1xuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgIGVzY2FwZVdpdGhSZWZlcmVuY2U6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGU6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gICAgY29udGVudCxcbiAgICBhcHBlbmRUbyxcbiAgICBmbGlwOiBmYWxzZSxcbiAgICBhcnJvdzogZmFsc2UsXG4gICAgdGhlbWU6ICdsaWdodCcsXG4gICAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICBhbGxvd0hUTUw6IHRydWUsXG4gICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICBzaG93T25Jbml0OiB0cnVlLFxuICAgIGhpZGVPbkNsaWNrOiAndG9nZ2xlJyxcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBpbnRlcmFjdGl2ZUJvcmRlcjogNSxcbiAgICBpbnRlcmFjdGl2ZURlYm91bmNlOiAxLFxuICB9XG4gIHRpcHB5KGVsZW1lbnQsIE9iamVjdC5hc3NpZ24oZGVmYXVsdFRpcHB5T3B0aW9ucywgdGlwcHlPcHRpb25zKSk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBvYmplY3RHZXROZXN0ZWRQcm9wZXJ0eSBhcyBnbnAgfSBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5cbi8qKlxuICpcbiAqIFNIT1VMRCBDRUxMIFVQREFURVxuICpcbiAqIERlY2lkZSB3aGV0aGVyIHRvIHVwZGF0ZSB0aGUgY2VsbCBvciBub3QuXG4gKiBOb3RlIHdlIERPIHdhbnQgdG8gdXBkYXRlIHRoZSBjZWxsIGV2ZW4gaWYgdGhlIGRhdGEgaGFzbnQgY2hhbmdlZCBzb1xuICogdGhhdCB0aGUgSFRNTCByZWxvYWRzLiBUaGF0IHNhaWQgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgaWYgd2UgaGF2ZSBubyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IG5ld1ZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hvdWxkQ2VsbFVwZGF0ZShvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGducChvbGRWYWx1ZSwgJ3ZhbHVlJykgPT09IGducChuZXdWYWx1ZSwgJ3ZhbHVlJykpXG4gICAgICAmJiAoZ25wKG9sZFZhbHVlLCAndGltZXN0YW1wJykgPT09IGducChuZXdWYWx1ZSwgJ3RpbWVzdGFtcCcpKTtcbiAgfVxuICBjYXRjaChlcnJvcikge1xuICAgIGRlYnVnZ2VyO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIFNPUlQgTlVNQkVSU1xuICpcbiAqIENvbXBhcmUgbnVtYmVycyB0aGF0IGFyZSBwcm92aWRlZCBvbiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGQxIC0gdGhlIGZpcnN0IGl0ZW0gdG8gY29tcGFyZVxuICogQHBhcmFtIHtPYmplY3R9IGQxIC0gdGhlIHNlY29uZCBpdGVtIHRvIGNvbXBhcmVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzb3J0TnVtYmVycyhkMSwgZDIpIHtcbiAgcmV0dXJuICgoZDEgJiYgZDEudmFsdWUpIHx8IC1JbmZpbml0eSkgLSAoKGQyICYmIGQyLnZhbHVlKSB8fCAtSW5maW5pdHkpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBvYmplY3RHZXROZXN0ZWRQcm9wZXJ0eSBhcyBnbnAgfSBmcm9tICcuLi9saWJzL2JvLXV0aWxzLWNsaWVudCc7XG5cbi8qKlxuICpcbiAqIHZhbHVlRm9ybWF0dGVyUGVyY2VudENoYW5nZVxuICpcbiAqIEBwYXJhbSB7fVxuICogQHJldHVybiB7fVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsdWVGb3JtYXR0ZXJQZXJjZW50Q2hhbmdlKHBhcmFtcykge1xuXG4gIGNvbnN0IHZhbHVlID0gZ25wKHBhcmFtcywgJ3ZhbHVlLnZhbHVlJyk7XG4gIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKS50b0ZpeGVkKDIpO1xuXG4gIHJldHVybiBpc05hTihudW0pID8gJy0nIDogYCR7bnVtfSVgO1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBvYmplY3RJc09iamVjdCBhcyBpc09iamVjdCB9IGZyb20gJy4uL2xpYnMvYm8tdXRpbHMtY2xpZW50JztcblxuLyoqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG4gIGxldCB1cCA9IDA7XG4gIGxldCBkbiA9IDA7XG4gIGxldCBuYyA9IDA7XG4gIGZvciAoa2V5IG9mIE9iamVjdC5rZXlzKGRhdGEpKSB7XG4gICAgaWYgKCFkYXRhW2tleV0pIGNvbnRpbnVlO1xuICAgIHZhbCA9IGRhdGFba2V5XVsnY2MtdG90YWwtdm9sLWZ1bGwtQ0hBTkdFUENUREFZJ107XG4gICAgaWYgKHZhbCA+IDApIHVwKys7XG4gICAgZWxzZSBpZiAodmFsIDwgMCkgZG4rKztcbiAgICBlbHNlIG5jKys7XG4gIH1cblxuICBjb25zdCB0b3RhbCA9IHVwICsgZG4gKyBuYztcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSAnLSc7XG4gIGxldCB1cFBlciA9IE1hdGguZmxvb3IodXAgLyAodG90YWwgLyAxMDApKTtcbiAgbGV0IGRuUGVyID0gTWF0aC5mbG9vcihkbiAvICh0b3RhbCAvIDEwMCkpO1xuICBsZXQgbmNQZXIgPSBNYXRoLmZsb29yKG5jIC8gKHRvdGFsIC8gMTAwKSk7XG4gIHVwUGVyID0gaXNOYU4odXBQZXIpID8gcGxhY2Vob2xkZXIgOiB1cFBlcjtcbiAgZG5QZXIgPSBpc05hTih1cFBlcikgPyBwbGFjZWhvbGRlciA6IGRuUGVyO1xuICBuY1BlciA9IGlzTmFOKHVwUGVyKSA/IHBsYWNlaG9sZGVyIDogbmNQZXI7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaC1kaXJlY3Rpb24gLmNoLXVwIC5jaC12YWwnKS5pbm5lckhUTUwgPSBgJHt1cFBlcn0lYDtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNoLWRpcmVjdGlvbiAuY2gtZG4gLmNoLXZhbCcpLmlubmVySFRNTCA9IGAke2RuUGVyfSVgO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2gtZGlyZWN0aW9uIC5jaC1uYyAuY2gtdmFsJykuaW5uZXJIVE1MID0gYCR7bmNQZXJ9JWA7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaC1kaXJlY3Rpb24gLmNoLXRvdGFsIC5jaC12YWwnKS5pbm5lckhUTUwgPSBgJHt0b3RhbH1gO1xuXG59XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9